/// <reference path="jquery.d.ts" />
/// <reference path="jquery.validation.d.ts" />
/// <reference path="jquery-validation-unobtrusive.d.ts" />
/// <reference path="sammyjs.d.ts" />
/// <reference path="extenders.d.ts" />
declare namespace WebClient {
    /** Базовый класс клиентского расширения Web-клиента. */
    abstract class BasicExtension implements IExtension {
        /** Вызывается при регистрации расширения. */
        initialize(): void;
        /** При переопределении в производных классах служит для добавления адресов в {@link urls} */
        getUrls(urlResolver: UrlResolver): IUrlMap;
        /** При переопределении в производных классах служит для добавления локализаций в {@link resources} */
        getLocalizations(): ILocalizationsMap;
    }
}
declare namespace WebClient {
    /** @internal */
    class LayoutExtension extends BasicExtension {
        constructor();
        initialize(): void;
        protected addLegacyCardTypes(): void;
        protected getCaption(name: string): string;
        getUrls(urlResolver: UrlResolver): IUrlMap;
        getLocalizations(): ILocalizationsMap;
    }
}
declare namespace WebClient {
    /** @internal */
    type $MainContentElementId = {
        mainContentElementId: string;
    };
    /** Основной класс для отображения разметок и получения к ним доступа. */
    class LayoutManager {
        protected services: $SiteUrl & $ApplicationTimestamp & $LayoutCardController & $Locale;
        protected layoutContainer: LayoutContainer;
        protected rootElementId: string;
        /** Note, on view layouts save can be performed multiple times. On edit and create it should be performed once. */
        protected pageLeaveConfirmationDisabled: boolean;
        protected layoutContainers: ILayoutContainerMap;
        protected layoutCardLayoutPosition: string;
        protected layoutUnloading: CancelableEvent<IEventArgs>;
        protected layoutUnloaded: SimpleEvent<IEventArgs>;
        protected prevConfirmationModal: ModalWindow;
        /** @internal */
        constructor(mainContentElementId: string, services?: $SiteUrl & $ApplicationTimestamp & $LayoutCardController & $Locale);
        /** @deprecated */
        readonly RootHtmlElement: HTMLElement;
        /** @deprecated */
        readonly IsCardSaved: boolean;
        /** Если в данный момент в Web-клиенте открыта карточка, то возвращает ее разметку. */
        readonly cardLayout: Layout;
        /** Событие, возникающее перед закрытием разметки.  */
        readonly LayoutUnloading: ICancelableEvent<IEventArgs>;
        /** Событие, возникающее после закрытия разметки.  */
        readonly LayoutUnloaded: SimpleEvent<IEventArgs>;
        /** Открывает разметку карточки на месте основного содержимого Web-клиента. */
        showCard(model: GenModels.LayoutCardViewModel, name?: string, owner?: string): JQueryDeferred<Layout>;
        /**
         * @deprecated Use showLayout instead
         */
        show(root: HTMLElement | string, name: string, model: GenModels.LayoutViewModel): JQueryDeferred<Layout>;
        /** Открывает разметку. */
        showLayout({root, name, model, owner, layoutPosition}: ShowLayoutParams): JQueryDeferred<Layout>;
        /** Возвращает разметку по имени экземпляра. */
        getLayout(name: string): Layout;
        /** Возвращает имя разметки, заполняющей место основного содержимого Web-клиента. */
        getCurrentLayoutName(): string | undefined;
        /** Возвращает описание разметки по имени экземпляра. */
        getLayoutModel(name: string): GenModels.LayoutViewModel | GenModels.LayoutCardViewModel;
        /** Отключает запрос подтверждения при закрытии страницы или переходе на другую страницу. */
        disablePageLeaveConfirmation(): void;
        /** Удаляет карточку. */
        deleteCard(cardId?: string): JQueryDeferred<any>;
        /** Равносильно нажатию кнопки "Назад" в браузере. */
        back(): void;
        /** @internal */
        protected createLayout({layoutCardModel, owner, name, root, positionName}: {
            layoutCardModel: GenModels.LayoutCardViewModel;
            owner?: string;
            name?: string;
            root?: string | HTMLElement;
            positionName?: string;
        }): {
            layoutContainer: LayoutContainer;
            deferred: JQueryDeferred<Layout>;
        };
        /** @internal */
        protected readonly siteUrl: string;
        /** Временная метка запуска сервера. */
        protected readonly applicationTimestamp: number;
        /** @internal */
        protected unmountCallback(name: string): void;
        /** @internal */
        protected loadExtensions(services: $SiteUrl & $ApplicationTimestamp & $LayoutCardController & $Locale): void;
        /** @internal */
        protected initialize(model: GenModels.LayoutCardViewModel): void;
        /** Закрывает разметку с указанным именем экземпляра. */
        destroy(name?: string): JQueryDeferred<any>;
        /** Обновляет внешний вид Web-клиента на основе стилей, заданных для указанного типа карточки. */
        protected updateFolderStyle(cardTypeId: string): void;
        /** @internal */
        protected reactJsUnmount(): void;
        /** @internal */
        onBeforeWindowUnload(e: any): string;
        /** @internal */
        onWindowUnload(ev: any): void;
    }
    /** Сервис отображения разметок и получения к ним доступа. */
    type $LayoutManager = {
        layoutManager: LayoutManager;
    };
}
declare var layoutManager: WebClient.LayoutManager;
/** @internal */
declare function documentViewCardOpened(sender: WebClient.LayoutControl, e: WebClient.IEventArgs): void;
/** @internal */
declare function documentViewHeaderMouseOver(sender: WebClient.LayoutControl, e: WebClient.IEventArgs): void;
/** @internal */
declare function documentViewHeaderMouseOut(sender: WebClient.LayoutControl, e: WebClient.IEventArgs): void;
/** @internal */
declare function documentSaving(sender: WebClient.LayoutControl, e: WebClient.ICancelableEventArgs<WebClient.GenModels.SaveControlDataModel>): boolean;
declare class DocumentManagementPatnerControlSync {
    senderInternalChange: boolean;
    /** ���������� ������� ������ ����������� ����������� � �������� �������� ��������� ���������. @review */
    updateEmployeeFromDepartment(employee: WebClient.Partner, department: WebClient.Department): Promise<void>;
    /** ���������� ������� ������ ���������� ����������� ����������� � �������� �������� ��������� ���������. @review */
    updateDepartmentFromEmployee(department: WebClient.Department, employee: WebClient.Partner): void;
}
/** @internal */
declare function documentCreateMainFileAdding(sender: WebClient.LayoutControl, e: WebClient.ICancelableEventArgs<WebClient.IMainFileAddingArgs>): void;
declare var incomingDocumentPartnerSync: DocumentManagementPatnerControlSync;
/** Обработчик события выбора организации отправителя в разметке создания Входящего документа. @review */
declare function incomingDocument_partnerDepartmentChanged(senderDepartment: WebClient.Department, e: WebClient.IDataChangedEventArgsEx<WebClient.GenModels.DepartmentModel>): Promise<void>;
/** Обработчик события выбора сотрудника организации отправителя в разметке создания Входящего документа. @review */
declare function incomingDocument_partnerEmployeeChanged(senderEmployee: WebClient.Partner, e: WebClient.IDataChangedEventArgsEx<WebClient.GenModels.EmployeeDataModel>): void;
declare var outgoingDocumentPartnerSync: DocumentManagementPatnerControlSync;
/** @internal  */
declare function outgoingDocument_loadPartnerDepartmentsInfo(sender: WebClient.LayoutControl): Promise<void>;
declare function outgoingDocument_updatePartnerDepartmentsOnEdit(sender: WebClient.LayoutControl): Promise<void>;
/** @internal */
declare function outgoingDocument_clearEmptyPartnersTableRows(sender: WebClient.LayoutControl): JQueryPromise<{}>;
/** @internal */
declare function outgoingDocumentViewCardOpened(sender: WebClient.LayoutControl, e: WebClient.IEventArgs): void;
/** @internal */
declare function outgoingDocumentSaving(sender: WebClient.LayoutControl, e: WebClient.ICancelableEventArgs<WebClient.GenModels.SaveControlDataModel>): void;
/** Обработчик события выбора организации отправителя в разметке создания Исходящего документа. @review */
declare function outgoingDocument_partnerDepartmentChanged(sender: WebClient.Department, e: WebClient.IDataChangedEventArgsEx<WebClient.GenModels.DepartmentModel>): void;
/** Обработчик события выбора сотрудника организации отправителя в разметке создания Исходящего документа. @review */
declare function outgoingDocument_partnerEmployeeChanged(sender: WebClient.Partner, e: WebClient.IDataChangedEventArgsEx<WebClient.GenModels.EmployeeDataModel>): void;
declare namespace WebClient {
    /** @internal */
    class Constants {
        static DeviceTypePrefixName: string;
        static HeaderWrapperElementId: string;
        static HeaderFolderNameElementId: string;
        static CompanyLogoElementId: string;
        static SidebarButtonCloseId: string;
        static SidebarButtonPinnId: string;
        static SidebarButtonOpen: string;
        static SidebarElementId: string;
        static SidebarButtonSwitchViewId: string;
        static FilePreviewElementId: string;
        static FileLinkClassName: string;
        static CommandsElementId: string;
        static SearchPanelId: string;
        static SearchInputId: string;
        static SearchTextInputId: string;
        static SearchClearButtonId: string;
        static SearchMobileContainerId: string;
        static SearchButtonId: string;
        static SearchDropdownId: string;
        static ResourcesGlobalContainterId: string;
        static ProgressBarElementId: string;
        static ProgressBarSpinnerElementId: string;
        static HeaderAddItemButton: string;
        static HeaderBackButton: string;
        static GridContainerId: string;
        static GridTableId: string;
        static GridDefaultPageSize: number;
        static MobileGridDefaultSize: number;
        static GridFilterDivId: string;
        static GridFilterContainerId: string;
        static SelectViewsContainerId: string;
        static SelectViewsBtnId: string;
        static SelectViewsListId: string;
        static NavigatorButtonsClass: string;
        static NavigatorPanelBtnTitleClass: string;
        static UserMenuId: string;
        static UserMenuButtonId: string;
        static UserMenuAboutButtonId: string;
        static UserMenuExitButtonId: string;
        static UserMenuChangeUserButtonId: string;
        static MobileSizeBorder: number;
        static GuidEmpty: string;
        static NewDigestId: string;
        static SearchResultsFolder: string;
        static SizeInKBytes: number;
        static SizeInMBytes: number;
        static SizeInGBytes: number;
        static DocumentCard: string;
        static TaskCard: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class Sidebar {
        private services;
        private mainMenuLayoutPosition;
        private mainMenuElementId;
        private model;
        private content;
        private btnPinn;
        private btnOpen;
        private linkSwitchView;
        private isPinned;
        private isClosed;
        private canResize;
        private maxResizeWidth;
        private minResizeWidth;
        private deviceType;
        private isBusy;
        private traceProvider;
        toggle?: BasicApiEvent<boolean>;
        constructor(services: $DeviceType & $LocalStorage);
        readonly IsClosed: boolean;
        readonly CanResize: boolean;
        IsPinned: boolean;
        DeviceType: GenModels.DeviceType;
        readonly Model: HTMLElement;
        readonly MinResizeWidth: number;
        readonly MaxResizeWidth: number;
        close(): void;
        open(): void;
        SaveSettings(): void;
        LoadSettings(): void;
        LoadLayout(): JQueryDeferred<any>;
        private SwitchView();
        private Initialize();
        private AddHideOnDocumentClickEvent();
        private toogle(element, hide?, isInline?);
        ResetSettings(): void;
        ReInitialize(): void;
    }
    /** @internal */
    type $Sidebar = {
        sidebar: Sidebar;
    };
}
interface ActiveXObject {
    new (s: string): any;
}
declare var ActiveXObject: ActiveXObject;
declare namespace WebClient {
    /**
     * Ключ для обозначения сервисов, которые должны быть переинициализированы в контексте конкретной разметки.
     *
     * Для применения необходимо передать данное значение третьим параметром в метод {@link ServiceContainer.registerService}
     */
    const LAYOUT_SERVICE: {
        isLayoutService: boolean;
    };
    /** @internal */
    class Helpers {
        constructor();
        static GetTarget(event: Event): HTMLElement;
        static GetDateSeparator(): string;
        static HideCaption(): void;
        static ShowCaption(): void;
        static UpdateCaption(headerText?: string, color?: string): void;
        static GetKindNameFromFullString(str: string): string;
        static GetFileExtension(fileName: string): string;
        static SetNumericControl(control: HTMLElement, callback?: Function): void;
        static InsertAfter(newElement: any, targetElement: any): void;
        static CapitalizeFirstLatter(str: string): string;
        private toogle(element, hide?, isInline?);
        static RunScripts(element: HTMLElement): void;
        private static RunScriptsHelper(element);
        static LoadAndRunScript(url: string): JQueryXHR;
        static DisplayFileSize(fileSize: number): string;
        static CheckCardModified(cardId: string, timestamp: string, callback?: Function): JQueryDeferred<any>;
        static CheckCardLocked(cardId: string, callback?: Function): JQueryDeferred<any>;
        static CheckKindCreatable(cardTypeId: string, cardKindId: string, callback: Function): void;
        /**
         * Показать предпросмотр файла.
         * @param options Список опций.
         */
        static ShowFilePreviewDialog(props: IFilePreviewProps, options?: {
            onClose?: () => void;
            onMount?: () => void;
        }): void;
        /** @deprecated Use {@link ShowFilePreviewDialog} */
        static ShowFilePreview(url: string, title: string, delCommentUrl?: string, editCommentUrl?: string): void;
        /** @deprecated Use {@link ShowFilePreviewDialog} */
        static ShowFilePreviewEx(previewContent: any, title: any, delCommentUrl?: string, editCommentUrl?: string): void;
        /**
         * Показать список комментариев файла.
         * @param options Список опций.
         * @returns Функция, вызов которой закрывает модальное окно
         */
        static ShowFileComments(props: IFileCommentsModalProps, options?: {
            onClose?: () => void;
        }): () => void;
        static ValidateForm(form: HTMLFormElement): boolean;
        static FindParentElement(element: HTMLElement, parentClassName: string): HTMLElement;
        static SupressEvents(e: Event): void;
        static FloatToCultureStr(num: number, precision?: number): string;
        static ParseFloatCultureStr(str: string): number;
        private static LegacyValidation(field);
        static Base64Encode(arrayBuffer: any): string;
        static Base64ArrayBuffer(arrayBuffer: any): string;
        static IsEdge(): boolean;
        static SetTooltip(element: HTMLElement): void;
        static SetTooltipFor(element: HTMLElement, text: string, extraOptions?: Object): void;
        static DestroyTooltips(element: HTMLElement): void;
        static ClearTips(): void;
        static LocationReload(): void;
        static GetCurrentDeviceType(): GenModels.DeviceType;
        static GetOriginalDeviceType(): GenModels.DeviceType;
        static GetIEVersion(): {};
        static CallCancelableIf(callback: Function, ...args: any[]): JQueryDeferred<any>;
        static CallIf(callback: Function, ...args: any[]): any;
        /** @deprecated Use Promise.all */
        static WhenAll(deferreds: JQueryDeferred<any>[]): JQueryDeferred<any>;
        static guidPattern: RegExp;
        static validGuid(guid: string): RegExpMatchArray;
        static iterateAsync<T>(collection: T[], func: (item: T) => JQueryDeferred<any>): JQueryDeferred<any>;
        private static iterateAsyncNext<T>(collection, func, currentIndex, total);
        static promiseToDeferred<T>(promise: Promise<T>): JQueryDeferred<T>;
        /** @deprecated Use deferredToPromise instead */
        static deferredtoPromise<T>(def: JQueryDeferred<T>): Promise<T>;
        static deferredToPromise<T>(def: JQueryDeferred<T>): Promise<T>;
        static getHashCode(str: string): number;
    }
    /** @internal */
    class Animate {
        static SetEndCallback(htmlElement: HTMLElement, func: any): void;
    }
    /** @internal */
    class SessionStorage {
        static SupportsSessionStorage(): boolean;
        static SaveData(id: string, obj: any): boolean;
        static LoadData(id: string): any;
    }
    /** @internal */
    class ErrorHelper {
        static ThrowIfElementNotFound(htmlElement: HTMLElement): void;
        static ThrowIfElementIdNotFound(elementWithId: string): void;
        static ThrowIfNull(request: XMLHttpRequest): void;
        static RequestNotSupported(): void;
        static RequestError(errorText: string): void;
        static CertificateNotFound(errorText: string): void;
    }
    /** Класс для доступа к системным серверным параметрам. */
    class ResourcesHelper {
        static ResourcesContainerName: string;
        static GetGlobalResource(resourceName: string): string;
        static SetGlobalResource(resourceName: string, resourceValue: any): void;
        static GetResource(container: HTMLElement, resourceName: string): string;
    }
    /** Затемнение на весь экран с отображением анимации загрузки. */
    class ProgressOverlay {
        private progressOverlay;
        private overlayTimeout;
        private static OverlayElementId;
        /** Таймаут показа затемнения. */
        Timeout: number;
        /** Показывает затемнение через {@link Timeout} мс., если к этому моменту не будет вызван {@link HideOverlay}. */
        ShowOverlay(): void;
        /** Скрыть затемнение. */
        HideOverlay(): void;
        private DestroyOverlay();
        private GetOrCreteateOverlay();
    }
    /** @internal */
    type RequestCustomCompleteCallback = (request: XMLHttpRequest, callerCallback: Function) => void;
    /** @internal */
    enum LoadingBarValues {
        Start = 1,
        OneFourth = 25,
        Half = 50,
        AfterHalf = 60,
        ThreeFourth = 75,
        Full = 100,
        None = 0,
    }
    /** Опции создания {@link Request}. */
    interface RequestOptions {
        /** Выполнять ли запрос асинхронном режиме (по умолчанию true). */
        isAsync?: boolean;
        /** Отключить кеширование запроса (по умолчанию true). */
        noCache?: boolean;
        /** Показывать ли затемнение на весь экран (по умолчанию false). */
        isShowOverlay?: boolean;
        /** Показывать ли прогресс выполнения запроса в верхней части приложения (по умолчанию true). */
        isShowLoadingBar?: boolean;
    }
    /** Обертка вокруг XMLHttpRequest с отображением прогресс-бара и обработкой ошибок. */
    class Request {
        private static ActiveRequests;
        private static LoadingBarElementId;
        private static LoadingBarWrapperElementId;
        /** @internal */
        static ContentTypeForm: string;
        private isAsync;
        private responseType;
        private contentType;
        private dataType;
        private isShowOverlay;
        private isShowLoadingBar;
        private customErrorCallback;
        private customCriticalErrorCallback;
        private customCompleteCallback;
        private progressOverlay;
        private isForm;
        private noCache;
        /** Инициализирует объект. */
        constructor(options?: RequestOptions);
        /** Режим выполнения запроса. */
        IsAsync: boolean;
        /** Отключено ли кеширование для запроса. */
        NoCache: boolean;
        /** Тип данных, передаваемых с запросом. По умолчанию 'application/json; charset=UTF-8;'. */
        ContentType: string;
        /** Собственный обработчик ситуации, когда запрос завершился с ошибкой. */
        CustomErrorCallback: Function;
        /** Собственный обработчик ситуации, когда запрос завершился с ошибкой. */
        CustomCriticalErrorCallback: Function;
        /** Собственный обработчик успешного завершения запроса. */
        CustomCompleteCallback: RequestCustomCompleteCallback;
        /** Тип данных ответа. */
        ResponseType: XMLHttpRequestResponseType;
        /** Отображать ли затемнение экрана во время выполнения запроса. */
        IsShowOverlay: boolean;
        /** Отображать ли ход выполнения запроса в верхней части приложения. */
        IsShowLoadingBar: boolean;
        /** @internal */
        /** @internal */
        ShowLoadingBar: boolean;
        private SetLoadingBar(value);
        /** Ожидаемый тип возвращаемых с сервера данных. */
        DataType: string;
        /** Отправляет запрос методом POST. */
        PostData(url: string, requestData: any, callback: Function): void;
        /** Отправляет запрос методом POST. */
        PostDataEx(url: string, requestData: any): JQueryDeferred<any>;
        /** Отправляет запрос методом POST без обработки ошибок. */
        PostDataSilent(url: string, requestData: any): JQueryDeferred<any>;
        /** Отправляет запрос методом GET. */
        GetData(url: string, requestData: any, callback: Function): void;
        /** Отправляет запрос методом GET. */
        GetDataEx(url: string, requestData: any): JQueryDeferred<any>;
        private ProcessRequest(url, requestData, callback, method);
        private ProcessRequestEx(url, requestData, method, showErrorDialog?);
        private static ParseError(httpRequest, customErrorCallback, customCriticalErrorCallback?);
        private static GetRequestInstance();
    }
    /** @internal */
    class TabsHelper {
        static AddTabEvents(tabElement: HTMLElement): void;
    }
    /**
     * Утилита для исключения дублирования запуска длительных операций.
     *
     * Для использования необходимо создать экземпляр класса, и запускать операцию
     * через его метод perform. Если на момент вызова операция будет находится в процессе выполнения
     * с предыдущего раза, то вызов будет проигнорирован.
     *
     * Данная логика может быть использована при реализации запросов к серверу при нажатии на кнопку.
     * Использование данной утилиты исключает ситуацию отправки повторного запроса при двойном нажатии
     * кнопки пользователем.
     *
     * Пример использования:
     *
     *      let once = new PerformOnce();
     *      button.addEventListener("click", () => {
     *          once.perform(() => makeServerRequest());
     *      });
     */
    class PerformOnce {
        performing: boolean;
        /** Выполняет операцию, если она уже не находится в процессе выполнения. */
        perform(func: () => JQueryDeferred<any> | Promise<any>): JQueryDeferred<any>;
    }
    /** @internal */
    class CardCommandButtonsHelper {
        static AddRefreshButtonEvents(selectorQuery: string): void;
        static AddEditButtonEvents(selectorQuery: string, widgetId?: string): void;
        static AddDeleteButtonEvents(selectorQuery: string, widgetId?: string): Promise<void>;
    }
    /** @internal */
    class DateTimeHelper {
        static GetLocaleFormat(locale: string): DateTimeFormat;
    }
    /** @internal */
    class EventHelper {
        static Change(element: HTMLElement): void;
        static WindowResize(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderViewRequestViewModel {
        private folderId;
        private folderUri;
        private queryId;
        private viewid;
        private searchId;
        private sourceType;
        private viewSourceId;
        private folderType;
        private searchContextOption;
        private fullTextFilter;
        private querySearchId;
        private filters;
        hasSearchParametrs: boolean;
        parameters: any;
        PageNumber: string;
        SortedColumnName: string;
        IsDescending: string;
        oldStoreId: string;
        RefreshView: boolean;
        folderRefreshTimeout: number;
        forceVirtualFolderSearch: boolean;
        constructor();
        Filters: any;
        readonly FolderType: NavigatorFolderType;
        FolderId: string;
        ViewId: string;
        SearchContextOption: string;
        FullTextFilter: string;
        ViewSourceId: string;
        QuerySearchId: string;
        SearchId: string;
        GetFolderData(element: HTMLElement): void;
    }
}
declare namespace WebClient {
    /** @internal */
    enum SourceFolderType {
        Generic = 0,
        Folder = 1,
        VirtualFolder = 2,
    }
}
declare namespace WebClient {
    /** @internal */
    class ModalWindowEvents {
        beforeShowCallback: Function;
        afterShowCallback: Function;
        beforeCloseCallback: Function;
        closingCallback: () => JQueryDeferred<any>;
        afterCloseCallback: Function;
        beforeDestroyCallback: Function;
        afterDestroyCallback: Function;
    }
    /** @internal */
    class ModalWindowParams extends ModalWindowEvents {
        modalType: ModalWindowType;
        modalClassName: string;
        content: string;
        contentClassName: string;
        headerText: string;
        buttonsClassName: string;
        buttonsReverse: boolean;
        buttonOkClassName: string;
        buttonOkShow: boolean;
        buttonOkText: string;
        buttonOkFunction: Function;
        buttonCancelClassName: string;
        buttonCancelShow: boolean;
        buttonCancelText: string;
        buttonCancelFunction: Function;
        buttons: Array<ModalButton>;
        replaceDefaultButtons: boolean;
    }
    /** @internal */
    class ModalButton {
        buttonClassName: string;
        buttonShow: boolean;
        buttonText: string;
        buttonFunction: Function;
        constructor(text: string, callback: Function, className?: string, visible?: boolean);
        Visible: boolean;
        Text: string;
        CssClassName: string;
        Callback: Function;
        static DefaultButtonOK(text: string, callback: Function): ModalButton;
        static DefaultButtonCancel(text: string, callback: Function): ModalButton;
    }
}
declare namespace WebClient {
    /** @internal */
    class Grid {
        private targetElement;
        private rootElement;
        private tableHeader;
        private tableBody;
        private gridFooter;
        private isMobileBuilt;
        private isDesktopBuilt;
        private htmlBuilder;
        model: GenModels.GridViewModel;
        options: GridOptions;
        private readonly IsMobileBuilt;
        private readonly IsDesktopBuilt;
        constructor(element: HTMLElement, model: GenModels.GridViewModel, options: GridOptions, htmlBuilder: IGridHtmlBuilder);
        onModelChange: (sender: any, model: any) => void;
        private initialize();
        private refreshLayoutToMakeIEBugsRunAway(mainTable);
        rebuildIfNeeded(): void;
        applyFilters(): void;
        /**
         * Возвращает загруженные с сервера новые данные грида
         */
        getChanges(): Promise<GenModels.GridViewModel>;
        /**
         * Визуальное уведомление о необходимости обновить грид
         */
        showUpdateRequest(show?: boolean): void;
        readonly refreshed: SimpleEvent<void>;
        isSearching(): string;
        /**
         * Is two grid models equal
         * @param model1 First grid model
         * @param model2 Second grid model
         * @param ignoreMeta Ignore meta data differences or not
         * @param ignoreReadStatus Ignore read status or not
         * @param paramsToCheck Row params to check on differences
         */
        static isEqual(model1: GenModels.GridViewModel, model2: GenModels.GridViewModel, ignoreMeta?: boolean, ignoreReadStatus?: boolean, paramsToCheck?: string[]): boolean;
    }
}
declare namespace WebClient {
    /** Служебный тип, используемый в {@link ServiceContainer}. */
    type ServiceGetter<T = any> = (services) => T;
    /** Служебный тип, используемый в {@link ServiceContainer}. */
    type ServiceSetter<T = any> = (instance: T, services) => void;
    /** Информация о сервисе, используемая в {@link ServiceContainer} */
    interface ServiceDescriptor<T = any> {
        name: string;
        factory?: (services) => T;
        meta: object;
        instance?: T;
        get?: ServiceGetter<T>;
        set?: ServiceSetter<T>;
    }
    /** Служебный тип, используемый в {@link ServiceContainer}. */
    type ServiceContainerFluentNext<T> = (services: T) => void;
    /** Служебный тип, используемый в {@link ServiceContainer}. */
    type ServiceContainerFluent<T> = {
        then: (next: ServiceContainerFluentNext<T>) => void;
    };
    /** Помечает, что сервис необязателен для работы. */
    type Optional<T> = Partial<T>;
    /** Служебный тип, используемый в {@link ServiceContainer}. */
    type Factories<$T> = {
        [P in keyof $T]: (services) => $T[P];
    };
    /**
     * Вспомогательный класс, позволяющий объявлять сервисные контейнеры с lazy-инициализацией свойств и хранением мета-информации о сервисах.
     *
     * Подробнее о сервисных контейнерах см. [статью в нашем блоге](https://habrahabr.ru/company/docsvision/blog/350398/).
     */
    class ServiceContainer {
        protected services: {
            [serviceName: string]: ServiceDescriptor;
        };
        /**
         * Добавляет новый сервис
         * @param name Имя сервиса (имя переменной), по которому к нему будут обращаться.
         * @param service Экземпляр сервиса
         * @param T Тип сервиса
         */
        registerService<T>(name: FieldSpec<any, T>, service: T, meta?: object): void;
        /**
         * Добавляет сервисы из контейнера
         * @param name Имя сервиса (имя переменной), по которому к нему будут обращаться.
         * @param service Экземпляр сервиса
         * @param T Тип сервиса
         */
        addFluent<$T>(container: $T, meta?: object): ServiceContainerFluent<this & $T>;
        /**
        * Добавляет сервисы из контейнера
        * @param name Имя сервиса (имя переменной), по которому к нему будут обращаться.
        * @param service Экземпляр сервиса
        * @param T Тип сервиса
        */
        addService<$T>(container: $T, meta?: object): this & $T;
        /**
       * Добавляет сервисы из контейнера
       * @param container Объект, в котором ключи - имена сервисов, значения - фабричные методы сервисов.
       * @param service Экземпляр сервиса
       * @param T Тип сервиса
       */
        addServiceFactory<$T>(container: Factories<$T>, meta?: object): this & $T;
        /**
         * Добавляет новый сервис, экземпляр которого создается при первом обращении
         * @param name Имя сервиса (имя переменной), по которому к нему будут обращаться.
         * @param service Метод, который принимает параметром текущий контейнер и возвращает экземпляр сервиса.
         * @param T Тип сервиса
         */
        registerServiceFactory<T>(name: FieldSpec<any, T>, serviceFactory: (services) => T, meta?: object): void;
        /**
         * Добавляет новый сервис, доступ к экземпляру которого осуществляется через специальные методы.
         * @param name Имя сервиса (имя переменной), по которому к нему будут обращаться.
         * @param get Метод, возвращающий экземпляр сервиса
         * @param set Метод, устаналивающий новый экземпляр сервиса
         * @param T Тип сервиса
         */
        registerServiceAccessors<T>(name: FieldSpec<any, T>, get: ServiceGetter<T>, set?: ServiceSetter<T>, meta?: object): void;
        /**
         * Добавляет новый сервис
         * @param serviceDescriptor Информация о сервисе
         * @param T Тип сервиса
         */
        registerServiceDesciptor<T>(serviceDescriptor: ServiceDescriptor): void;
        /**
         * Отменяет регистрацию севриса
         * @param name Имя сервиса (имя переменной), по которому к нему обращаются.
         */
        unregisterService<T>(name: FieldSpec<any, T>): void;
        /**
         * Вспомогательный метод, позволяющий сообщить TypeScript, что сервис был ранее зарегистрирован через вызов {@link registerService}.
         * @param T Тип контейнера, содержащего необходимый сервис. Например, {@link $LayoutController}.
         * @returns this
         *
         * Пример использования:
         *
         *     export type $MyService = { myService: MyService };
         *     serviceContainer.register("myService", () => new MyService());
         *     serviceContainer.with<$MyService>().myService.doSomething();
         */
        with<T>(): this & T;
        /**
        * Вспомогательный метод, позволяющий сообщить TypeScript, что сервис был ранее зарегистрирован через вызов {@link registerService}.
        * @param T Тип контейнера, содержащего необходимый сервис. Например, {@link $LayoutController}.
        * @returns this
        *
        * Пример использования:
        *
        *     export type $MyService1 = { myService1: MyService1 };
        *     export type $MyService2 = { myService2: MyService2 };
        *     function foo(service: $MyService1 & $MyService2) {}
        *
        *     let myService1 = serviceContainer.addService<$MyService1>({ myService1: new MyService1()});
        *     let myService2 = serviceContainer.addService<$MyService2>({ myService2: new MyService2()});
        *     foo(serviceContainer.withAll(myService1, myService2));
        */
        withAll<T>(c: T): this & T;
        withAll<T1, T2>(c1: T1, c2: T2): this & T1 & T2;
        withAll<T1, T2, T3>(c1: T1, c2: T2, c3: T3): this & T1 & T2 & T3;
        withAll<T1, T2, T3, T4>(c1: T1, c2: T2, c3: T3, c4: T4): this & T1 & T2 & T3 & T4;
        /**
         * Получение зарегистрированного сервиса по имени.
         * Вместо использования этого метода можно обращаться напрямую к свойству контейнера (`container[name]`).
         * @param name Имя сервиса (имя переменной), по которому к нему обращаются.
         * @returns Экземпляр сервиса
         */
        getService<T>(name: FieldSpec<any, T>): any;
        /**
         * Получение зарегистрированного сервиса по имени.
         * Вместо использования этого метода можно обращаться напрямую к свойству контейнера (`container[name]`).
         * @param name Имя сервиса (имя переменной), по которому к нему обращаются.
         * @returns Экземпляр сервиса
         */
        getServiceDescriptor<T>(name: FieldSpec<any, T>): ServiceDescriptor<T>;
        /**
         * Замена сервиса на указанный экземпляр.
         * @param name Имя сервиса (имя переменной), по которому к нему будут обращаться.
         * @param service Новый экземпляр сервиса.
         */
        setService<T>(name: FieldSpec<any, T>, service: T): void;
        /**
         * Копирует информацию о сервисах в указанный контейнер.
         */
        copyTo(container: ServiceContainer): void;
        /**
         * Создает копию текущего контейнера, со всеми зарегистрированными сервисами.
         */
        clone(): ServiceContainer;
        /**
         * Возвращает информацию о сервисах, удовлетворяющих некоторому условию.
         * @param predicat Условие отбора сервисов.
         */
        findDescriptors(predicat: (descriptor: ServiceDescriptor) => boolean): ServiceDescriptor[];
        /**
         * Освобождает экземпляры сервисов зарегистрированных через {@link registerServiceFactory}, удовлетворяющих условию.
         * При следующем обращении сервисы будут созданы заново.
         * Функция принимает параметром метаданные сервиса, и возвращает true если сервис нужно освободить, и false иначе.
         *
         * @param predicat Условие отбора сервисов на основе метаданных сервисов.
         */
        reinitializeFactoryServices<MetaT>(predicat: (metaKey: MetaT) => boolean): void;
    }
}
declare namespace WebClient {
    /** @internal */
    abstract class BasicEvent<T> implements IBasicEvent<T> {
        protected handlers: BasicEventHandler<T>[];
        protected mDefaultSender: () => LayoutControl;
        protected mEventInfo: IBublingEventInfo;
        constructor(sender: any, subscribers?: BasicEventHandler<T>[]);
        subscribe(handler: BasicEventHandler<T>): void;
        unsubscribe(handler: BasicEventHandler<T>): void;
        defaultSender: () => BaseControl<BaseControlParams, any>;
        protected triggerAll(sender?: any, data?: T): void;
        protected triggerBublingEvent(sender?: any, data?: T): void;
    }
}
declare namespace WebClient {
    /** Простое событие, без функциональности отмены. */
    class SimpleEvent<T> extends BasicEvent<T> {
        constructor(sender?: any, subscribers?: {
            (sender: any, args?: T): void;
        }[]);
        /** Уведомляет подписчиков о событии с передачей отправителя, указанного при создании события. */
        trigger(data?: T): void;
        /** Уведомляет подписчиков о событии. */
        triggerWith(sender: any, data?: T): void;
        /** Преобразует тип события к {@link SimpleEvent}. */
        static cast<T>(event: IBasicEvent<T> | BasicApiEvent<T> | string): SimpleEvent<T> & BasicEventHandler<T>;
        /** Создает экземпляр {@link SimpleEvent}. */
        static Create<T>(sender: any, subscriberFunc?: BasicApiEvent<T> | string): SimpleEvent<T> & BasicEventHandler<T>;
    }
}
declare var layoutManager: WebClient.LayoutManager;
declare namespace WebClient {
    /** Входная точка приложения Web-клиента. */
    class App extends ServiceContainer {
        private localization;
        private canPromise;
        private static logEnabled;
        private static isIE10;
        private static routeTimestampVal;
        private static isMobileSafary;
        private static initializedEvent;
        private traceProvider;
        /** Экземпляр приложения Web-клиента. */
        static Instance: App & $StandardControllers & $StandardServices;
        constructor();
        /**
         * Регистрирует сервис через вызов `App.Instance.registerService` при инициализации приложения (по событию {@link App.Initialized}).
         *
         * @see {@link ServiceContainer.registerService}
         */
        static registerService<T>(name: FieldSpec<any, T>, service: T, meta?: object): void;
        /**
         * Регистрирует сервис через вызов `App.Instance.registerServiceFactory` при инициализации приложения (по событию {@link App.Initialized}).
         *
         * @see {@link ServiceContainer.registerServiceFactory}
         */
        static registerServiceFactory<T>(name: FieldSpec<any, T>, serviceFactory: (services) => T, meta?: object): void;
        /**
         * Регистрирует сервис через вызов `App.Instance.registerServiceAccessors` при инициализации приложения (по событию {@link App.Initialized}).
         *
         * @see {@link ServiceContainer.registerServiceAccessors}
         */
        static registerServiceAccessors<T>(name: FieldSpec<any, T>, get: ServiceGetter<T>, set?: ServiceSetter<T>, meta?: object): void;
        /**
         * Регистрирует сервис через вызов `App.Instance.addService` при инициализации приложения (по событию {@link App.Initialized}).
         *
         * @see {@link ServiceContainer.addService}
         */
        static addService<$T>(container: $T, meta?: object): void;
        /**
         * Регистрирует сервис через вызов `App.Instance.addServiceFactory` при инициализации приложения (по событию {@link App.Initialized}).
         *
         * @see {@link ServiceContainer.addServiceFactory}
         */
        static addServiceFactory<$T>(container: Factories<$T>, meta?: object): void;
        /** Событие инициализации приложения. */
        static readonly Initialized: IBasicEvent<App>;
        /** Является ли текущий браузер IE10. */
        static readonly IsIE10: boolean;
        /** Логирование включено. */
        static LogEnabled: boolean;
        /** Временная метка роута - при смене роута она изменяется. */
        static readonly RouteTimestamp: number;
        /** Обновить {@link RouteTimestamp}. */
        static UpdateRouteTimestamp(): void;
        /** Является ли текущий браузер мобильной версией Safary. */
        static readonly IsMobileSafary: boolean;
        /** @internal */
        initialize(): void;
        /** Открыть домашнюю страницу. */
        GoToDashBoard(refresh?: boolean): Promise<void>;
        /** Скрыть логотип Docsvision в шапке приложения. */
        HideLogo(): void;
        /** Отобразить логотип Docsvision в шапке приложения. */
        ShowLogo(): void;
        /** Сбрасывает локальные настройки и кеши пользователя сохраненные в браузере. */
        ResetSettings(): Promise<void>;
        /** @deprecated */
        readonly CurrentFolderUri: string;
        /** @deprecated */
        LastSearchRequest: string;
        /** @deprecated Используйте сервис `{@link $UserMenu}`. */
        readonly UserMenu: UserMenu;
        /** @deprecated Используйте сервис `{@link $Sidebar}`. */
        readonly Sidebar: Sidebar;
        /** @deprecated Используйте сервис `{@link $FolderViews}`. */
        readonly FolderViews: FolderViews;
        /** @deprecated Используйте сервис `{@link $SearchPanel}`. */
        readonly SearchPanel: SearchPanel;
        /** @deprecated Используйте сервис `{@link $NavBar}`. */
        readonly NavBar: NavBar;
        /** @deprecated */
        readonly CompanyLogo: HTMLElement;
        /** @deprecated Используйте сервис `{@link $FullTextSearchEnabled}`. */
        readonly FullTextSearchEnabled: boolean;
        /** @deprecated  Используйте сервис `{@link $Router}`*/
        readonly SammyHelper: Router;
        /** @deprecated  Используйте сервис `{@link $Folders}`*/
        readonly Folders: Folders;
        /** @deprecated  Используйте сервис `{@link $UnreadCounter}`*/
        readonly UnreadCounters: UnreadCounter;
        /** @deprecated  Используйте сервис `{@link $DeviceType}`*/
        readonly DeviceType: GenModels.DeviceType;
        /** @deprecated  Используйте сервис `{@link $DeviceType}`*/
        readonly DefaultDeviceType: GenModels.DeviceType;
        /** @deprecated  Используйте сервис `{@link $InstalledCSP}`*/
        InstalledCSP: boolean;
        /** @deprecated  Используйте сервис `{@link $ApplicationTimestamp}`*/
        readonly ApplicationTimestamp: number;
        /** @deprecated */
        readonly Localization: any;
        /** @deprecated  Используйте сервис `{@link $SiteUrl}`*/
        readonly SiteUrl: string;
        /** @deprecated  Используйте сервис `{@link $LayoutManager}`*/
        readonly LayoutManager: any;
        /** @deprecated  Используйте сервис `{@link $RealtimeCommunicationService}`*/
        readonly RealtimeCommunicationService: RealtimeCommunicationService;
        /** @deprecated  Используйте сервис `{@link $CurrentEmployeeId}`*/
        readonly CurrentEmployeeId: string;
        private AddBackButtonEventClick(buttonId);
        private isApple();
        private DetectBrowsers();
    }
    var app: App & $StandardControllers & $StandardServices;
}
declare namespace WebClient {
}
declare namespace WebClient {
    /** @deprecated */
    interface IBasicEmployeeInfo {
        id: string;
        firstName: string;
        middleName: string;
        lastName: string;
        position: string;
        displayName: string;
        pathInDirectory?: IDepartmentInfo[];
    }
    /** @deprecated */
    interface IDelegationRecord {
        fromPerformer: string;
        toPerformer: string;
    }
    /** @deprecated */
    interface IDocumentTreeNodeModel extends ITreeNodeModel {
        name: string;
    }
    /** @deprecated */
    interface ITaskCurrentPerformer {
        displayName: string;
        employeeModel: IBasicEmployeeInfo;
    }
    /** @deprecated */
    interface ITaskGroupSelectedPerformer {
        displayName: string;
        isResponsiblePerformer: boolean;
        employeeModel: IBasicEmployeeInfo;
    }
    /** @deprecated */
    interface ITaskGroupTreeNodeHelpModel extends ITreeNodeHelpModel {
        executionType: ExecutionType;
        author: IBasicEmployeeInfo;
        selectedPerformers: ITaskGroupSelectedPerformer[];
        name: string;
        content: string;
        endDate: Date;
        controller: IBasicEmployeeInfo;
        controlDate: Date;
    }
    /** @deprecated */
    interface ITaskGroupTreeNodeHintModel extends ITreeNodeHintModel {
        name: string;
        endDate?: Date;
        executionType: ExecutionType;
        stateDisplayName: string;
        stateClassName: string;
        stateType: number;
        selectedPerformers: ITaskGroupSelectedPerformer[];
    }
    /** @deprecated */
    interface ITaskGroupTreeNodeModel extends ITreeNodeModel {
        executionType: ExecutionType;
        isOverdue: boolean;
        priority: Priority;
        stateCategory: TaskGroupStateCategory;
        onControl: boolean;
    }
    /** @deprecated */
    interface ITasksTreeModel {
        nodes: ITreeNodeModel[];
        edges: ITaskTreeEdge[];
    }
    /** @deprecated */
    interface ITasksTreeNodeHelpRequestModel {
        cardId: string;
        cardTypeId: string;
    }
    /** @deprecated */
    interface ITasksTreeRequestModel {
        cardId: string;
        taskListId: string;
        kindIds: string[];
        fullTree: boolean;
    }
    /** @deprecated */
    interface ITaskTreeEdge {
        fromNode: string;
        toNode: string;
    }
    /** @deprecated */
    interface ITaskTreeNodeHelpModel extends ITreeNodeHelpModel {
        author: IBasicEmployeeInfo;
        currentPerformers: ITaskCurrentPerformer[];
        delegationHint: IDelegationRecord;
        name: string;
        content: string;
        endDate: Date;
        controller: IBasicEmployeeInfo;
        controlDate: Date;
        isOverdue: boolean;
        endDateActual: Date;
        report: string;
        delegationHistory: IDelegationRecord[];
        creationDate: Date;
        reportFiles: ILinkItemData[];
    }
    /** @deprecated */
    interface ITaskTreeNodeHintModel extends ITreeNodeHintModel {
        name: string;
        endDate?: Date;
        stateDisplayName: string;
        stateClassName: string;
        stateType: number;
        delegationHint: IDelegationRecord;
    }
    /** @deprecated */
    interface ITaskTreeNodeModel extends ITreeNodeModel {
        hasDelegates: boolean;
        hasReport: boolean;
        hasFileReport: boolean;
        onControl: boolean;
        isResponsiblePerformerTask: boolean;
        gender: PerformerGender;
        isOverdue: boolean;
        priority: Priority;
        stateCategory: TaskStateCategory;
        currentPerformers: ITaskCurrentPerformer[];
    }
    /** @deprecated */
    interface ITreeNodeHelpModel {
    }
    /** @deprecated */
    interface ITreeNodeHintModel {
    }
    /** @deprecated */
    interface ITreeNodeModel {
        nodeId: string;
        cardTypeId: string;
        kindId: string;
        hint: ITreeNodeHintModel;
        accessAllowed: boolean;
    }
    /** @deprecated Use WebClient.GenModels.SearchContextOption instead */
    enum SearchContextOption {
        None = -1,
        CurrentFolder = 0,
        CurrentFolderAndSubFolders = 1,
        SearchInSearchResults = 2,
        EveryWhere = 3,
    }
    /** @deprecated Use WebClient.GenModels.ExecutionType instead */
    enum TaskExecutionType {
        Serial = 0,
        Parallel = 1,
    }
    /** @deprecated Use WebClient.GenModels.DvFolderStyles instead */
    enum FolderStyles {
        /**
          * None
          */
        None = 0,
        /**
          * View displayed
          */
        FolderView = 1,
        /**
          * Card displayed
          */
        FolderCard = 2,
        /**
          * HTML page displayed
          */
        FolderURL = 4,
        /**
          * Digest view displayed
          */
        FolderDigest = 8,
        /**
          * All
          */
        All = 15,
    }
    /** @deprecated */
    enum DeviceType {
        /**
         * Desktop
         */
        Desktop = 0,
        /**
         * Smartphone
         */
        Smartphone = 1,
        /**
         * Tablet
         */
        Tablet = 2,
    }
    /** @deprecated */
    enum ExecutionType {
        Serial = 0,
        Parallel = 1,
    }
    /** @deprecated */
    enum PerformerGender {
        NotSpecified = 0,
        Male = 1,
        Female = 2,
    }
    /** @deprecated */
    enum Priority {
        Low = 0,
        Normal = 1,
        High = 2,
    }
    /** @deprecated */
    enum TaskGroupStateCategory {
        Preparing = 0,
        Performing = 1,
        Completed = 2,
        Other = 3,
    }
    /** @deprecated */
    enum TaskGroupWithOneTaskDisplayMode {
        Both = 0,
        Group = 1,
        Task = 2,
    }
    /** @deprecated */
    enum TaskStateCategory {
        Preparing = 0,
        InWork = 1,
        Rejected = 2,
        OnRework = 3,
        Completed = 4,
        Other = 5,
    }
    /** @deprecated */
    enum TasksTreeDisplayMode {
        Button = 0,
        Layout = 1,
    }
    /** @deprecated */
    interface ITaskCreateInfo {
        displayName: string;
        isTemplate: boolean;
        createRouteName: string;
        id: string;
        cardTypeId: string;
        layoutAvailable: boolean;
    }
    /** @deprecated */
    interface ITaskListItem {
        cardId: string;
        kindId: string;
        taskName: string;
        viewRouteName: string;
        isGroupTask: boolean;
        stateDisplayName: string;
        stateType: number;
        stateClassName: string;
        performerDisplayName: string;
        startDate: string;
        endDate: string;
    }
    /** @deprecated */
    interface ITasksDataModel {
        tasks: ITaskListItem[];
        tasksLoaded: boolean;
        availableKinds: string[];
        taskID: string;
    }
    /** @deprecated */
    enum TaskGroupStateType {
        Preparation = 0,
        Performance = 1,
        Completed = 2,
        Recalled = 3,
    }
    /** @deprecated */
    enum TasksMode {
        ListAndCreation = 0,
        CreationOnly = 1,
    }
    /** @deprecated */
    enum TaskStateType {
        Draft = 0,
        InWork = 1,
        Completed = 2,
        Rejected = 3,
        OnAgreement = 4,
        Agreed = 5,
        Unknown = 6,
        NotAgreed = 7,
        OnAcceptance = 8,
        OnModification = 9,
        Deferred = 10,
        Recalled = 11,
        Delegated = 12,
        ReturnedFromDelegation = 13,
        Started = 14,
        Stopped = 15,
    }
    /** @deprecated */
    interface ILayoutTableBindingModel {
        sectionId: string;
        skippedCount: number;
        hasMore: boolean;
        loadedRows: string[];
        addedRows: string[];
        deletedRows: string[];
    }
    /** @deprecated */
    interface ILayoutTableColumnInfo {
        header: string;
        columnWidth: string;
        tip: string;
        visibility: boolean;
    }
    /** @deprecated */
    interface IOperationData {
        operationId: string;
        displayName: string;
        tooltip: string;
    }
    /** @deprecated */
    interface IStateDataModel {
        stateId: string;
        caption: string;
    }
    class ElementDataModel {
        value: string;
        key: any;
    }
    class ElementsDataModel {
        elements: ElementDataModel[];
        isEmptyKeyAllowed: boolean;
    }
    /** @deprecated */
    enum RadioGroupLabelPlacement {
        Right = 0,
        Left = 1,
    }
    /** @deprecated */
    enum FolderNodeStyle {
        FolderView = 1,
        FolderCard = 2,
        FolderURL = 4,
        FolderDigest = 8,
    }
    /** @deprecated */
    enum LinkKind {
        Card = 0,
        File = 1,
        Url = 2,
    }
    /** @deprecated */
    interface IEmployeeData extends IBasicEmployeeInfo {
        fieldPath: string;
    }
    /** @deprecated */
    interface IFindEmployeeResultItem {
        Id: string;
        FullName: string;
        FirstName: string;
        MiddleName: string;
        LastName: string;
        IsMyself: boolean;
        Position: string;
        IsFavoritePerformer: boolean;
    }
    /** @deprecated */
    interface IMultipleEmployeeData {
        employees: IEmployeeData[];
        fieldPath: string;
    }
    /** @deprecated */
    enum EmployeeTooltipMode {
        Fio = 0,
        FioAndPosition = 1,
        None = 2,
    }
    /** @deprecated */
    enum EmployeeViewMode {
        LastNameAndInitials = 0,
        DisplayName = 1,
        Auto = 2,
    }
    /** @deprecated */
    enum DepartmentDialogMode {
        Tree = 0,
        List = 1,
    }
    /** @deprecated */
    enum DateTimePickerMode {
        DateTime = 0,
        Date = 1,
    }
    /** @deprecated */
    interface ICardLinkData {
        cardId: string;
        cardDigest: string;
        cardViewAllowed: boolean;
        mainFileReadAllowed: boolean;
    }
    /** @deprecated */
    interface ICardKindDataModel {
        cardKindName: string;
        cardKindFullName: string;
        cardKindId: string;
        loadingError: string;
    }
    /** @deprecated */
    interface AgreementManagementButtonModel {
        agreementManagementOperation: ApprovalOperationKind;
        displayName: string;
    }
    /** @deprecated */
    enum AgreementOperationKind {
        Resume = 0,
        Finish = 1,
        Pause = 2,
        Cancel = 3,
    }
    /** @deprecated */
    interface IApproverInfo {
        employee: IBasicEmployeeInfo;
        excluded: boolean;
    }
    /** @deprecated */
    interface StageInfo {
        stageSemantics: StageSemantic;
        currentStage: boolean;
    }
    /** @deprecated */
    interface AgreementStageModel {
        stageId: string;
        name: string;
        order: number;
        approvalType: ApprovalType;
        duration: number;
        specificDuration: boolean;
        approvers: IApproverInfo[];
        allowEdit: boolean;
        hasBusinessProcess: boolean;
        excluded: boolean;
        approversChanged: boolean;
        stageInstanceInfo: StageInfo;
    }
    /** @deprecated */
    interface AgreementTemplateModel {
        templateId: string;
        creationSettingId: string;
        name: string;
        startNoEdit: boolean;
        startNoFiles: boolean;
        stages: AgreementStageModel[];
        loaded: boolean;
    }
    class StageChangeModel {
        constructor(stage: AgreementStageModel);
        stageId: string;
        order: number;
        approvalType: ApprovalType;
        duration: number;
        specificDuration: boolean;
        approversChanged: boolean;
        approvers: IApproverInfo[];
        excluded: boolean;
    }
    /** @deprecated */
    enum AgreementMode {
        StartAndManagement = 0,
        StartOnly = 1,
        ManagementOnly = 2,
    }
    /** @deprecated */
    enum AgreementStateType {
        Draft = 0,
        Started = 1,
        Stopped = 2,
        Agreed = 3,
        Other = 4,
    }
    /** @deprecated */
    enum ApprovalOperationKind {
        Resume = 0,
        Complete = 1,
        Pause = 2,
        Cancel = 3,
        ToApprove = 4,
        AbortStage = 5,
        Management = 6,
    }
    /** @deprecated */
    enum ApproverViewType {
        Fio = 0,
        FioAndPosition = 1,
        DisplayString = 2,
    }
    /** @deprecated */
    enum ApprovalType {
        Sequential = 0,
        Parallel = 1,
        Alternative = 3,
    }
    /** @deprecated */
    enum StageSemantic {
        Positive = 1,
        Negative = 2,
        Neutral = 3,
        Other = 4,
    }
    class ApprovalHistorySimpleCycleModel {
        isCurrent: boolean;
        number: number;
    }
    class ApprovalHistoryCycleModel extends ApprovalHistorySimpleCycleModel {
        stages: ApprovalHistoryStageModel[];
        ownerCardId: string;
    }
    class ApprovalHistorySimpleFileModel {
        name: string;
        key: {
            fileId: string;
        };
    }
    class ApprovalHistoryStageItemModel {
        decision: DecisionSemantics;
        decisionName: string;
        decisionDate: Date;
        employeeId: string;
        employeeText: string;
        comment: string;
        hasComment: boolean;
        addedFileCardModels: any[];
        commentFileData: ApprovalHistorySimpleFileModel;
    }
    /** @deprecated */
    enum DecisionSemantics {
        Positive = 1,
        Negative = 2,
        Neutral = 3,
        Cancellation = 4,
        NewCycle = 5,
        Completion = 100,
    }
    class ApprovalHistoryStageModel {
        stageId: string;
        name: string;
        approvalType: string;
        isExpandedByDefault: boolean;
        stageItems: ApprovalHistoryStageItemModel[];
    }
    class ApprovalHistoryViewModel {
        approvalReconcileCardId: string;
        approvalTaskCardId: string;
        currentCycle: ApprovalHistoryCycleModel;
        cycles: ApprovalHistorySimpleCycleModel[];
    }
    /** @deprecated */
    interface IAgreementHistoryDataModel {
        historyExists: boolean;
        agreementCardId: any;
    }
    /** @deprecated */
    enum AgreementHistoryMode {
        Button = 0,
        Layout = 1,
    }
    /** @deprecated */
    interface IMainMenuItemSetting {
        id: string;
        hidden: boolean;
    }
    /** @deprecated */
    interface IMainMenuSettings {
        items?: IMainMenuItemSetting[];
    }
    /** @deprecated */
    enum DepartmentSource {
        StaffDirectory = 0,
        PartnersDirectory = 1,
    }
    /** @deprecated */
    enum DepartmentType {
        Organisation = 0,
        Department = 1,
    }
    /** @deprecated */
    interface IDepartmentDigest extends IDepartmentInfo {
    }
    /** @deprecated */
    interface IDepartmentExtendedInfo extends IDepartmentInfo {
        email: string;
        phone: string;
    }
    /** @deprecated */
    interface IDepartmentFlatDigest {
        data: IDepartmentInfo;
        hasChildren?: boolean;
    }
    /** @deprecated */
    interface IDepartmentInfo {
        id: string;
        name: string;
        fullName: string;
        departmentType?: DepartmentType;
        hasEmployee?: boolean;
        hasChildren?: boolean;
    }
    /** @deprecated */
    interface IDepartmentsFlatSearchQuery {
        itemTypes: SearchDepartmentType;
        searchText?: string;
        departmentId?: string;
        skip: number;
        maxCount: number;
        source: DepartmentSource;
    }
    /** @deprecated */
    interface IDepartmentsItemSearchInfo {
        matched: boolean;
        matchedFieldName: string;
        matchedFieldValue: string;
    }
    /** @deprecated */
    interface IDepartmentsSearchItemFlat {
        data: IDepartmentInfo;
        searchInfo?: IDepartmentsItemSearchInfo;
        path?: IDepartmentInfo[];
        hasChildren?: boolean;
    }
    /** @deprecated */
    interface IDepartmentsSearchQuery {
        itemTypes: SearchDepartmentType;
        searchText?: string;
        skipCount: number;
        maxCount: number;
        source: DepartmentSource;
    }
    /** @deprecated */
    interface IDepartmentsSearchResult {
        items: IDepartmentDigest[];
        hasMore: boolean;
    }
    /** @deprecated */
    interface IDepartmentTreeDigest extends IDepartmentInfo {
        children?: IDepartmentTreeDigest[];
        childrenLoaded?: boolean;
    }
    /** @deprecated */
    interface IDepartmentTreeSearchDigest extends IDepartmentTreeDigest {
        matched: boolean;
        matchedFieldName: string;
        matchedFieldValue: string;
    }
    /** @deprecated */
    interface IEmloyeeInfoWithPhoneAndEmail extends IBasicEmployeeInfo {
        phone: string;
        email: string;
        unitId: string;
    }
    /** @deprecated */
    interface ILoadDepartmentsFlatQuery {
        departmentId?: string;
        source: DepartmentSource;
        skip: number;
        itemTypes: SearchDepartmentType;
        maxCount: number;
    }
    /** @deprecated */
    interface ILoadDepartmentsFlatResponse {
        directoryTimestamp: number;
        totalItemsCount: number;
        items: IDepartmentFlatDigest[];
    }
    /** @deprecated */
    interface ILoadDepartmentsTreeQuery {
        parentNodeId?: string;
        treeLevelDown: number;
        itemTypes: SearchDepartmentType;
        source: DepartmentSource;
    }
    /** @deprecated */
    interface ISearchDepartmentsFlatResult {
        items: IDepartmentsSearchItemFlat[];
        hasMore: boolean;
        directoryTimestamp: number;
    }
    /** @deprecated */
    interface ISearchDepartmentsTreeQuery {
        itemTypes: SearchDepartmentType;
        searchQuery?: string;
        source: DepartmentSource;
    }
    /** @deprecated */
    interface ISearchDepartmentsTreeResult {
        items: IDepartmentTreeDigest[];
        totalResultsCount: number;
    }
    /** @deprecated */
    interface IStaffInfoRequestModel {
        employeeIds: string[];
        departmentIds: string[];
        source: DepartmentSource;
    }
    /** @deprecated */
    interface IStaffInfoResponseModel {
        employeesInfo: IEmloyeeInfoWithPhoneAndEmail[];
        departmentsInfo: IDepartmentExtendedInfo[];
    }
    /** @deprecated */
    enum SearchDepartmentType {
        None = 0,
        Department = 1,
        Organisation = 2,
    }
    /** @deprecated */
    interface IDepartmentTreeSearchDigest extends IDepartmentTreeDigest {
        matched: boolean;
        matchedFieldName: string;
        matchedFieldValue: string;
    }
    /** @deprecated */
    interface IPartnerDirectoryItem {
        itemType: PartnerDirectoryItemType;
        data: IDepartmentInfo | IBasicEmployeeInfo;
    }
    /** @deprecated */
    interface IPartnerDirectoryItemSearchInfo {
        matched: boolean;
        matchedFieldName: string;
        matchedFieldValue: string;
    }
    /** @deprecated */
    interface IPartnerDirectoryQuickSearchResponse extends IPartnerDirectoryResponse {
        hasMore: boolean;
    }
    /** @deprecated */
    interface IPartnerDirectoryRequest {
        departmentId?: string;
        skip: number;
        maxCount: number;
    }
    /** @deprecated */
    interface IPartnerDirectoryResponse {
        items: IPartnerDirectoryItem[];
    }
    /** @deprecated */
    interface IPartnerDirectorySearchItem extends IPartnerDirectoryItem {
        searchInfo?: IPartnerDirectoryItemSearchInfo;
        path?: IDepartmentInfo[];
    }
    /** @deprecated */
    interface IPartnerDirectorySearchRequest {
        searchMode: PartnerDirectorySearchMode;
        searchText?: string;
        departmentId?: string;
        skip: number;
        skipDepartments: number;
        maxCount: number;
    }
    /** @deprecated */
    interface IPartnerDirectorySearchResponse extends IPartnerDirectoryResponse {
        items: IPartnerDirectorySearchItem[];
        hasMore: boolean;
        directoryTimestamp: number;
    }
    /** @deprecated */
    interface IPartnerDirectoryTreeLoadItem extends IPartnerDirectoryItem {
        hasChildren?: boolean;
    }
    /** @deprecated */
    interface IPartnerDirectoryTreeLoadRequest extends IPartnerDirectoryRequest {
        departmentId?: string;
    }
    /** @deprecated */
    interface IPartnerDirectoryTreeLoadResponse extends IPartnerDirectoryResponse {
        items: IPartnerDirectoryTreeLoadItem[];
        totalItemsCount: number;
        directoryTimestamp: number;
    }
    /** @deprecated */
    enum PartnerDirectoryItemType {
        Organization = 0,
        Department = 1,
        Employee = 2,
    }
    /** @deprecated */
    enum PartnerDirectorySearchMode {
        SearchDepartments = 0,
        SearchEmployees = 1,
        SearchAll = 2,
    }
    /** @deprecated */
    interface IAllowedCardKind {
        KindId: string;
        WithDescendants: boolean;
    }
    /** @deprecated */
    interface IAllowedCardType {
        CardTypeId: string;
    }
    /** @deprecated */
    interface IKindModel {
        cardTypeId: string;
        kindId: string;
        name: string;
        kinds: IKindModel[];
        notAvailable: boolean;
    }
    /** @deprecated */
    interface ILayoutLinkCreateParams {
        sourceCardId: string;
        sourceCardTimestamp: number;
        destinationCardId: string;
        linkTypeId: string;
        linksBinding: ISimpleBindingInfo;
        saveHardLink: boolean;
        editOperation: string;
    }
    /** @deprecated */
    interface ILayoutSetLinkDescriptionParams {
        cardId: string;
        bindingInfo: ISimpleBindingInfo;
        linkId: string;
        newDescription: string;
        timestamp: number;
    }
    /** @deprecated */
    interface ILinkItemData {
        linkId: string;
        displayName: string;
        linkTypeName: string;
        kind: LinkKind;
        cardId: string;
        creationDate?: Date;
        authorDisplayName: string;
        description: string;
    }
    /** @deprecated */
    interface ILinksDataModel {
        links: ILinkItemData[];
        bindingInfo: ISimpleBindingInfo;
        allowedLinkCardTypes: string[];
        linksLoaded: boolean;
    }
    /** @deprecated */
    interface ILinkType {
        LinkTypeId: string;
        Caption: string;
        DisplayName: string;
    }
    /** @deprecated */
    interface HistoryRecord {
        id: string;
        author: IBasicEmployeeInfo;
        date: Date;
        event: string;
    }
    class HistoryRequest {
        cardId: string;
        employeeName?: string;
        date?: Date;
        eventSearch?: string;
        skip: number;
        maxCount: number;
        operationsToHide: string[];
        cacheId: string;
        editOperation: string;
    }
    class HistoryResponse {
        records: HistoryRecord[];
        hasMore: boolean;
        cacheId: string;
        renew: boolean;
    }
    /** @deprecated */
    enum FolderMode {
        NoDefaultValue = 0,
        DefaultValueIsCurrentFolder = 1,
    }
    /** @deprecated */
    enum FolderType {
        Regular = 1,
        Virtual = 4,
        Delegate = 8,
        System = 16,
    }
    /** @deprecated */
    interface ICheckResult {
        passed: boolean;
        failReason: string;
    }
    /** @deprecated */
    interface IFolderInfo {
        name: string;
        folderId: string;
        additionalId: string;
        folderType: FolderType;
        disabled: boolean;
        refreshTimeout: number;
        hasUnloadedSubfolders: boolean;
        children: IFolderInfo[];
    }
    /** @deprecated */
    interface IFolderItemNodeData {
        id: string;
        name: string;
        type: FolderType;
        defaultStyle: FolderNodeStyle;
        hasUnloadedSubfolders: boolean;
        url: string;
        defaultViewId: string;
        searchId: string;
        targetFolderId: string;
        searchHasParameters: boolean;
        refreshTimeout: number;
        showUnreadCounter: boolean;
        folders: IFolderItemNodeData[];
    }
    /** @deprecated */
    interface IFolderItemNodeDataWithParents {
        folderNode: IFolderItemNodeData;
        parentNodes: string[];
    }
    /** @deprecated */
    interface IFileListDataModel {
        timestamp: number;
        files: ILayoutFileModel[];
        hasAnySignature: boolean;
        totalCount: number;
    }
    /** @deprecated */
    interface FileListVersionsDataModel {
        versions: IFileVersion[];
    }
    /** @deprecated */
    interface IFileVersion {
        id: string;
        versionId: string;
        versionPath: string;
        versionNumber: number;
        author: string;
        creationDate: Date;
        comments: IVersionComment[];
    }
    /** @deprecated */
    interface IGetFilesOptions {
        skipCount: number;
        maxCount: number;
    }
    /** @deprecated */
    interface ILayoutFileModel {
        name: string;
        fileId: string;
        fileCardId: string;
        isLocked: boolean;
        isFilePreviewSupported: boolean;
        currentVersion: IFileVersion;
        childVersions: IFileVersion[];
        hasFileSignature: boolean;
        versionsCount: number;
        isMain: boolean;
        webDavLink: string;
        webDavReadonlyLink: string;
    }
    /** @deprecated */
    interface IVersionComment {
        id: string;
        date: Date;
        comment: string;
        author: string;
    }
    /** @deprecated */
    enum DirectoryDesignerAreas {
        OnlyNode = 0,
        OnlyChildren = 1,
        NodeWithChildren = 2,
    }
    /** @deprecated */
    enum DirectoryDesignerNodeType {
        Node = 0,
        Row = 1,
    }
    /** @deprecated */
    interface IDirectoryDesignerLoadTreeQuery {
        rootNodeId?: string;
        searchArea?: DirectoryDesignerAreas;
        currentNodeId?: string;
        treeLevelDown: number;
    }
    /** @deprecated */
    interface IDirectoryDesignerRowDigest extends IDirectoryDesignerRowInfo {
    }
    /** @deprecated */
    interface IDirectoryDesignerRowInfo {
        id: string;
        name: string;
    }
    /** @deprecated */
    interface IDirectoryDesignerSearchQuery {
        rootNodeId?: string;
        searchArea?: DirectoryDesignerAreas;
        searchText: string;
        skipCount: number;
        maxCount: number;
    }
    /** @deprecated */
    interface IDirectoryDesignerSearchResult {
        items: IDirectoryDesignerRowDigest[];
        hasMore: boolean;
    }
    /** @deprecated */
    interface IDirectoryDesignerSearchTreeQuery {
        rootNodeId?: string;
        searchArea?: DirectoryDesignerAreas;
        searchQuery?: string;
        searchResultNumber?: number;
    }
    /** @deprecated */
    interface IDirectoryDesignerSearchTreeResult {
        items: IDirectoryDesignerTreeNodeDigest[];
        totalResultsCount: number;
        searchResultNumber: number;
        matchedElementId: string;
        matchedFieldName: string;
        matchedFieldValue: string;
    }
    /** @deprecated */
    interface IDirectoryDesignerTreeNodeDigest {
        name: string;
        nodeType: DirectoryDesignerNodeType;
        id: string;
        children?: IDirectoryDesignerTreeNodeDigest[];
        childrenLoaded?: boolean;
    }
    /** @deprecated */
    interface IChangeStateData {
        cardId: string;
        operationId: string;
        layoutType: number;
        comment?: string;
    }
    /** @deprecated */
    interface ILayoutPartParams {
        cardId: string;
        layoutType: number;
        rootControlName: string;
        includeRootControl: boolean;
    }
    /** @deprecated */
    interface ISaveControlData {
        cardId: string;
        layoutType: number;
        bindings: IBindingsWriteRequest[];
        createAsLink: ICreateAsLinkParams;
        createInFolder: string;
        timestamp: number;
        deferred: JQueryDeferred<any>;
        cardTypeId: string;
        parentCardId: string;
    }
    /** @deprecated */
    interface IBindingInfoExt extends ISimpleBindingInfo {
    }
    /** @deprecated */
    interface ICardInfoModel {
        id: string;
        typeId: string;
        lockInfo: ILockInfoModel;
        timestamp: number;
        parentCardId: string;
        createAsLink: ICreateAsLinkParams;
        createInFolder: string;
        createInCurrentFolderForbidden: boolean;
        createDate: Date;
    }
    /** @deprecated */
    interface ICreateAsLinkParams {
        sourceCardId: string;
        sourceCardTimestamp: number;
        linkTypeId: string;
        linksBinding: ISimpleBindingInfo;
        saveHardLink: boolean;
    }
    /** @deprecated */
    interface IExtendedLayoutModel extends ILayoutModel {
        layoutInfo: ILayoutInfoModel;
    }
    /** @deprecated */
    interface ILayoutCardModel extends ILayoutViewModel {
        cardInfo: ICardInfoModel;
    }
    /** @deprecated */
    interface ILayoutInfoModel {
        deviceType: GenModels.DeviceType;
        localeId: number;
        name: string;
        id: string;
        type: LayoutType;
        operations: IEditOperation[];
    }
    /** @deprecated */
    interface ILayoutModel {
        properties: any;
        children: ILayoutModel[];
        controlTypeName: string;
    }
    /** @deprecated */
    interface ILayoutViewModel {
        layoutModel: IExtendedLayoutModel;
    }
    /** @deprecated */
    interface ILockInfoModel {
        isLocked: boolean;
        accountName: string;
    }
    /** @deprecated */
    interface ISimpleBindingInfo {
        fieldAlias: string;
        sectionId: string;
        editOperation: string;
        propertyName: string;
    }
    /** @deprecated */
    enum LayoutType {
        View = 0,
        Edit = 1,
        Create = 2,
    }
    /** @deprecated */
    interface IAgreementListDataModel {
        items: IAgreementListItemModel[];
        documentNumber: string;
        documentName: string;
    }
    /** @deprecated */
    interface IAgreementListItemModel {
        date: Date;
        employeeDisplayText: string;
        departmentName: string;
        comment: string;
        decisionText: string;
    }
    /** @deprecated */
    interface IAgreementManagementEditModel {
        agreementManagement: IAgreementManagementModel;
        stages: AgreementStageModel[];
        canInterruptCurrentStages: boolean;
        availableAgreementOperations: AgreementOperationKind[];
    }
    /** @deprecated */
    interface IAgreementManagementModel {
        isMainFileExists: boolean;
        isNew: boolean;
        stateType: AgreementStateType;
        reconciliationCardId: string;
    }
    /** @deprecated */
    interface IAgreementManagementStartModel {
        agreementManagement: IAgreementManagementModel;
        templates: AgreementTemplateModel[];
    }
    /** @deprecated */
    interface ILayoutAgreementManagementModel {
        isNew: boolean;
        enableCreate: boolean;
        createDisableReason: string;
        agreementCardId: string;
        stateType: AgreementStateType;
        documentTimestamp: number;
    }
    /** @deprecated */
    class ApplicationInfo {
        constructor();
    }
}
declare namespace WebClient {
    type $StandardControllers = $BusinessCalendarController & $DocumentCardController & $FileController & $LayoutAgreementController & $LayoutCardController & $LayoutCardKindController & $LayoutController & $LayoutDirectoryDesignerController & $LayoutDocumentController & $LayoutFileController & $LayoutFolderController & $LayoutHistoryController & $LayoutLinksController & $LayoutPartnerController & $LayoutStaffController & $LayoutTasksController & $LayoutUserSettingsController & $PagesController & $EmployeesController & $CommentsController & $EmployeesController & $LayoutFileApiController;
}
declare namespace WebClient {
    /**
     * Базовый класс для описания публичных свойств контрола.
     *
     * Публичные свойства должны объявляться использованием одного из трех декораторов:
     * {@link r} (свойство, котрое запрещено изменять после создания контрола),
     * {@link rw} (разрешено изменять) или
     * {@link event} (событие).
     * Например:
     *
     *     @r isLoaded?: boolean;
     *     @rw visibility?: boolean = true;
     *     @event click?: BasicApiEvent<IClickEventArgs>;
     *
     * Свойства, которые не существенны для контрола (либо имеют значения по умолчанию) должны быть помечены как необязательные
     * (с помощью знака вопроса, например `@rw compactMode?: boolean = false;`). Это позволит не указывать данные свойства при создании контрола
     * через JSX из скриптов.
     *
     * Получение и запись значения публичных свойств можно переопределить в методах {@link BaseControl.setParamValue},
     * {@link BaseControl.getParamValue}, либо при помощи объявления свойств с декоратором {@link handler}.
     */
    class BaseControlParams {
        /** Возвращает ссылку на родительский элемент управления. @see {@link BaseControl.parent} */
        parent: BaseControl<BaseControlParams, BaseControlState>;
        /** Возвращает имя класса элемента управления. */
        controlTypeName?: string;
        /** Возвращает наименование класса TypeScript, реализующего компонент */
        controlComponentName?: string;
        /** Возвращает уникальное (для текущей разметки) имя элемента управления. */
        name?: string;
        /**
         * Возвращает набор стандартных классов, определяющих стиль элемента управления.
         * Стандартные классы, указываемые по умолчанию для всех элементов управления, не могут быть изменены.
         */
        standardCssClass?: string;
        /** Пользовательские классы стилей элемента управления, дополняющие стили из {@link BaseControlParams.standardCssClass}. */
        customCssClasses?: string;
        /** Определяет, отображается ли элемент управления на странице: `true` - отображается, `false` - скрыт. */
        visibility?: boolean;
        /**
         * Определяет, должен ли элемент управления получать фокус при переходе по Tab:
         * `true` - должен, `false` - не должен.
         * @see {@link BaseControlImpl.getTabIndex}
         */
        tabStop?: boolean;
        /**
         * Определяет, должен ли элемент управления отображаться в компактном режиме, в котором у элемента отсутствуют отступы и т.п.
         * Компактный режим, например, используется при отрисовке контролов в таблице (см. {@link Table}).
         */
        compactMode?: boolean;
        /** Стиль родительского (по отношению к данному элементу управления) div-элемента. */
        customCssStyle?: React.CSSProperties;
        /**
         * Определяет, завершена ли инициализация элемента управления:
         * `true` - объект {@link BaseControl.controlImpl} создан,
         * `false` - инициализация завершена.
         */
        isLoaded?: boolean;
        /** Событие, возникающее при щелчке мышью в области элемента управления. */
        click?: BasicApiEvent<any>;
        /** Событие, возникающее при попадании мыши в область элемента управления. */
        mouseOver?: BasicApiEvent<IMouseOverEventArgs>;
        /** Событие, возникающее при выведении мыши из области элемента управления. */
        mouseOut?: BasicApiEvent<IMouseOutEventArgs>;
        /** Событие, возникающее при получении элементом управления фокуса. */
        focus?: BasicApiEvent<IFocusEventArgs>;
        /** Событие, возникающее при потере элементом управления фокуса. */
        blur?: BasicApiEvent<IBlurEventArgs>;
        /** Событие, возникающее, когда свойство {@link isLoaded} устанавливается в `true`. */
        loaded?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее при удалении элемента управления из разметки. */
        unloading?: CancelableApiEvent<IEventArgs>;
        /** Интерфейсный компонент контрола (см. описание класса {@link BaseControl}). */
        wrapper?: BaseControl<BaseControlParams, BaseControlState>;
    }
    /** Базовый интерфейс для описания состояния интерфейсного компонента элемента управления. */
    interface BaseControlState extends BaseControlParams {
        /** Разметка. */
        layout: Layout;
        /** Инициализирован ли компонент. */
        initialized: boolean;
    }
    /** Синоним `BaseControl<any, any>` */
    type LayoutControl = BaseControl<BaseControlParams, any>;
    /**
     * Базовый класс элементов управления модуля Web-клиент.
     *
     * Элементы управления Модуля состоят из двух классов: интерфейсного и реализации. Интерфейсная часть наследуется от данного класса,
     * а реализация от {@link BaseControlImpl}. Интерфейсный компонент обеспечивает взаимодействие контрола с внешним миром (работа с binding,
     * обращения к серверу, к разметке, в которой находится контрол и т.д.), в то время как компонент реализации содержит логику контрола,
     * абстрагированную от внешнего окружения.
     *
     * Публичные свойства контрола объявляются в специальном классе, наследующемся от {@link BaseControlParams}. Данные свойства
     * доступны через объект {@link BaseControl.params}. Публичные методы контрола объявляются в классе с использованием декоратора {@link api}.
     *
     * @param P Класс, наследующийся от {@link BaseControlParams} и описывающий публичные свойства компонента.
     * @param S Интерфейс, расширяющий {@link BaseControlState} и описывающий внутренние переменные инетрфейсного компонента.
     */
    abstract class BaseControl<P extends BaseControlParams, S extends BaseControlState> extends React.Component<P, S> implements ISupportEventBubling {
        /**
         * Если значение данного поля `false`, то вызов метода {@link forceUpdate} не инициирует перерисовку компонента.
         * Используется методом {@link batchUpdate}.
         */
        protected shouldUpdate: boolean;
        private paramsObject;
        private propertyGetHandlers;
        private propertySetHandlers;
        private controlImplRef;
        private bublingEventSubscribers;
        protected newStyleControlImpl: boolean;
        /**
         * Инициализирует контрол
         * @param props Свойства, переданные контролу
         */
        constructor(props: P);
        /**
         * При переопределении в дочернем классе должен возвращать новый
         * экземпляр параметров компонента, созданный через оператор new (например: `new MyControlParams()`)
         * Данный объект будет присвоен свойству this.state.
         */
        protected abstract createParams(): P;
        /**
         * При переопределении в дочернем классе должен возвращать новый
         * экземпляр реализации компонента, созданный через оператор new (например: `new MyControlImpl()`)
         * Данный объект будет присвоен свойству this.controlImpl.
         */
        protected createImpl(): BaseControlImpl<BaseControlParams, BaseControlImplState>;
        /**
         * Аналог свойства {@link BaseControl.params}.
         */
        protected getParams(): P;
        /**
         * Инициализация
         */
        init(): void;
        /**
         * Деинициализация
         */
        deinit(): void;
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected unregisterChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected registerControl(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected unregisterControl(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** Компонент реализации (см. описание класса {@link BaseControl})
          * @see {@link getParamValue}, {@link setParamValue}, {@link attachControl},
          */
        protected controlImpl: BaseControlImpl<BaseControlParams, BaseControlImplState>;
        protected getImpl<T>(): T;
        /**
         * Получает значения через метод {@link getBindingsWriteRequests} и сохраняет их на сервере.
         */
        save(): JQueryDeferred<any>;
        /**
          * Публичные свойства элемента управления.
          * Обращения к параметрам через данный объект обрабатываются функциями {@link getParamValue} и {@link setParamValue}.
          * Свойства данного объекта объявляются в методе {@link setupParamsAccessors}.
          * Сам объект создается в методе {@link createParams}
          */
        readonly params: P;
        /**
         * Устанавливает значение {@ controlImpl}, в соответствии с идиомой Pimpl.
         * Метод должен передаваться в качестве значения ref в функции render. Например:
         *
         *     <MyControlImpl ref={this.attachControl} />;
         *
         * @param control Reference to contorl implementation
         */
        protected attachControl(control: any): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentWillMount(): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentDidMount(): void;
        /** Разметка, в которой находится компонент. */
        readonly layout: Layout;
        /**
         * Родительский компонент. Отношение родитель-потомок определяет, прежде всего, логику {@link getBindingsWriteRequests}.
         *
         * Внимание! Отношение родитель-потомок может отличаться от логической вложенности компонентов (например, дочерние компоненты, вложенные один в другой
         * могут иметь общего родителя).
         */
        readonly parent: BaseControl<BaseControlParams, BaseControlState>;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentWillUnmount(): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentWillReceiveProps(nextProps: P, nextContext: any): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentWillUpdate(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentDidUpdate(prevProps: Readonly<P>, prevState: Readonly<S>, prevContext: any): void;
        shouldComponentUpdate(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean;
        /**
         * Вызывает перерисовку компонента.
         * Присваивание параметрам новых значений автоматически вызывает перерисовку, и в таких случаях вызывать метод не следует.
         * Данный метод нужно вызывать только в том случае, когда либо меняются поля объекта параметра, либо устанавливается значение state.
         * @param callBack Функция, которая будет вызвана после того, как перерисовка компонента завершится.
         * @see [Документация React](https://facebook.github.io/react/docs/react-component.html#other-apis)
         */
        forceUpdate(callBack?: () => any): void;
        /**
         * Позволяет установить значение нескольких параметров, вызвав только одну перерисовку компонента.
         * В методе нет необходимости, если значения параметров меняются в рамках обработки одного React-события (в этом случае
         * React автоматически предотвращает многократную перерисовку компонента).
         * @param updateLogic Функция, который выполняет изменение параметров
         * @param callback Функция, которая вызывается после обновления компонента (передается параметром в forceUpdate)
         */
        batchUpdate(updateLogic: Function, callback?: () => any): void;
        /** @internal */
        protected getApiProperties(): IApiPropertyDescriptor[];
        /** @internal */
        private readonly isLoaded;
        /**
         * Вызывается перед сохранением карточки.
         * @returns Сохранение будет продолжено только после того, как данный объект перейдет в состояние "resolved".
         */
        onSaving(): JQueryDeferred<any>;
        /**
         * Вызывается после сохранения карточки.
         * @returns Логика после сохранения карточки продолжит выполняться только после того, как данный объект перейдет в состояние "resolved".
         */
        onSaved(): JQueryDeferred<any>;
        /**
         * Подготавливает собственные значения и значения всех дочерних контролов для отправки на сервер.
         * Метод вызывает {@link getBindings} для получения значений.
         * @param withChildren Включать в результат значения дочерних контролов или нет.
         */
        getBindingsWriteRequests(withChildren?: boolean): IBindingsWriteRequest[];
        /**
         * При переопределнии в дочерних классах, должен возвращать все значения,
         * которые контрол должен отправлять на сервер при сохранении.
         */
        protected getBindings(): IBindingResult<any>[];
        /**
         * Проверяет корректность значения элемента управления.
         *
         * К примеру, если у элемента управления с флагом "обязательный" отсутствует значение,
         * валидация не будет пройдена (см. {@link InputBasedControl}). При этом можно показать предупреждающее сообщение.
         * @param params Параметры выполнения валидации. Например, показывать ли сообщение о неудаче в UI или нет.
         */
        validate(params: any): IValidationResult[];
        /**
         * Производится обнаружение и регистрация всех свойств, объявленных с декоратором {@link handler}.
         */
        protected registerParamHandlers(): void;
        private registerParamHandlersInternal(obj);
        /**
         * Возвращает значение параметра при обращении через {@link params} объект.
         * По умолчанию реализуется следующая логика:
         * 1. Если объявлено get-свойство с декоратором {@link handler}, то возвращается значение данного свойства
         * 2. Если свойство controlImpl содержит объект, то возвращается реультат вызова {@link BaseControlImpl.getParamValue}.
         * 3. Если свойство controlImpl равно undefined, то выдается предупреждение, о том что controlImpl еще не инициализирован.
         *    Данная ситуация может возникнуть, если обращение к свойству происходит до вызова componentDidMount.
         * @param paramName Имя параметра, значение которого необходимо получить
         * @returns Значение параметра
         */
        getParamValue(paramName: string): any;
        /**
         * Обрабатывает новые значения свойств. Вызывается в `componentWillMount` и `componentWillReceiveProps`.
         * @param newProps Новые значения props компонента при вызове из componentWillReceiveProps или this.props при вызове из componentWillMount.
         * @param initial Значение истино, если метод вызывается при инициализации компонента (из componentWillMount).
         */
        protected setParamValues(newProps: BaseControlParams, initial: boolean): void;
        /**
         * Обработчик, вызываемый всякий раз, когда установливается значение параметра.
         * Происходить это может в следующих случаях:
         * 1. При инициализации компонента (см. {@link setParamValues})
         * 2. При получении новых props компонента (ситуация возможна при создании компонента из скриптов через JSX-синтаксис, см. {@link setParamValues}).
         * 3. При установке значения через объект {@link params} (например `params.visiblity = false`).
         *
         * Метод Реализует следующую логику:
         * 1. Если параметр является событием (объявлен с декоратором {@link event}), то вызывается {@link setEventValue}.
         * 2. Если запись не разрешена (параметр только для чтения (объявлен с декоратором {@link r}) и initial = false), то сообщается об ошибке.
         * 3. Если запись разрешена, то
         * а) Ищется set-свойство в текущем классе с декоратором {@link handler} для данного параметра, и если оно присутствует, то вызывается оно.
         * б) Если свойство не найдено, значение параметра помещается в `state`. В методе `render` значения из `state` обычно передаются в {@link controlImpl}.
         * @param paramName Имя параметра, значение которого нужно установить.
         * @param value Значение параметра
         * @param initial Значение истино, если метод вызывается при инициализации компонента (из componentWillMount).
         */
        setParamValue(paramName: string, value: any, initial: boolean): void;
        /**
         * Вызывается методом {@link setParamValue}, в случае если параметр является событием (объявлен с декоратором {@link event}).
         * @param paramName Имя события
         * @param newVal Одна или несколько функций-обработчик события
         * Если передаётся строка, то несколько функций можно указать через один из разделителей:
         * ",", ";", "|" или "&" с произвольным количеством пробелов между ними.
         * @param initial Значение истино, если метод вызывается при инициализации компонента (из componentWillMount).
         */
        protected setEventValue(paramName: string, handlersData: BasicEventHandler<any> | BasicEventHandler<any>[] | string, initial: boolean): void;
        /**
         * Инициализирует объект {@link params}.
         * В объекте объявляются get и set акссессоры для всех параметров, которые вызывают
         * методы {@link getParamValue} и {@link setParamValue}.
         * Для успешной настройки параметров они должны быть объявлены с декоратором {@link r}, {@link rw} или {@link event}.
         */
        protected setupParamsAccessors(): void;
        readonly supportEventBubling: boolean;
        getEventInfo<T>(event: any): IBublingEventInfo;
        triggerBublingEvent<T>(eventName: string, actualSender: ISupportEventBubling, args: T): void;
        subscribteToBublingEvent(eventNameSpec: string | FieldSpec<any, any>, callback: BublingEventCallback): void;
        unsubscribteToBublingEvent(eventNameSpec: string | FieldSpec<any, any>, callback: BublingEventCallback): void;
        render(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства [EmptyControlStub]{@link EmptyControlStub}.
     */
    class EmptyControlStubParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Пояснение, почему не удалось загрузить основной контрол. */
        emptyControlStubComment?: string;
    }
    /**
     * Контрол-заглушка, обозначающий что никакого содержимого для отображения нет.
     */
    class EmptyControlStub extends BaseControl<EmptyControlStubParams, any> {
        /** @internal */
        protected createParams(): EmptyControlStubParams;
        /** @internal */
        protected createImpl(): ControlImpl;
        /** @internal */
        componentDidMount(): void;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства [LayoutScript]{@link LayoutScript}.
     */
    class LayoutScriptParams extends BaseControlParams {
        services?: $ControlStore;
    }
    /** @internal */
    interface LayoutScriptState extends LayoutScriptParams, BaseControlState {
    }
    /**
     * Класс, позволяющий хранить различную логику для элементов управления.
     */
    abstract class LayoutScript<ParamsT extends LayoutScriptParams, StateT extends BaseControlState = LayoutScriptState> extends BaseControl<ParamsT, StateT> {
        constructor(props: ParamsT);
        /** @internal */
        protected createImpl(): ControlImpl;
        /** @internal */
        render(): any;
    }
}
declare namespace WebClient {
    /** Форматы конвертации даты в строку. */
    enum DateFormats {
        /** Только дата для отображения пользователю. */
        Date = 0,
        /** Только время для отображения пользователю. */
        Time = 1,
        /** Дата и время для отображения пользователю. */
        DateTime = 2,
        /** Дата и время для отправки на сервер. */
        ServerDateTime = 3,
    }
}
declare namespace WebClient {
    /**
    * Возможные режимы редактирования значения элемента управления.
    */
    enum EditMode {
        /** По месту. В данном режиме изменение значение осуществляется в отдельном диалоговом окне. */
        EditInPlace = 0,
        /** Без редактирование. В данном режиме изменение значения недоступно. */
        View = 1,
        /** Редактирование. Стандартный режим редактирования значения, осуществляемого непосредственно в элементе управления. */
        Edit = 2,
    }
}
declare namespace WebClient {
    /** Коды клавиш */
    class KeyCodes {
        static readonly ARROW_UP: number;
        static readonly ARROW_DOWN: number;
        static readonly ARROW_RIGHT: number;
        static readonly ARROW_LEFT: number;
        static readonly ESC: number;
        static readonly ENTER: number;
        static readonly SPACE: number;
        static readonly BACKSPACE: number;
    }
}
declare namespace WebClient {
    /** Конструктор класса контрола. Например: `let type: LayoutControlType = WebClient.TextBox;*/
    interface LayoutControlType {
        new (props: any): LayoutControl;
        controlComponentName: string;
    }
    /** Хранит ссылки на классы контролов с доступом по имени типа. */
    class LayoutControlFactory {
        private readonly matchPattern;
        /** Словарь контролов. */
        protected controlMap: IControlMap;
        /** Регистрирует контрол в словаре.
         * @param name Имя типа контрола (controlTypeName).
         * @param createFunction Функция, возвращающая ссылку на конструктор класса контрола.
         * @param replaceExisting Следует ли разрешить перерегистрацию контролов (по умолчанию false).
        */
        register(name: string, createFunction: () => any, replaceExisting?: boolean): void;
        /** Возвращает зарегистрированный ранее контрол по имени типа. */
        get(name: string): LayoutControlType;
    }
    /** @internal */
    type $LayoutControlFactory = {
        controlFactory: LayoutControlFactory;
    };
    var controlFactory: LayoutControlFactory;
}
declare var controlFactory: WebClient.LayoutControlFactory;
declare namespace WebClient {
    /** Статус длительной операции. */
    enum LoadingStatus {
        /** Операция не была начата. */
        None = 1,
        /** Операция находится в процессе выполнения. */
        Loading = 2,
        /** Операция завершилась успешно. */
        Done = 3,
        /** Операция завершилась с ошибкой. */
        Error = 4,
    }
    /** Состояние длительной операции. */
    class LoadingState {
        /** Экземпляр {@link LoadingState} со статусом {@link LoadingStatus.Loading}. */
        static Loading: LoadingState;
        /** Экземпляр {@link LoadingState} со статусом {@link LoadingStatus.None}. */
        static None: LoadingState;
        constructor(status?: LoadingStatus, message?: string);
        /** Операция выполняется. */
        readonly loading: boolean;
        /** Операция завершилась с ошибкой. */
        readonly error: boolean;
        /** Операция завершилась успешно. */
        readonly done: boolean;
        /** Операция не была начата. */
        readonly none: boolean;
        /** Обновить значение статуса. */
        update(status: LoadingStatus, message?: string): void;
        /** Статус выполнения операции. */
        status: LoadingStatus;
        /** Сообщение об ошибке или предупреждение. */
        message: string;
    }
}
declare namespace WebClient {
    /**
     * Вспомогательный класс для создания всплывающих уведомлений
     */
    class PopupNotification {
        static getDefaultOptions: () => Noty.Options;
        /**
         * Создаёт уведомление
         * @param options Список опций
         * @param show Показывать ли уведомление сразу же
         */
        static create(options: Noty.Options, show?: boolean): Noty;
    }
}
declare namespace WebClient {
    /** Если условие истинно, возвращает переданную строку обрамленную пробелами. Иначе пустую строку. */
    function classIf(condition: boolean, css: string): string;
    /** Если условие ложно, возвращает переданную строку обрамленную пробелами. Иначе пустую строку. */
    function classIfNot(condition: boolean, css: string): string;
    /** Если переданное значение определено, то возвращает его. Иначе возвращает пустую строку. */
    function classIfDefined(css: string): string;
    /** Если условие ложно, то возвращает строку "hide" обрамленную пробелами. hide - это системный класс, скрывающий элемент на странице. */
    function showIf(condition: boolean): string;
    /** Если условие истинно, то возвращает строку "hide" обрамленную пробелами. hide - это системный класс, скрывающий элемент на странице. */
    function hideIf(condition: boolean): string;
    /** Если условие истинно, то возвращает переданную строку trueCss обрамленную пробелами, иначе falseCss обрамленную пробелами. */
    function classIfElse(condition: boolean, trueCss: string, falseCss: string): string;
    /** Клонирует объект при помощи JSON.stringify и JSON.parse. */
    function cloneObject(obj: any): any;
    /** @deprecated Используйте formatDateTime */
    function dateTimeToString(dateTime: Date | string, format?: DateFormats): string;
    /** @deprecated Используйте formatDateTime */
    function toStringDate(date: Date): string;
    /** Конвертирует дату в строку. */
    function formatDateTime(dateTime: Date | string, format?: DateFormats): string;
    /** Конвертирует строку в дату. */
    function parseDateTime(dateTime: string, format?: DateFormats, asMoment?: boolean): Date | moment.Moment | null;
    /** @deprecated Use Promise.all */
    function whenAll(deferreds: JQueryDeferred<any>[]): JQueryDeferred<any>;
    /** @internal */
    function getFunctionByName(name: string, returnOnlyOne?: boolean, customErrorMessage?: (funcName: string, funcData: any) => string): any | any[];
    /** @internal */
    function getFunctionByNameEx(name: string): any;
    /** Если значение variable не определено, то возвращает newValue. Иначе возвращает variable. */
    function newValueIfUndefined(variable: any, newValue: any): any;
    /** Вызывает jquery функции slideUp и slideDown. */
    function slideAnimation(elem: HTMLElement, isSlideUp: boolean, duration?: number, easing?: string, completeCallback?: Function): void;
    /** Вызывает jquery функции slideUp и slideDown. */
    function slideAnimations(items: NodeListOf<Element>, isSlideUp: boolean, duration?: number, easing?: string, completeCallback?: Function, endCallback?: Function): void;
    /**
     * @deprecated Вспомогательная функция для совмещения React с WebClient.ModalWindow
     *
     * Внимание! В связи с изменениями в React 16, начиная с Web-клиента 10 функция не возвращает значение. Используйте ref для получения экземпляра.
     */
    function renderModalContent(modal: ModalWindow, content: React.ReactNode, showCloseButton?: boolean): void;
    /** @internal */
    const DISPLAY_NAME_PROPERTY_NAME_KEY = "DisplayNamePropertyName";
    /** Конструирует объект {@link IBindingResult} для отправки на сервер.
     * @param binding Значение привязки полученное при загрузке контрола.
     * @param value Новое значение контрола.
     * @param fieldSpec Имя параметра, в котором хранится отображаемое имя поля, значение которого редактируется контролом.
     */
    function getBindingResult(binding: IBindingResult<any>, value: any, fieldSpec: FieldSpec<any, any>): IBindingResult<any>;
    /** Константа равная 00000000-0000-0000-0000-000000000000. Для проверки что GUID является пустым используйте {@link isEmptyGuid}. */
    const EMPTY_GUID = "00000000-0000-0000-0000-000000000000";
    /** Возвращает true если переданное значение не определено или равно {@link EMPTY_GUID}. */
    function isEmptyGuid(guid: string): boolean;
    /**
     * Возвращает функцию, которая может быть передана в качестве значения "ref" параметра react-элемента.
     * В результате элементу будет добавлена всплывающая подсказка при помощи плагина tipso.
     */
    function attachTooltip(text: string, extraOptions?: Object): (elem: HTMLElement) => any;
    /**
     * Возвращает функцию, которая может быть передана в качестве значения "ref" параметра react-элемента.
     * Текст всплывающей подсказки будет определен на основе содержимого элемента.
     */
    function attachTooltipFromContent(extraOptions?: Object): (elem: HTMLElement) => void;
    /**
     * Добавляет всплывающую подсказку к элементу.
     */
    function setTooltip(elem: HTMLElement, text: string, extraOptions?: any): void;
    /** Генерирует новый уникальный идентификатор формата GUID. */
    function generateGuid(): string;
    /** Создает новый объект JQueryDeferred в стиле конструктора Promise. */
    function MakeDeferred<T>(job: (resolve: (data: T) => JQueryDeferred<T> | void, reject: (err: any) => JQueryDeferred<T> | void) => void): JQueryDeferred<T>;
    /** Создает новый объект JQueryDeferred и завершает его с переданным значением. */
    function ResolvedDeferred<T>(data: T): JQueryDeferred<T>;
    /**
      * Лямбда функция вида () => obj.someProperty или (obj) => obj.someProperty.
      *
      * Функция getFieldName способна конвертировать данное выражение в имя свойства (напр. "someProperty").
      */
    type FieldSpec<TModel, TResult> = ((model?: TModel) => TResult) | string;
    /**
     * Преобразует функцию вида () => obj.someProperty или (obj) => obj.someProperty в имя свойства (напр. "someProperty").
     *
     * Данная функция используется для того, чтобы получить имя свойства, создав при этом TypeScript-ссылку на это свойство.
     * TypeScript-ссылка позволяет использовать инструменты VisualStudio для рефакторинга и исследования кода (например, переименование).
     * @param fieldSpec функция вида () => obj.someProperty или (obj) => obj.someProperty или строка (возвращается без изменений)
     */
    function getFieldName<TModel, TResult>(fieldSpec: FieldSpec<TModel, TResult>): string;
    /** Преобразует строку в значение boolean. */
    function parseBoolean(value: string | null | undefined | boolean, defaultValue?: boolean): boolean;
    /** Преобразует строку в значение number. */
    function parseNumber(value: string | null | undefined | number, defaultValue?: number): number;
    /** Возвращает true если переданное значение определено (не равно undefined и null). */
    function definedNotNull(val: any): boolean;
    /** Осветление цвета. */
    function colorLuminance(hex: string, lum: number): string;
    /** Вычисляет цвет, который получится при наложении прозрачного слоя одного цвета на подложку другого цвета.
     * @param opacity Степень прозрачности накладываемого слоя (0-1).
     * @param backgroundColor Цвет подложки в формате HEX.
     * @param foregroundColor Цвет накладываемого слоя в формате HEX.
     */
    function caculateTransparentColor(foregroundColor: any, backgroundColor: any, opacity: any): string;
    /** Делает первую букву в строке заглавной. */
    function capitalizeFirstLetter(str: any): any;
    /** Преобразует имена свойств в объекте так, чтобы они начинались с прописной буквы. */
    function toCamelCase(key: any, value: any): any;
    /** Внутренний размер окна. */
    function getInnerSize(): number[];
    /** Возвращает адрес открытия карточки на просмотр. */
    function getViewCardUrl(id: string): string;
    /** Разбивает строку на подстроки указанной длинны. */
    function chunkString(str: string, length: number): string[];
    /** Разбивает строку на подстроки, разделяя ее по указанному вхождению. */
    function splitFirstSymbol(str: string, symbol: string): string[];
    /** Возвращает строку "Desktop", "Smartphone" или "Tablet" в зависимости от переданного значения.  */
    function getDeviceName(enumValue: GenModels.DeviceType): string;
    /** Открывает html-разметку в новом окне, копируя туда все текущие стили, после чего инициирует печать открытой страницы. */
    function printContent(content: string, siteUrl?: string): void;
    /** Возвращает порядковый номер дня в году для указанной даты. */
    function getDayOfYear(date: Date): number;
    /** Вставляет replacement в строку str начиная с позиции index, заменяя существующие символы str. */
    function replaceStringAt(str: string, index: number, replacement: string): string;
    /** @internal */
    function defineBackwardCompabilityLegacyController(name: FieldSpec<any, any>): void;
    /** Вызывает оператор as для преобразования типа объекта. */
    function cast<T>(object: any): T;
    /** Возвращает массив, отфильтровав повторяющиеся значения. */
    function arrayUnique(arr: any[]): any[];
    /** Возвращает пересечение двух множеств. */
    function arrayIntersection(arr1: any[], arr2: any[]): any[];
    /** Возвращает различие двух множеств. */
    function arrayDifference(arr1: any[], arr2: any[]): any[];
    /** Проверяет, что операция редактирования доступна. */
    function editOperationAvailable(store: $EditOperationStore, binding: IBindingResult<any>): boolean;
    /** Проверяет, что встроенная операция редактирования доступна. */
    function builtinEditOperationAvailable(store: $EditOperationStore, builtinOperationId: string): boolean;
    /** Возвращает services.cardId. */
    function tryGetCardId(services: Optional<$CardId>): string;
    /** Форматирует строку, заменяя вхождения {0}, {1}, {2}... на значения переданных параметров. */
    function formatString(str: string, ...args: any[]): string;
    /** Возвращает true, если переданная строка оканчивается на двоеточие. */
    function endsWithColon(str: string): boolean;
}
declare namespace WebClient {
    /** @internal */
    enum HttpMethods {
        Get = 0,
        Post = 1,
    }
    /** @internal */
    class BaseController {
        protected services: $RequestManager;
        constructor(services?: $RequestManager);
        protected basePostRequest(url: string, data: any, options?: RequestOptions): JQueryDeferred<any>;
        protected baseGetRequest(url: string, options?: RequestOptions): JQueryDeferred<any>;
        protected doRequest({controller, action, isApi, method, data, options}: {
            controller: string;
            action: string;
            isApi: boolean;
            method: HttpMethods;
            data?: any;
            options?: RequestOptions;
        }): JQueryDeferred<any>;
        protected getUrl({controller, action, isApi, method, data}: {
            controller: string;
            action: string;
            isApi: boolean;
            method: HttpMethods;
            data: any;
        }): string;
    }
}
declare namespace WebClient.GenControllers {
    /**
     * File controller
     */
    interface IRazorControlController {
        /**
         * Render razor control
         *
         * @param viewName View name
         * @param model Model
         * @param viewPath View path
         * @param viewData Additinal data
         *
         * @returns Rendered control
         */
        render<T>(viewName: string, model: T, viewPath: string, viewData?: Array<any>, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
    class RazorControlController extends WebClient.BaseController implements IRazorControlController {
        render<T>(viewName: string, model: T, viewPath: string, viewData?: Array<any>, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
}
declare type $RazorControlController = {
    razorControlController: WebClient.GenControllers.IRazorControlController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout links controller
     */
    interface ILayoutLinksMvcController {
        /**
         * POST: /LayoutLinks/GetLinksResult
         */
        getLinksResult(queryViewRequest: WebClient.GenModels.QueryViewRequest, allowedCardTypes?: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
    class LayoutLinksMvcController extends WebClient.BaseController implements ILayoutLinksMvcController {
        getLinksResult(queryViewRequest: WebClient.GenModels.QueryViewRequest, allowedCardTypes?: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
}
declare type $LayoutLinksMvcController = {
    layoutLinksMvcController: WebClient.GenControllers.ILayoutLinksMvcController;
};
declare namespace WebClient.GenControllers {
    /**
     * Cards controller
     */
    interface ICardController {
        /**
         * HTTP: /Card/SetWasRead
         */
        setWasRead(cardIds: Array<string>, setRead?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/CheckLock
         */
        checkLock(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/CheckModified
         */
        checkModified(cardId: string, timestamp: number, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/KindAvailable
         */
        checkKindCreatable(cardTypeId: string, cardKindId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/GetViewRoute
         */
        getViewRoute(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/GetViewList
         */
        getViewList(folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/IsViewInList
         */
        isViewInList(folderId: string, viewId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/Show/id
         */
        show(id: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/UnknownCardView/cardId
         */
        unknownCardView(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/GetReferenceList
         *
         * @param cardId card id
         *
         * @returns reference list model
         */
        getReferenceList(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Card/GetReferenceListContent
         *
         * @param cardId card id
         *
         * @returns reference list model content
         */
        getReferenceListContent(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/DeleteLink
         *
         * @param cardId card id
         * @param timestamp card timestamp
         * @param linkId link id
         */
        deleteLink(cardId: string, timestamp: number, linkId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
    class CardController extends WebClient.BaseController implements ICardController {
        setWasRead(cardIds: Array<string>, setRead?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        checkLock(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        checkModified(cardId: string, timestamp: number, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        checkKindCreatable(cardTypeId: string, cardKindId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        getViewRoute(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        getViewList(folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        isViewInList(folderId: string, viewId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        show(id: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        unknownCardView(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        getReferenceList(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        getReferenceListContent(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        deleteLink(cardId: string, timestamp: number, linkId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
}
declare type $CardController = {
    cardController: WebClient.GenControllers.ICardController;
};
declare namespace WebClient.GenControllers {
    /**
     * Error controller
     */
    interface IErrorController {
        /**
         * HTTP: /Error/Index
         */
        index(statusCode: number, exception: any, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Error/AccessDenied
         */
        accessDenied(options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
    class ErrorController extends WebClient.BaseController implements IErrorController {
        index(statusCode: number, exception: any, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        accessDenied(options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
}
declare type $ErrorController = {
    errorController: WebClient.GenControllers.IErrorController;
};
declare namespace WebClient.GenControllers {
    /**
     * Navigator controller
     */
    interface INavigatorController {
        /**
         * HTTP: /Navigator/GetFolderTree
         */
        getNavigatorFolders(id?: string, excludeSeachParamFolder?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/AddUserFolder
         */
        attachUserFolders(folderIds: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Index
         */
        index(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * Awake
         */
        awake(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/About
         */
        about(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/SwitchView
         */
        switchView(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/GetCardCreateLinks
         */
        getCardCreateLinks(folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/GetCardCreateTemplates
         */
        getCardCreateTemplates(folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/GetCreationRoute
         */
        getCreationRoute(cardId: string, cardTypeId: string, defaultRoute: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * HTTP: /Navigator/GetCardKinds
         */
        getCardKinds(cardTypeId: string, folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/SendFoldersAndUnreadCounters
         */
        sendFoldersAndUnreadCounters(unreadCountersRequest: WebClient.GenModels.UnreadCountersRequest, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/ShowSelectExistingCard
         */
        showSelectExistingCard(cardId: string, isReport?: boolean, allowedLinkTypes?: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/ShowSelectNewDocumentKind
         */
        showSelectNewDocumentKind(isReport?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/AttachLink
         */
        attachLink(model: WebClient.GenModels.LinkAddModel, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * HTTP: /Navigator/SetClientTimeoffset
         */
        setClientTimeoffset(timeoffset: number, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * HTTP: /Navigator/HealthCheck
         */
        healthCheck(options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
    class NavigatorController extends WebClient.BaseController implements INavigatorController {
        getNavigatorFolders(id?: string, excludeSeachParamFolder?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        attachUserFolders(folderIds: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        index(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        awake(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        about(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        switchView(options?: WebClient.RequestOptions): JQueryDeferred<string>;
        getCardCreateLinks(folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        getCardCreateTemplates(folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        getCreationRoute(cardId: string, cardTypeId: string, defaultRoute: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        getCardKinds(cardTypeId: string, folderId: string, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        sendFoldersAndUnreadCounters(unreadCountersRequest: WebClient.GenModels.UnreadCountersRequest, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        showSelectExistingCard(cardId: string, isReport?: boolean, allowedLinkTypes?: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        showSelectNewDocumentKind(isReport?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        attachLink(model: WebClient.GenModels.LinkAddModel, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        setClientTimeoffset(timeoffset: number, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        healthCheck(options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
}
declare type $NavigatorController = {
    navigatorController: WebClient.GenControllers.INavigatorController;
};
declare namespace WebClient.GenControllers {
    /**
     * Business calendar controller
     */
    interface IBusinessCalendarController {
        /**
         * Get work-time settings
         *
         * @param requestModel Request model
         */
        getWorkTimeSettings(requestModel: WebClient.GenModels.CalendarRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.CalendarYearSettings>>;
        /**
         * Get duration
         *
         * @param requestModel Request model
         */
        getDuration(requestModel: WebClient.GenModels.CalendarDurationRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<number>;
        /**
         * Get end date
         *
         * @param requestModel Request model
         */
        getEndDate(requestModel: WebClient.GenModels.CalendarEndDateRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
    class BusinessCalendarController extends WebClient.BaseController implements IBusinessCalendarController {
        getWorkTimeSettings(requestModel: WebClient.GenModels.CalendarRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.CalendarYearSettings>>;
        getDuration(requestModel: WebClient.GenModels.CalendarDurationRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<number>;
        getEndDate(requestModel: WebClient.GenModels.CalendarEndDateRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<string>;
    }
}
declare type $BusinessCalendarController = {
    businessCalendarController: WebClient.GenControllers.IBusinessCalendarController;
};
declare namespace WebClient.GenControllers {
    /**
     * Comments controller
     */
    interface ICommentsController {
        /**
         * Get comments
         *
         * @param requestModel Request model
         */
        getComments(requestModel: WebClient.GenModels.CommentsRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CommentsModel>;
        /**
         * Add comment
         *
         * @param requestModel Request model
         */
        addComment(requestModel: WebClient.GenModels.AddCommentRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Update comment
         *
         * @param requestModel Request model
         */
        updateComment(requestModel: WebClient.GenModels.UpdateCommentRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Delete comment
         *
         * @param requestModel Request model
         */
        deleteComment(requestModel: WebClient.GenModels.DeleteCommentRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
    class CommentsController extends WebClient.BaseController implements ICommentsController {
        getComments(requestModel: WebClient.GenModels.CommentsRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CommentsModel>;
        addComment(requestModel: WebClient.GenModels.AddCommentRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        updateComment(requestModel: WebClient.GenModels.UpdateCommentRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        deleteComment(requestModel: WebClient.GenModels.DeleteCommentRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
}
declare type $CommentsController = {
    commentsController: WebClient.GenControllers.ICommentsController;
};
declare namespace WebClient.GenControllers {
    /**
     * Signatyre controller
     */
    interface ISignatureController {
        /**
         * Gets available signature kind depends on certificate, settings, etc
         *
         * @param certEncoded certificate
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        getSignatureKind(certEncoded: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.SignatureKindSelectionModel>;
    }
    class SignatureController extends WebClient.BaseController implements ISignatureController {
        getSignatureKind(certEncoded: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.SignatureKindSelectionModel>;
    }
}
declare type $SignatureController = {
    signatureController: WebClient.GenControllers.ISignatureController;
};
declare namespace WebClient.GenControllers {
    /**
     * Tasks tree controller
     */
    interface ITasksTreeController {
        /**
         * Get tasks tree
         *
         * @param requestModel Request model
         *
         * @returns Tasks tree
         */
        get(requestModel: WebClient.GenModels.TasksTreeRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.TasksTreeModel>;
        /**
         * Get help model for node
         *
         * @param requestModel Request model
         *
         * @returns Help model for node
         */
        getNodeHelpModel(requestModel: WebClient.GenModels.TasksTreeNodeHelpRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.TreeNodeHelpModel>;
    }
    class TasksTreeController extends WebClient.BaseController implements ITasksTreeController {
        get(requestModel: WebClient.GenModels.TasksTreeRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.TasksTreeModel>;
        getNodeHelpModel(requestModel: WebClient.GenModels.TasksTreeNodeHelpRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.TreeNodeHelpModel>;
    }
}
declare type $TasksTreeController = {
    tasksTreeController: WebClient.GenControllers.ITasksTreeController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout partner controller
     */
    interface ILayoutPartnerController {
        /**
         * find department by name
         *
         * @param query search string
         */
        quickSearch(query: WebClient.GenModels.PartnerQuickSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.PartnerQuickSearchResponse>;
        /**
         * find department by name
         *
         * @param query search string
         */
        loadTree(query: WebClient.GenModels.PartnerLoadQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.PartnerTreeLoadResponse>;
        /**
         * find department by name
         *
         * @param query search string
         */
        directorySearch(query: WebClient.GenModels.PartnerQuickSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.PartnerSearchResponse>;
    }
    class LayoutPartnerController extends WebClient.BaseController implements ILayoutPartnerController {
        quickSearch(query: WebClient.GenModels.PartnerQuickSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.PartnerQuickSearchResponse>;
        loadTree(query: WebClient.GenModels.PartnerLoadQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.PartnerTreeLoadResponse>;
        directorySearch(query: WebClient.GenModels.PartnerQuickSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.PartnerSearchResponse>;
    }
}
declare type $LayoutPartnerController = {
    layoutPartnerController: WebClient.GenControllers.ILayoutPartnerController;
};
declare namespace WebClient.GenControllers {
    /**
     * Controller for user settings of layout
     */
    interface ILayoutUserSettingsController {
        /**
         * Get settings for main menu
         */
        getMainMenuSettings(options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.MainMenuSettings>;
        /**
         * Save settings for main menu
         *
         * @param settings Request model
         */
        saveMainMenuSettings(settings: WebClient.GenModels.MainMenuSettings, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
    class LayoutUserSettingsController extends WebClient.BaseController implements ILayoutUserSettingsController {
        getMainMenuSettings(options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.MainMenuSettings>;
        saveMainMenuSettings(settings: WebClient.GenModels.MainMenuSettings, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
}
declare type $LayoutUserSettingsController = {
    layoutUserSettingsController: WebClient.GenControllers.ILayoutUserSettingsController;
};
declare namespace WebClient.GenControllers {
    /**
     * Pages controller
     */
    interface IPagesController {
        /**
         * Get recent cards
         *
         * @param requestModel Request model
         *
         * @returns Model with list of recent cards
         */
        recentCards(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CardListViewModel>;
    }
    class PagesController extends WebClient.BaseController implements IPagesController {
        recentCards(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CardListViewModel>;
    }
}
declare type $PagesController = {
    pagesController: WebClient.GenControllers.IPagesController;
};
declare namespace WebClient.GenControllers {
    /**
     * Grid controller
     */
    interface IGridController {
        /**
         * Get card list
         *
         * TODO: make http get
         *
         * @param requestModel Request model
         */
        getCardList(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CardListViewModel>;
        /**
         * Get grid filter layout model
         *
         * @param requestModel Request model
         */
        getFilter(requestModel: WebClient.GenModels.GridFilterRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        /**
         * Get grid data
         *
         * @param requestModel Request model
         *
         * @returns Grid data
         */
        getGridData(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.GridViewModel>;
        /**
         * Get grid data silently
         *
         * @param requestModel Request model
         *
         * @returns Grid data
         */
        getGridDataSilent(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.GridViewModel>;
    }
    class GridController extends WebClient.BaseController implements IGridController {
        getCardList(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CardListViewModel>;
        getFilter(requestModel: WebClient.GenModels.GridFilterRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        getGridData(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.GridViewModel>;
        getGridDataSilent(requestModel: WebClient.GenModels.CardListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.GridViewModel>;
    }
}
declare type $GridController = {
    gridController: WebClient.GenControllers.IGridController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout controller
     */
    interface ILayoutController {
        /**
         * Get layout
         *
         * @param layoutPositionName Position name
         * @param cardId Card id
         *
         * @returns Layout model
         */
        get(layoutPositionName: string, cardId?: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        /**
         * Get layout
         */
        getWithParams(request: WebClient.GenModels.GetRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        /**
         * Get specified control info from whole layout
         *
         * @param layoutPositionName Position name
         * @param controlName Control name
         * @param cardId Card id
         *
         * @returns Layout model with control info
         */
        getPart(layoutPositionName: string, controlName: string, cardId?: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        /**
         * Get specified control info from whole layout
         *
         * @returns Layout model with control info
         */
        getPartWithParams(request: WebClient.GenModels.GetPartRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
    }
    class LayoutController extends WebClient.BaseController implements ILayoutController {
        get(layoutPositionName: string, cardId?: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        getWithParams(request: WebClient.GenModels.GetRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        getPart(layoutPositionName: string, controlName: string, cardId?: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
        getPartWithParams(request: WebClient.GenModels.GetPartRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutViewModel>;
    }
}
declare type $LayoutController = {
    layoutController: WebClient.GenControllers.ILayoutController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout history controller
     */
    interface ILayoutHistoryController {
        /**
         * Get history records
         *
         * @param query search string
         */
        getHistoryRecords(query: WebClient.GenModels.HistorySearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.HistorySearchResult>;
    }
    class LayoutHistoryController extends WebClient.BaseController implements ILayoutHistoryController {
        getHistoryRecords(query: WebClient.GenModels.HistorySearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.HistorySearchResult>;
    }
}
declare type $LayoutHistoryController = {
    layoutHistoryController: WebClient.GenControllers.ILayoutHistoryController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout card kind controller
     */
    interface ILayoutCardKindController {
        /**
         * Load kinds tree
         */
        loadTree(options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.CardKindInfoModel>>;
    }
    class LayoutCardKindController extends WebClient.BaseController implements ILayoutCardKindController {
        loadTree(options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.CardKindInfoModel>>;
    }
}
declare type $LayoutCardKindController = {
    layoutCardKindController: WebClient.GenControllers.ILayoutCardKindController;
};
declare namespace WebClient.GenControllers {
    /**
     * Card types controller
     */
    interface ICardTypesController {
        /**
         * Gets card types
         */
        get(options?: WebClient.RequestOptions): JQueryDeferred<any>;
    }
    class CardTypesController extends WebClient.BaseController implements ICardTypesController {
        get(options?: WebClient.RequestOptions): JQueryDeferred<any>;
    }
}
declare type $CardTypesController = {
    cardTypesController: WebClient.GenControllers.ICardTypesController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout tasks controller
     */
    interface ILayoutTasksController {
        /**
         * GET: /LayoutTasks/GetTasks
         */
        getTaskList(request: WebClient.GenModels.GetTasksListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.TaskDataModel>>;
        /**
         * Get tasks by specified card id
         *
         * @param cardId Card id
         * @param availableKinds List of available kinds ids
         */
        getTasks(cardId: string, availableKinds: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.TaskDataModel>>;
    }
    class LayoutTasksController extends WebClient.BaseController implements ILayoutTasksController {
        getTaskList(request: WebClient.GenModels.GetTasksListRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.TaskDataModel>>;
        getTasks(cardId: string, availableKinds: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.TaskDataModel>>;
    }
}
declare type $LayoutTasksController = {
    layoutTasksController: WebClient.GenControllers.ILayoutTasksController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout file controller
     */
    interface ILayoutAgreementController {
        /**
         * Get agreement list
         *
         * @param cardId Card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        getAgreementList(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.AgreementListModel>;
        /**
         * Get model for AgreementManagement control
         *
         * @param cardId Document card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        getAgreementManagementModel(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutAgreementManagementModel>;
        /**
         * Gets model for the start agreement in AgreementManagementControl
         *
         * @param documentCardId Document card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        getAgreementManagementStartModel(documentCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.AgreementManagementStartModel>;
        /**
         * Gets model for the edit agreement in AgreementManagementControl
         *
         * @param documentCardId Document card id
         * @param reconcileCardId Reconcile card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        getAgreementManagementEditModel(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.AgreementManagementEditModel>;
        /**
         * Gets template stages AgreementManagementControl
         *
         * @param documentId Document id
         * @param templateId Template id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        getAgreementTemplateStages(documentId: string, templateId: string, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.StageModel>>;
        /**
         * Create Reconciliation
         *
         * @param model Reconcilation creation model
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        createReconciliation(model: WebClient.GenModels.ReconcilationCreationModel, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        /**
         * Create Reconciliation
         *
         * @param model Reconcilation edit model
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        changeStages(model: WebClient.GenModels.ReconcilationEditModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Interrupt current stages
         *
         * @param documentCardId Document card id
         * @param reconcileCardId Reconcile card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        interruptCurrentStages(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Stop agreement
         *
         * @param documentCardId Document card id
         * @param reconcileCardId Reconcile card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        agreementStop(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Finish agreement
         *
         * @param documentCardId Document card id
         * @param reconcileCardId Resoncile card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        agreementFinish(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Pause agreement
         *
         * @param documentCardId Document card id
         * @param reconcileCardId Reconcile card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        agreementPause(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Resume agreement
         *
         * @param documentCardId Document card id
         * @param reconcileCardId Reconcile card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        agreementResume(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Get agreement history
         *
         * @param reconcileCardId Reconcile card id
         *
         * @returns JSON representation of {@link WebClient.GenModels}
         */
        getAgreementHistory(reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.ApprovalHistoryViewModel>;
    }
    class LayoutAgreementController extends WebClient.BaseController implements ILayoutAgreementController {
        getAgreementList(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.AgreementListModel>;
        getAgreementManagementModel(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutAgreementManagementModel>;
        getAgreementManagementStartModel(documentCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.AgreementManagementStartModel>;
        getAgreementManagementEditModel(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.AgreementManagementEditModel>;
        getAgreementTemplateStages(documentId: string, templateId: string, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.StageModel>>;
        createReconciliation(model: WebClient.GenModels.ReconcilationCreationModel, options?: WebClient.RequestOptions): JQueryDeferred<string>;
        changeStages(model: WebClient.GenModels.ReconcilationEditModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        interruptCurrentStages(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        agreementStop(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        agreementFinish(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        agreementPause(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        agreementResume(documentCardId: string, reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        getAgreementHistory(reconcileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.ApprovalHistoryViewModel>;
    }
}
declare type $LayoutAgreementController = {
    layoutAgreementController: WebClient.GenControllers.ILayoutAgreementController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout card controller
     */
    interface ILayoutCardController {
        /**
         * HTTP: /LayoutCard/NewCard
         */
        newCard(createParams: WebClient.GenModels.LayoutCardCreateParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        /**
         * HTTP: /LayoutCard/View
         */
        view(cardId: string, refresh?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        /**
         * HTTP: /LayoutCard/Edit
         */
        edit(cardId: string, refresh?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        /**
         * HTTP: /LayoutCard/Delete
         */
        delete(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Gets layout part
         *
         * @param layoutPartParams layout part params
         */
        getLayoutPart(layoutPartParams: WebClient.GenModels.LayoutPartParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutModel>;
        /**
         * HTTP: /LayoutCard/Save
         */
        save(model: WebClient.GenModels.SaveControlDataModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * HTTP: /LayoutCard/CheckModifiedAndLocked
         */
        checkModifiedAndLocked(cardId: string, timestamp: number, refresh?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * HTTP: /LayoutCard/ChangeState
         */
        changeState(changeStateDataModel: WebClient.GenModels.ChangeStateDataModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        /**
         * HTTP: /LayoutCard/CheckAccess
         */
        checkAccess(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<boolean>;
    }
    class LayoutCardController extends WebClient.BaseController implements ILayoutCardController {
        newCard(createParams: WebClient.GenModels.LayoutCardCreateParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        view(cardId: string, refresh?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        edit(cardId: string, refresh?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        delete(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        getLayoutPart(layoutPartParams: WebClient.GenModels.LayoutPartParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutModel>;
        save(model: WebClient.GenModels.SaveControlDataModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        checkModifiedAndLocked(cardId: string, timestamp: number, refresh?: boolean, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        changeState(changeStateDataModel: WebClient.GenModels.ChangeStateDataModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LayoutCardViewModel>;
        checkAccess(cardId: string, options?: WebClient.RequestOptions): JQueryDeferred<boolean>;
    }
}
declare type $LayoutCardController = {
    layoutCardController: WebClient.GenControllers.ILayoutCardController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout directory designer controller
     */
    interface ILayoutDirectoryDesignerController {
        /**
         * Find department by name
         *
         * @param query Search string
         */
        findRows(query: WebClient.GenModels.DirectoryDesignerSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DirectoryDesignerSearchResult>;
        /**
         * Load directory tree nodes
         *
         * @param query Search query params
         */
        loadTree(query: WebClient.GenModels.DirectoryDesignerLoadTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DirectoryDesignerTreeNode>>;
        /**
         * Find in tree
         *
         * @param query Search query params
         */
        findInTree(query: WebClient.GenModels.DirectoryDesignerSearchTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DirectoryDesignerSearchTreeResult>;
    }
    class LayoutDirectoryDesignerController extends WebClient.BaseController implements ILayoutDirectoryDesignerController {
        findRows(query: WebClient.GenModels.DirectoryDesignerSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DirectoryDesignerSearchResult>;
        loadTree(query: WebClient.GenModels.DirectoryDesignerLoadTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DirectoryDesignerTreeNode>>;
        findInTree(query: WebClient.GenModels.DirectoryDesignerSearchTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DirectoryDesignerSearchTreeResult>;
    }
}
declare type $LayoutDirectoryDesignerController = {
    layoutDirectoryDesignerController: WebClient.GenControllers.ILayoutDirectoryDesignerController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout document card controller
     */
    interface ILayoutDocumentController {
        /**
         * Generate number and optionally save it to the card
         *
         * @param request Number generation request
         */
        generateNumber(request: WebClient.GenModels.GenerateNumberRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.NumberInfo>;
        /**
         * Release document number
         */
        releaseNumber(request: WebClient.GenModels.ReleaseNumberRequest, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Runs acquaintance business process for specified employees
         */
        sendForAcquaintance(request: WebClient.GenModels.SendForAcquaintanceRequest, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
    class LayoutDocumentController extends WebClient.BaseController implements ILayoutDocumentController {
        generateNumber(request: WebClient.GenModels.GenerateNumberRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.NumberInfo>;
        releaseNumber(request: WebClient.GenModels.ReleaseNumberRequest, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        sendForAcquaintance(request: WebClient.GenModels.SendForAcquaintanceRequest, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
}
declare type $LayoutDocumentController = {
    layoutDocumentController: WebClient.GenControllers.ILayoutDocumentController;
};
declare namespace WebClient.GenControllers {
    /**
     * Defines abstract class for file upload web api controllers
     */
    interface IFileUploadApiController {
    }
    abstract class FileUploadApiController extends WebClient.BaseController implements IFileUploadApiController {
    }
}
declare type $FileUploadApiController = {
    fileUploadApiController: WebClient.GenControllers.IFileUploadApiController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout file api controller
     */
    interface ILayoutFileApiController {
        /**
         * POST: /LayoutFileApi/AddFiles
         */
        addFiles(options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * POST: /DocumentCardApi/AddNewMainFileVersion
         */
        addNewMainFileVersion(options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * POST: /LayoutFileApi/AddFiles
         */
        uploadFiles(options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * GET: /LayoutFileApi/DeleteFiles
         */
        deleteFiles(fileIdList: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
    class LayoutFileApiController extends WebClient.GenControllers.FileUploadApiController implements ILayoutFileApiController {
        addFiles(options?: WebClient.RequestOptions): JQueryDeferred<any>;
        addNewMainFileVersion(options?: WebClient.RequestOptions): JQueryDeferred<any>;
        uploadFiles(options?: WebClient.RequestOptions): JQueryDeferred<any>;
        deleteFiles(fileIdList: Array<string>, options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
}
declare type $LayoutFileApiController = {
    layoutFileApiController: WebClient.GenControllers.ILayoutFileApiController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout file controller
     */
    interface ILayoutFileController {
        /**
         * POST: /LayoutFile/GetFiles
         */
        getFiles(request: WebClient.GenModels.GetFilesRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModelBase>;
        /**
         * POST: /LayoutFile/GetVersions
         */
        getVersions(request: WebClient.GenModels.GetVersionsRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListVersionsDataModel>;
        /**
         * POST: /LayoutFile/GetComments
         */
        getComments(request: WebClient.GenModels.GetCommentsRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.VersionedFileCommentListModel>;
        /**
         * POST: /LayoutFile/AddOrUpdateComment
         */
        addOrUpdateComment(versionedFileCommentCreateModel: WebClient.GenModels.VersionedFileCommentCreateModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * GET: /LayoutFile/DeleteComment
         */
        deleteComment(versionedFileCommentDeleteModel: WebClient.GenModels.VersionedFileCommentDeleteModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * GET: /LayoutFile/LockFile
         */
        lockFile(request: WebClient.GenModels.CommmonFileRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModel>;
        /**
         * Will be remake after task with layout
         *
         * @param ownerCardId Owner card id
         * @param fileCardId File card id
         */
        lockTaskFile(ownerCardId: string, fileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * GET: /LayoutFile/UnlockFile
         */
        unlockFile(request: WebClient.GenModels.CommmonFileRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModel>;
        /**
         * Will be remake after task with layout
         *
         * @param ownerCardId Owner card id
         * @param fileCardId File card id
         */
        unlockTaskFile(ownerCardId: string, fileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * GET: /LayoutFile/DeleteFile
         */
        deleteFile(request: WebClient.GenModels.CommmonFileRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModel>;
    }
    class LayoutFileController extends WebClient.BaseController implements ILayoutFileController {
        getFiles(request: WebClient.GenModels.GetFilesRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModelBase>;
        getVersions(request: WebClient.GenModels.GetVersionsRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListVersionsDataModel>;
        getComments(request: WebClient.GenModels.GetCommentsRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.VersionedFileCommentListModel>;
        addOrUpdateComment(versionedFileCommentCreateModel: WebClient.GenModels.VersionedFileCommentCreateModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        deleteComment(versionedFileCommentDeleteModel: WebClient.GenModels.VersionedFileCommentDeleteModel, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        lockFile(request: WebClient.GenModels.CommmonFileRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModel>;
        lockTaskFile(ownerCardId: string, fileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        unlockFile(request: WebClient.GenModels.CommmonFileRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModel>;
        unlockTaskFile(ownerCardId: string, fileCardId: string, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        deleteFile(request: WebClient.GenModels.CommmonFileRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FileListDataModel>;
    }
}
declare type $LayoutFileController = {
    layoutFileController: WebClient.GenControllers.ILayoutFileController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout file controller
     */
    interface ILayoutFolderController {
        /**
         * Get user folders partial tree (only two levels deep).
         *
         * @param request Request model
         */
        getUserFoldersTreeData(request: WebClient.GenModels.GetUserFoldersTreeDataRequest, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.FolderNode>>;
        /**
         * Check folder settings, to determine if specified card can be created in this folder
         *
         * @param request Request model
         *
         * @returns JSON representation of {@link WebClient.GenModels} value, indicating result of the check.
         */
        checkFolderForAvailableCardKind(request: WebClient.GenModels.CheckFolderForAvailableCardKindRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CheckResult>;
        /**
         * Returns common information about folder.
         *
         * @param request Request model
         *
         * @returns Info about folder, see {@link WebClient.GenModels}
         */
        getFolderInfo(request: WebClient.GenModels.GetFolderInfoRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FolderNode>;
        /**
         * Returns common information about folder.
         *
         * @param request Request model
         *
         * @returns Folder node with parents
         */
        getFolderInfoWithParents(request: WebClient.GenModels.GetFolderInfoWithParentsRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FolderNodeWithParents>;
        /**
         * Detach user folder.
         *
         * @param request Request model
         *
         * @returns JSON representation of {@link WebClient.GenModels} value, indicating result of the detach.
         */
        detachUserFolders(request: WebClient.GenModels.DetachUserFoldersRequest, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        /**
         * Refresh folders settings cache
         */
        refreshFolders(options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
    class LayoutFolderController extends WebClient.BaseController implements ILayoutFolderController {
        getUserFoldersTreeData(request: WebClient.GenModels.GetUserFoldersTreeDataRequest, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.FolderNode>>;
        checkFolderForAvailableCardKind(request: WebClient.GenModels.CheckFolderForAvailableCardKindRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.CheckResult>;
        getFolderInfo(request: WebClient.GenModels.GetFolderInfoRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FolderNode>;
        getFolderInfoWithParents(request: WebClient.GenModels.GetFolderInfoWithParentsRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FolderNodeWithParents>;
        detachUserFolders(request: WebClient.GenModels.DetachUserFoldersRequest, options?: WebClient.RequestOptions): JQueryDeferred<void>;
        refreshFolders(options?: WebClient.RequestOptions): JQueryDeferred<void>;
    }
}
declare type $LayoutFolderController = {
    layoutFolderController: WebClient.GenControllers.ILayoutFolderController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout links controller
     */
    interface ILayoutLinksController {
        /**
         * GET: /LayoutLinks/DeleteLink
         */
        deleteLink(request: WebClient.GenModels.DeleteLinkRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        /**
         * GET: /LayoutLinks/GetLinkTypes
         */
        getLinkTypes(options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.LinkType>>;
        /**
         * POST: /LayoutLinks/CardCreateLinks
         */
        cardCreateLinks(allowedKinds: Array<WebClient.GenModels.AllowedCardKind>, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.LayoutKindModel>>;
        /**
         * POST: /LayoutLinks/AddExistingCardLink
         */
        addExistingCardLink(linkParams: WebClient.GenModels.LayoutLinkCreateParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        /**
         * POST: /LayoutLinks/AddUrlLink
         *
         * @param addUrlLinkParams
         */
        addUrlLink(addUrlLinkParams: WebClient.GenModels.AddUrlLinkParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        /**
         * POST: /LayoutLinks/SetLinkDescription
         */
        setLinkDescription(data: WebClient.GenModels.LayoutSetLinkDescriptionParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        /**
         * POST: /LayoutLinks/GetLinks
         */
        getLinks(request: WebClient.GenModels.GetLinksRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        /**
         * POST: /LayoutLinks/CheckReadMainFileAvailable
         */
        checkReadMainFileAvailable(request: WebClient.GenModels.CheckReadMainFileAvailableRequest, options?: WebClient.RequestOptions): JQueryDeferred<boolean>;
    }
    class LayoutLinksController extends WebClient.BaseController implements ILayoutLinksController {
        deleteLink(request: WebClient.GenModels.DeleteLinkRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        getLinkTypes(options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.LinkType>>;
        cardCreateLinks(allowedKinds: Array<WebClient.GenModels.AllowedCardKind>, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.LayoutKindModel>>;
        addExistingCardLink(linkParams: WebClient.GenModels.LayoutLinkCreateParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        addUrlLink(addUrlLinkParams: WebClient.GenModels.AddUrlLinkParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        setLinkDescription(data: WebClient.GenModels.LayoutSetLinkDescriptionParams, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        getLinks(request: WebClient.GenModels.GetLinksRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.LinksDataModel>;
        checkReadMainFileAvailable(request: WebClient.GenModels.CheckReadMainFileAvailableRequest, options?: WebClient.RequestOptions): JQueryDeferred<boolean>;
    }
}
declare type $LayoutLinksController = {
    layoutLinksController: WebClient.GenControllers.ILayoutLinksController;
};
declare namespace WebClient.GenControllers {
    /**
     * Layout controller for staff directory
     */
    interface ILayoutStaffController {
        /**
         * Find department by name
         *
         * @param query Search string
         */
        findDepartments(query: WebClient.GenModels.DepartmentSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FindDepartmentsResponse>;
        /**
         * Find departments tree by search query
         *
         * @param query Search query
         */
        loadDepartmentsTree(query: WebClient.GenModels.DepartmentLoadTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentTreeNode>>;
        /**
         * Find in departmt's tree
         */
        findInDepartmentsTree(query: WebClient.GenModels.DepartmentFindInTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DepartmentFindInTreeResult>;
        /**
         * Get departments info
         */
        getDepartmentsInfo(departmentIds: Array<string>, source?: WebClient.GenModels.DepartmentDataSource, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentExtendedModel>>;
        /**
         * Get employees and departments info
         */
        getStaffInfo(request: WebClient.GenModels.StaffInfoRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.StaffInfoResponseModel>;
        /**
         * Get departments and all its parents info
         */
        getDepartmentPath(departmentId: string, source?: WebClient.GenModels.DepartmentDataSource, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentExtendedModel>>;
        /**
         * Load department by parent
         *
         * @param query search query
         */
        loadDepartmentsFlat(query: WebClient.GenModels.DepartmentLoadFlatQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DepartmentLoadFlatResponse>;
        /**
         * Find department by name
         *
         * @param query search string
         */
        findInDepartmentsFlat(query: WebClient.GenModels.DepartmentSearchFlatQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DepartmentSearchFlatResponse>;
        /**
         * Find department by name
         *
         * @param query search string
         */
        getParentDepartments(query: WebClient.GenModels.GetParentDepartmentsRequest, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentModel>>;
        /**
         * Get employee image by employee id
         *
         * @param employeeId Employee id
         */
        getEmployeeImage(employeeId: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * HTTP: /Employees/Find
         */
        findEmployees(request: WebClient.GenModels.FindEmployeesRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FindEmployeesResponse>;
    }
    class LayoutStaffController extends WebClient.BaseController implements ILayoutStaffController {
        findDepartments(query: WebClient.GenModels.DepartmentSearchQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FindDepartmentsResponse>;
        loadDepartmentsTree(query: WebClient.GenModels.DepartmentLoadTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentTreeNode>>;
        findInDepartmentsTree(query: WebClient.GenModels.DepartmentFindInTreeQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DepartmentFindInTreeResult>;
        getDepartmentsInfo(departmentIds: Array<string>, source?: WebClient.GenModels.DepartmentDataSource, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentExtendedModel>>;
        getStaffInfo(request: WebClient.GenModels.StaffInfoRequestModel, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.StaffInfoResponseModel>;
        getDepartmentPath(departmentId: string, source?: WebClient.GenModels.DepartmentDataSource, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentExtendedModel>>;
        loadDepartmentsFlat(query: WebClient.GenModels.DepartmentLoadFlatQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DepartmentLoadFlatResponse>;
        findInDepartmentsFlat(query: WebClient.GenModels.DepartmentSearchFlatQuery, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.DepartmentSearchFlatResponse>;
        getParentDepartments(query: WebClient.GenModels.GetParentDepartmentsRequest, options?: WebClient.RequestOptions): JQueryDeferred<Array<WebClient.GenModels.DepartmentModel>>;
        getEmployeeImage(employeeId: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        findEmployees(request: WebClient.GenModels.FindEmployeesRequest, options?: WebClient.RequestOptions): JQueryDeferred<WebClient.GenModels.FindEmployeesResponse>;
    }
}
declare type $LayoutStaffController = {
    layoutStaffController: WebClient.GenControllers.ILayoutStaffController;
};
declare namespace WebClient.GenControllers {
    /**
     * Resources controller
     */
    interface ILocalizationController {
        /**
         * Gets localization
         */
        get(options?: WebClient.RequestOptions): JQueryDeferred<any>;
    }
    class LocalizationController extends WebClient.BaseController implements ILocalizationController {
        get(options?: WebClient.RequestOptions): JQueryDeferred<any>;
    }
}
declare type $LocalizationController = {
    localizationController: WebClient.GenControllers.ILocalizationController;
};
declare namespace WebClient.GenControllers {
    /**
     * WebDAV controller
     */
    interface IWebDavController {
        /**
         * Getting file
         *
         * @param id File card identifier
         * @param idext File name
         */
        get(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Request for resource existance
         *
         * @param id File card identifier
         * @param idext File name
         */
        head(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Request for resource locking
         *
         * @param id File card identifier
         * @param idext File name
         */
        lock(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Request for root resource
         *
         * @param id File card identifier
         *
         * @returns Returns supported Http methods list
         */
        options(id: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Get resource properties
         *
         * @param id File card identifier
         * @param idext File name
         */
        propfind(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Changing resource properties
         *
         * @param id File card identifier
         * @param idext File name
         */
        proppatch(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Changing file card content (adding file version)
         *
         * @param id File card identifier
         * @param idext File name
         */
        put(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        /**
         * Request for unlocking resource
         *
         * @param id File card identifier
         * @param idext File name
         */
        unlock(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
    }
    class WebDavController extends WebClient.BaseController implements IWebDavController {
        get(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        head(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        lock(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        options(id: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        propfind(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        proppatch(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        put(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
        unlock(id: string, idext: string, options?: WebClient.RequestOptions): JQueryDeferred<any>;
    }
}
declare type $WebDavController = {
    webDavController: WebClient.GenControllers.IWebDavController;
};
declare namespace WebClient.GenModels {
    interface QueryViewRequest {
        /**
         * Gets or sets folder identifier
         */
        folderId: string;
        /**
         * Folder setting - seconds to auto refresh. Zero value inidicates, that autorefresh disabled.
         */
        folderRefreshTimeout: number;
        /**
         * Data for unread counters calculation (or not only unread counters?)
         */
        forceVirtualFolderSearch: boolean;
        /**
         * Gets or sets search identifier
         */
        searchId: string;
        /**
         * Gets or sets view identifier
         */
        viewId: string;
        /**
         * Gets or sets full text filter string
         */
        fullTextFilter: string;
        /**
         * Gets or sets whether view should get cached data or refreshed
         */
        refreshView: boolean;
        /**
         * Gets or sets sorted column name
         */
        sortedColumnName: string;
        /**
         * Gets or sets value indicated whether is descending sort order
         */
        isDescending: boolean;
        /**
         * Gets or sets page number
         */
        pageNumber: number;
        /**
         * Gets or sets old search results store identifier
         */
        oldStoreId: string;
        /**
         * Gets or sets search context option
         */
        searchContextOption: WebClient.GenModels.SearchContextOption;
        /**
         * Gets or sets attribute search text
         */
        attributeTextFilter: string;
        /**
         * Gets or sets Filters
         */
        filters: Array<WebClient.GenModels.QueryFilterItem>;
    }
}
declare namespace WebClient.GenModels {
    interface QueryFilterItem {
        /**
         * Gets or sets filtered columnt name
         */
        name: string;
        /**
         * Gets or sets values
         */
        values: Array<string>;
    }
}
declare namespace WebClient.GenModels {
    interface UnreadCountersRequest {
        /**
         * Gets or sets employee identifier
         */
        employeeId: string;
        /**
         * Gets or sets tab identifier
         */
        realtimeSessionId: string;
        /**
         * Gets client folders with current counters
         */
        clientFolders: Array<WebClient.GenModels.UnreadCountersFolderInfo>;
    }
}
declare namespace WebClient.GenModels {
    interface UnreadCountersFolderInfo {
        /**
         * Gets or sets folder identifier
         */
        folderId: string;
        /**
         * Minutes to refresh counter
         */
        refreshTimeout: number;
        /**
         * Gets or sets virtual folder search refresh parameter
         */
        forceVirtualFolderSearch: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface LinkAddModel {
        /**
         * Gets or sets card timestamp
         */
        timestamp: number;
        /**
         * Gets or sets source card identifier
         */
        sourceCardId: string;
        /**
         * Gets or sets destination card identifier
         */
        destinationCardId: string;
        /**
         * Gets or sets link type identifier
         */
        linkTypeId: string;
        /**
         * Gets or sets flag if link is backward
         */
        oppositeLinkName: string;
        /**
         * Gets or sets source card type
         */
        sourceCardType: string;
        /**
         * Gets or sets flag if link is file
         */
        isFileLink: boolean;
        /**
         * Gets or sets flag if link is report
         */
        isReport: boolean;
        /**
         * Gets or sets value whether indicate create link for new card
         */
        isNewCard: boolean;
        /**
         * Gets or sets link types
         */
        linkTypes: Array<WebClient.GenModels.LinkTypeModel>;
        /**
         * Gets or sets value whether LinkTypes array has some predefined order
         */
        linkTypesSorted: boolean;
        /**
         * Gets or sets value whether hard link should be created
         */
        hardLink: boolean;
        /**
         * Gets or sets is link type selectable
         */
        isLinkTypeSelectable: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface LinkTypeModel {
        /**
         * Gets or sets id
         */
        linkTypeId: string;
        /**
         * Gets or sets type name
         */
        name: string;
        /**
         * Gets or set display name
         */
        displayName: string;
        /**
         * Gets or sets flag indicated if the link is bidirectional
         */
        oppositeLinkName: string;
    }
}
declare namespace WebClient.GenModels {
    interface CalendarRequestModel {
        /**
         * Restrict result with specified year only
         */
        year?: number;
        /**
         * Restrict result with specified day only
         */
        day?: number;
    }
}
declare namespace WebClient.GenModels {
    interface CalendarYearSettings {
        /**
         * Year
         */
        year: number;
        /**
         * Value of business calendar EndTime
         */
        days: Array<WebClient.GenModels.CalendarDaySettings>;
    }
}
declare namespace WebClient.GenModels {
    interface CalendarDaySettings {
        /**
         * Day number from begining of the year
         */
        day: number;
        /**
         * Value of business calendar WorkTime
         */
        workTime: WebClient.GenModels.CalendarWorkTime;
    }
}
declare namespace WebClient.GenModels {
    interface CalendarWorkTime {
        /**
         * Value of business calendar StartTime in milliseconds from 0:00
         */
        begin: number;
        /**
         * Value of business calendar EndTime in milliseconds from 0:00
         */
        end: number;
    }
}
declare namespace WebClient.GenModels {
    interface CalendarDurationRequestModel {
        /**
         * What calendar use to calculate value
         */
        calendarSources: Array<WebClient.GenModels.BusinessCalendarSource>;
        /**
         * Date of the start of the period
         */
        startDate: string;
        /**
         * Date of the end of the period
         */
        endDate: string;
    }
}
declare namespace WebClient.GenModels {
    interface BusinessCalendarSource {
        /**
         * Employee or unit identifier
         */
        id: string;
        /**
         * Type of {@link WebClient.GenModels}
         */
        type: WebClient.GenModels.BusinessCalendarSourceType;
    }
}
declare namespace WebClient.GenModels {
    interface CalendarEndDateRequestModel {
        /**
         * What calendar use to calculate value
         */
        calendarSources: Array<WebClient.GenModels.BusinessCalendarSource>;
        /**
         * Date of the start of the period
         */
        startDate: string;
        /**
         * Duration of the period
         */
        duration: number;
    }
}
declare namespace WebClient.GenModels {
    interface CommentsRequestModel {
        /**
         * Gets or sets comments data source
         */
        commentsDataSource: WebClient.GenModels.CommentsDataSourceModel;
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets max count
         */
        maxCount: number;
    }
}
declare namespace WebClient.GenModels {
    interface CommentsDataSourceModel {
        /**
         * Gets or sets use related card data
         */
        useRelatedCardData: boolean;
        /**
         * Gets or sets related card section
         */
        relatedCardSection: string;
        /**
         * Gets or sets related card field alias
         */
        relatedCardFieldAlias: string;
        /**
         * Gets or sets data source card section
         */
        dataSourceCardSection: string;
        /**
         * Gets or sets author field alias
         */
        authorFieldAlias: string;
        /**
         * Gets or sets date field alias
         */
        dateFieldAlias: string;
        /**
         * Gets or sets text field alias
         */
        textFieldAlias: string;
    }
}
declare namespace WebClient.GenModels {
    interface CommentsModel {
        /**
         * Gets or sets comments list
         */
        comments: Array<WebClient.GenModels.Comment>;
        /**
         * Gets or sets comments data source
         */
        commentsDataSource: WebClient.GenModels.CommentsDataSourceModel;
        /**
         * Gets or sets all comments count
         */
        allCommentsCount: number;
    }
}
declare namespace WebClient.GenModels {
    interface Comment {
        /**
         * Gets or sets identifier
         */
        id: string;
        /**
         * Gets or sets employee identifier
         */
        employeeId?: string;
        /**
         * Gets or sets employee display name
         */
        employeeDisplayName: string;
        /**
         * Gets or sets date
         */
        date?: string;
        /**
         * Gets or sets text
         */
        text: string;
    }
}
declare namespace WebClient.GenModels {
    interface AddCommentRequestModel {
        /**
         * Gets or sets comments data source
         */
        commentsDataSource: WebClient.GenModels.CommentsDataSourceModel;
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets text
         */
        text: string;
    }
}
declare namespace WebClient.GenModels {
    interface UpdateCommentRequestModel {
        /**
         * Gets or sets comments data source
         */
        commentsDataSource: WebClient.GenModels.CommentsDataSourceModel;
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets comment identifier
         */
        commentId: string;
        /**
         * Gets or sets text
         */
        text: string;
    }
}
declare namespace WebClient.GenModels {
    interface DeleteCommentRequestModel {
        /**
         * Gets or sets comments data source
         */
        commentsDataSource: WebClient.GenModels.CommentsDataSourceModel;
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets comment identifier
         */
        commentId: string;
    }
}
declare namespace WebClient.GenModels {
    interface SignatureKindSelectionModel {
        /**
         * available signature kind
         */
        availableKind?: WebClient.GenModels.DigitalSignatureKind;
        /**
         * warning message
         */
        warning: string;
        /**
         * time-stamp protocol server address
         */
        tspAddress: string;
    }
}
declare namespace WebClient.GenModels {
    interface TasksTreeRequestModel {
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets task list identifier
         */
        taskListId: string;
        /**
         * Gets allowed kinds identifiers
         */
        kindIds: Array<string>;
        /**
         * Gets or sets whether not restrict tree to current card
         */
        fullTree: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface TasksTreeModel {
        /**
         * Gets tree nodes
         */
        parentCardId: string;
        /**
         * Gets tree nodes
         */
        nodes: Array<WebClient.GenModels.TreeNodeModel>;
        /**
         * Gets edges
         */
        edges: Array<WebClient.GenModels.TaskTreeEdge>;
    }
}
declare namespace WebClient.GenModels {
    interface TreeNodeModel {
        /**
         * Gets or sets node identifier
         */
        nodeId: string;
        /**
         * Gets or sets card type identifier
         */
        cardTypeId: string;
        /**
         * Gets or sets kind identifier
         */
        kindId: string;
        /**
         * Gets or sets tree node hint
         */
        hint: WebClient.GenModels.TreeNodeHintModel;
        /**
         * Is allowed to read this tree node
         */
        accessAllowed: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface TreeNodeHintModel {
    }
}
declare namespace WebClient.GenModels {
    interface TaskTreeEdge {
        /**
         * Gets or sets from node identifier
         */
        fromNode: string;
        /**
         * Gets or sets to node identifier
         */
        toNode: string;
    }
}
declare namespace WebClient.GenModels {
    interface TasksTreeNodeHelpRequestModel {
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets card type identifier
         */
        cardTypeId: string;
    }
}
declare namespace WebClient.GenModels {
    interface TreeNodeHelpModel {
        /**
         * Gets or set creation date
         */
        creationDate: string;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerQuickSearchQuery {
        /**
         * Search mode
         */
        searchMode: WebClient.GenModels.PartnerSearchMode;
        searchText: string;
        departmentId?: string;
        /**
         * Partners count to skip from begin (pagination). Real skip = Skip - SkipDepartments;
         */
        skip?: number;
        /**
         * Departments count to skip from begin (pagination). Real skip = Skip - SkipDepartments;
         */
        skipDepartments?: number;
        /**
         * Max partners in pagination result
         */
        maxCount?: number;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerQuickSearchResponse {
        /**
         * List of {@link WebClient.GenModels}
         */
        items: Array<WebClient.GenModels.PartnerDirectoryItem>;
        /**
         * Has more items
         */
        hasMore: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerDirectoryItem {
        /**
         * Partner item type
         */
        itemType: WebClient.GenModels.PartnerItemType;
        /**
         * Item data
         */
        data: any;
        /**
         * Has item any children
         */
        hasChildren: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerLoadQuery {
        /**
         * Search mode
         */
        searchMode: WebClient.GenModels.PartnerSearchMode;
        /**
         * Department id
         */
        departmentId?: string;
        /**
         * Skip (pagination)
         */
        skip?: number;
        /**
         * Skip departments (pagination)
         */
        skipDepartments?: number;
        /**
         * Max count (pagination)
         */
        maxCount?: number;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerTreeLoadResponse {
        /**
         * List of partner directory items
         */
        items: Array<WebClient.GenModels.PartnerDirectoryItem>;
        /**
         * Total partners count
         */
        totalItemsCount: number;
        /**
         * Directory timestamp
         */
        directoryTimestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerSearchResponse {
        /**
         * List of {@link WebClient.GenModels}
         */
        items: Array<WebClient.GenModels.PartnerDirectorySearchItem>;
        /**
         * Has more items
         */
        hasMore: boolean;
        /**
         * Directory timestamp
         */
        directoryTimestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerDirectorySearchItem extends WebClient.GenModels.PartnerDirectoryItem {
        /**
         * Search info
         */
        searchInfo: WebClient.GenModels.PartnerSearchInfo;
        /**
         * Search path in departments
         */
        path: Array<WebClient.GenModels.DepartmentModel>;
    }
}
declare namespace WebClient.GenModels {
    interface PartnerSearchInfo {
        /**
         * Is matched
         */
        matched: boolean;
        /**
         * Matched field name
         */
        matchedFieldName: string;
        /**
         * Matched field value
         */
        matchedFieldValue: string;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentModel {
        /**
         * Department id
         */
        id: string;
        /**
         * Department name
         */
        name: string;
        /**
         * Department full name
         */
        fullName: string;
        /**
         * Department type
         */
        departmentType: WebClient.GenModels.DepartmentType;
    }
}
declare namespace WebClient.GenModels {
    interface MainMenuSettings {
        /**
         * List of main menu settings
         */
        items: Array<WebClient.GenModels.MainMenuItemSetting>;
    }
}
declare namespace WebClient.GenModels {
    interface MainMenuItemSetting {
        /**
         * Main menu item unuque identifier
         */
        id: string;
        /**
         * Is item hidden by user
         */
        hidden: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface CardListRequestModel {
        /**
         * Request model for folder view
         */
        folderViewRequest: WebClient.GenModels.QueryViewRequest;
        /**
         * Search params
         */
        parameters: Array<WebClient.GenModels.SearchParameter>;
        /**
         * Instance id
         */
        instanceId?: string;
        /**
         * Search filter
         */
        searchFilter: string;
        /**
         * Device type
         */
        deviceType: WebClient.GenModels.DeviceType;
    }
}
declare namespace WebClient.GenModels {
    interface SearchParameter {
        /**
         * Gets or sets parameter name
         */
        name: string;
        /**
         * Gets or sets parameter value
         */
        value: string;
        /**
         * Does parameter included in search
         */
        enabled: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface CardListViewModel {
        /**
         * Card list header text
         */
        headerText: string;
        /**
         * Card list parent header text
         */
        parentHeaderText: string;
        /**
         * Current view name
         */
        currentViewName: string;
        /**
         * Default folder view style
         */
        defaultStyle: WebClient.GenModels.DvFolderStyles;
        /**
         * Url for DefaultStyle.FolderURL, when folder displayed as web page.
         */
        folderUrl: string;
        /**
         * Grid model
         */
        gridModel: WebClient.GenModels.GridViewModel;
        searchParametersLayout: WebClient.GenModels.LayoutViewModel;
    }
}
declare namespace WebClient.GenModels {
    interface GridViewModel {
        /**
         * Gets or sets instanceId
         */
        instanceId: string;
        /**
         * Gets or sets size
         */
        pageSize: number;
        /**
         * Gets or sets model size
         */
        modelSize: number;
        /**
         * Gets or sets whether is final model size
         */
        isAllPagesLoaded: boolean;
        /**
         * Gets or sets IsUnknownModelSize
         */
        isUnknownModelSize: boolean;
        /**
         * Gets or sets whether filter allowed
         */
        isFilterAllowed: boolean;
        /**
         * Gets or sets paging mode
         */
        isPagingMode: boolean;
        /**
         * Gets or sets whether last page
         */
        isLastPage: boolean;
        /**
         * Gets or sets whether to highlight unread cards
         */
        markUnread: boolean;
        /**
         * Gets or sets CheckCardAccess
         */
        checkCardAccess: boolean;
        /**
         * Gets or sets whether to allow resize rows
         */
        allowRowResize: boolean;
        /**
         * Gets sorting key
         */
        sortingKey: string;
        /**
         * Gets columns
         */
        columns: Array<WebClient.GenModels.GridColumn>;
        /**
         * Gets values
         */
        rows: Array<WebClient.GenModels.GridRow>;
        /**
         * Gets or sets folder view request used to aquire ViewContext-specific grid settings
         */
        request: WebClient.GenModels.QueryViewRequest;
        /**
         * Current session id.
         */
        sessionId: string;
        /**
         * Gets or sets key column name
         */
        keyColumnName: string;
        /**
         * Get sorting column settings
         */
        sortingColumns: Array<WebClient.GenModels.GridSorting>;
        /**
         * Get grouping column names
         */
        groupingColumnNames: Array<WebClient.GenModels.GridGrouping>;
    }
}
declare namespace WebClient.GenModels {
    interface GridColumn {
        /**
         * Gets or sets display name
         */
        displayName: string;
        /**
         * Gets or sets sorting
         */
        sorting: boolean;
        /**
         * Gets or sets css class name
         */
        cssClassName: string;
        /**
         * Gets or sets column type
         */
        type: WebClient.GenModels.ColumnType;
        /**
         * Gets or sets if column supported in mobile or desktop format
         */
        formFactor?: WebClient.GenModels.FormFactor;
        /**
         * Gets or sets column sort direction
         */
        sortDirection?: System.Web.UI.WebControls.SortDirection;
        /**
         * Gets or set whether column is marked as sort direction
         */
        isDefaultSort: boolean;
        /**
         * Get view column name
         */
        name: string;
        /**
         * Get value indicated whether view column is system column
         */
        isSystemColumn: boolean;
        /**
         * Get value indicated whether view column is hidden in view settings
         */
        isHiddenColumn: boolean;
        /**
         * Gets or sets value indicated whether column is unresizable
         */
        unresizable: boolean;
        /**
         * Gets or sets column width
         */
        width: any;
        /**
         * Gets or sets column order
         */
        order: number;
        /**
         * Eval row function
         */
        evalRow: any;
        /**
         * Eval get grid field data
         */
        getGridFieldData: any;
    }
}
declare namespace WebClient.GenModels {
    interface GridRow {
        /**
         * Get ot sets params
         */
        params: Array<WebClient.GenModels.GridRowParam>;
        /**
         * Gets or sets back color for row
         */
        backColor: string;
        /**
         * Gets or sets back color for row
         */
        foreColor: string;
        /**
         * Gets or sets row was read
         */
        wasRead: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface GridRowParam {
        /**
         * Gets or sets column name
         */
        columnName: string;
        /**
         * Gets or sets value
         */
        value: any;
        /**
         * Gets or sets typed value
         */
        typedValue: any;
        /**
         * Gets or sets raw value
         */
        rawValue: any;
        /**
         * Gets or sets column order
         */
        order: number;
    }
}
declare namespace WebClient.GenModels {
    interface GridSorting {
        /**
         * sorting column name
         */
        columnName: string;
        /**
         * column sorting order
         */
        order: number;
        /**
         * Sorting direction
         */
        ascending: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface GridGrouping {
        /**
         * sorting column name
         */
        columnName: string;
        /**
         * Sorting direction
         */
        ascending: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutViewModel {
        /**
         * Gets or sets a layout model
         */
        layoutModel: WebClient.GenModels.LayoutModel;
    }
}
declare namespace WebClient.GenModels {
    interface ControlModel {
        /**
         * Gets or sets control type name
         */
        controlTypeName: string;
        /**
         * Gets control properties
         */
        properties: {
            [name: string]: any;
        };
        /**
         * Gets control children
         */
        children: Array<WebClient.GenModels.ControlModel>;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutModel extends WebClient.GenModels.ControlModel {
        /**
         * Gets or sets layout info model
         */
        layoutInfo: WebClient.GenModels.LayoutInfoModel;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutInfoModel {
        /**
         * Gets or sets layout type
         */
        type: WebClient.GenModels.LayoutType;
        /**
         * Gets or sets device type
         */
        deviceType: WebClient.GenModels.DeviceType;
        /**
         * Gets or sets locale identifier
         */
        localeId: number;
        /**
         * Gets or sets layout name
         */
        name: string;
        /**
         * Gets or sets layout identifier
         */
        id: string;
        /**
         * Gets operation
         */
        operations: Array<WebClient.GenModels.OperationModel>;
    }
}
declare namespace WebClient.GenModels {
    interface OperationModel {
        /**
         * Gets operation identifier
         */
        id: string;
        /**
         * Gets operation identifier
         */
        builtInId?: string;
        /**
         * Gets operation caption
         */
        caption: string;
        /**
         * Gets value indicating whether operation is available
         */
        available: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface GridFilterRequestModel {
        /**
         * Gets or sets folder identifier
         */
        folderId: string;
        /**
         * Gets or sets view identifier
         */
        viewId: string;
    }
}
declare namespace WebClient.GenModels {
    interface GetRequestModel {
        layoutPositionName: string;
        cardId?: string;
        layoutParams: {
            [name: string]: string;
        };
    }
}
declare namespace WebClient.GenModels {
    interface GetPartRequestModel extends WebClient.GenModels.GetRequestModel {
        controlName: string;
    }
}
declare namespace WebClient.GenModels {
    interface HistorySearchQuery {
        /**
         * Card id
         */
        cardId: string;
        /**
         * Employee name
         */
        employeeName: string;
        /**
         * Date
         */
        date?: string;
        /**
         * Event name
         */
        eventSearch: string;
        /**
         * List of operations ids to hide
         */
        operationsToHide: Array<string>;
        /**
         * Cache id
         */
        cacheId: string;
        /**
         * Count of items to skip (paginator logic)
         */
        skip?: number;
        /**
         * Max items count in the result (paginator logic)
         */
        maxCount?: number;
        /**
         * Edit operation id
         */
        editOperation: string;
    }
}
declare namespace WebClient.GenModels {
    interface HistorySearchResult {
        /**
         * History records
         */
        records: Array<WebClient.GenModels.HistoryRecord>;
        /**
         * Show if result has more records (for pagination)
         */
        hasMore: boolean;
        /**
         * Cache id
         */
        cacheId: string;
        /**
         * Replace (if true) or concat (if false) to existing history records (for pagination).
         */
        renew: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface HistoryRecord {
        /**
         * Record id
         */
        logNewId: string;
        /**
         * Record item id
         */
        id: number;
        /**
         * Record date
         */
        date: string;
        /**
         * Record user-readable event description
         */
        event: string;
        /**
         * Author of history record
         */
        author: WebClient.GenModels.HistoryEmployee;
    }
}
declare namespace WebClient.GenModels {
    interface HistoryEmployee {
        /**
         * Name to display
         */
        displayName: string;
    }
}
declare namespace WebClient.GenModels {
    interface CardKindInfoModel {
        /**
         * Gets or sets card type id
         */
        cardTypeId: string;
        /**
         * Gets or sets kind name
         */
        kindId: string;
        /**
         * Gets or sets kind name
         */
        name: string;
        /**
         * Gets or set value indicated where kind is default
         */
        isDefault: boolean;
        /**
         * Gets or set value indicated where kind is not available
         */
        notAvailable: boolean;
        /**
         * Gets or set value indicated where kind is not allowed to select
         */
        notSelectable: boolean;
        /**
         * Gets or set child kinds
         */
        kinds: Array<WebClient.GenModels.CardKindInfoModel>;
    }
}
declare namespace WebClient.GenModels {
    interface GetTasksListRequestModel {
        /**
         * Id of the task list card.
         */
        taskListId: string;
        /**
         * Filter result by these kinds. If array is empty or null, filter will not be applied.
         */
        availableKinds: Array<string>;
    }
}
declare namespace WebClient.GenModels {
    interface TaskDataModel {
        /**
         * Gets card identifier
         */
        cardId: string;
        /**
         * Gets card type identifier
         */
        cardTypeId: string;
        /**
         * Gets kind identifier
         */
        kindId: string;
        /**
         * Gets task name
         */
        taskName: string;
        /**
         * Gets view route name
         */
        viewRouteName: string;
        /**
         * Gets group task flag
         */
        isGroupTask: boolean;
        /**
         * Gets state name
         */
        stateDisplayName: string;
        /**
         * Gets task state class name
         */
        stateClassName: string;
        /**
         * Gets task state type
         */
        stateType: number;
        /**
         * Gets performer name
         */
        performerDisplayName: string;
        /**
         * Gets start date
         */
        startDate?: string;
        /**
         * Gets end date
         */
        endDate?: string;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementListModel {
        documentNumber: string;
        documentName: string;
        items: Array<WebClient.GenModels.AgreementListItemModel>;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementListItemModel {
        date: string;
        employeeDisplayText: string;
        departmentName: string;
        comment: string;
        decisionText: string;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutAgreementManagementModel {
        /**
         * Gets or sets is create enabled
         */
        enableCreate: boolean;
        /**
         * Gets or sets is create enabled
         */
        isNew: boolean;
        /**
         * Gets agreement card identifier
         */
        agreementCardId: string;
        /**
         * Gets or sets agreement state type
         */
        stateType: WebClient.GenModels.AgreementStateType;
        /**
         * If EnableCreate is false, this property contains message for user, explaining why it is disabled.
         */
        createDisableReason: string;
        /**
         * Timestamp of document card on moment of model loading
         */
        documentTimestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementManagementStartModel {
        agreementManagement: WebClient.GenModels.AgreementManagementModel;
        templates: Array<WebClient.GenModels.AgreementTemplateModel>;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementManagementModel {
        reconciliationCardId: string;
        isMainFileExists: boolean;
        isNew: boolean;
        stateType: WebClient.GenModels.AgreementStateType;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementTemplateModel {
        creationSettingId: string;
        templateId: string;
        name: string;
        stages: Array<WebClient.GenModels.StageModel>;
        startNoFiles: boolean;
        startNoEdit: boolean;
        loaded: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface StageModel {
        stageId: string;
        name: string;
        allowEdit: boolean;
        duration: number;
        specificDuration: boolean;
        approvalType: WebClient.GenModels.ApprovalType;
        hasBusinessProcess: boolean;
        excluded: boolean;
        order: number;
        allowExcludeStage: boolean;
        stageInstanceInfo: WebClient.GenModels.ActualStageData;
        approvers: Array<WebClient.GenModels.ApproverModel>;
        allowEditApprovalType: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface ActualStageData {
        stageSemantics: WebClient.GenModels.StageSemantics;
        currentStage: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface ApproverModel {
        employee: WebClient.GenModels.ApproverEmployeeModel;
        excluded: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface ApproverEmployeeModel {
        id: string;
        isCurrent: boolean;
        displayName: string;
        firstName: string;
        lastName: string;
        middleName: string;
        position: string;
        isFavoritePerformer: boolean;
        unitId: string;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementManagementEditModel {
        agreementManagement: WebClient.GenModels.AgreementManagementModel;
        availableAgreementOperations: Array<WebClient.GenModels.ApprovalOperationKind>;
        stages: Array<WebClient.GenModels.StageModel>;
        canInterruptCurrentStages: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface ReconcilationCreationModel {
        documentId: string;
        creationSettingId: string;
        stages: Array<WebClient.GenModels.StageChangeModel>;
    }
}
declare namespace WebClient.GenModels {
    interface StageChangeModel {
        stageId: string;
        order: number;
        excluded: boolean;
        duration: number;
        specificDuration: boolean;
        approvalType: WebClient.GenModels.ApprovalType;
        approversChanged: boolean;
        approvers: Array<WebClient.GenModels.ApproverModel>;
    }
}
declare namespace WebClient.GenModels {
    interface ReconcilationEditModel {
        documentId: string;
        reconcileCardId: string;
        stages: Array<WebClient.GenModels.StageChangeModel>;
    }
}
declare namespace WebClient.GenModels {
    interface ApprovalHistoryViewModel {
        approvalReconcileCardId: string;
        approvalTaskCardId: string;
        currentCycle: WebClient.GenModels.ApprovalHistoryCycleModel;
        cycles: Array<WebClient.GenModels.ApprovalHistoryCycleModel>;
    }
}
declare namespace WebClient.GenModels {
    interface ApprovalHistoryCycleModel {
        number: number;
        isCurrent: boolean;
        stages: Array<WebClient.GenModels.ApprovalHistoryStageModel>;
        ownerCardId: string;
    }
}
declare namespace WebClient.GenModels {
    interface ApprovalHistoryStageModel {
        name: string;
        approvalType?: WebClient.GenModels.ApprovalType;
        stageItems: Array<WebClient.GenModels.ApprovalHistoryStageItemModel>;
    }
}
declare namespace WebClient.GenModels {
    interface ApprovalHistoryStageItemModel {
        employeeText: string;
        employeeId: string;
        decisionDate: string;
        comment: string;
        hasComment: boolean;
        decisionName: string;
        decision?: WebClient.GenModels.DecisionSemantics;
        stageDecision?: WebClient.GenModels.StageSemantics;
        addedFileCardModels: Array<WebClient.GenModels.ApprovalHistoryFileModel>;
        commentFileData: WebClient.GenModels.ApprovalHistoryFileCommentModel;
    }
}
declare namespace WebClient.GenModels {
    interface ApprovalHistoryFileModel {
        fileCardId: string;
        name: string;
        currentVersion: WebClient.GenModels.ApprovalHistoryFileVersionModel;
    }
}
declare namespace WebClient.GenModels {
    interface ApprovalHistoryFileVersionModel {
        versionId: string;
        fileId: string;
    }
}
declare namespace WebClient.GenModels {
    interface ApprovalHistoryFileCommentModel {
        fileId: string;
        name: string;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutCardCreateParams {
        /**
         * Card type identifier
         */
        cardTypeId?: string;
        /**
         * Kind identifier
         */
        kindId?: string;
        /**
         * Folder identifier
         */
        folderId?: string;
        /**
         * Template identifier
         */
        templateId?: string;
        /**
         * Parent card identifier
         */
        parentCardId?: string;
        /**
         * Create new card as link in another card
         */
        createAsLink: WebClient.GenModels.CreateAsLinkParams;
    }
}
declare namespace WebClient.GenModels {
    interface CreateAsLinkParams {
        /**
         * Source link card
         */
        sourceCardId: string;
        /**
         * Timestamp of the source card
         */
        sourceCardTimestamp: number;
        /**
         * Link kind
         */
        linkTypeId: string;
        /**
         * Where links placed in the card
         */
        linksBinding: WebClient.GenModels.SimpleBindingInfo;
        /**
         * If link is hard link, then removing source card will also remove destination card
         */
        saveHardLink: boolean;
        /**
         * If link is report
         */
        isReport: boolean;
        /**
         * Edit operation
         */
        editOperation: string;
    }
}
declare namespace WebClient.GenModels {
    interface SimpleBindingInfo {
        /**
         * Gets or sets section identifier
         */
        sectionId: string;
        /**
         * Gets or sets field alias
         */
        fieldAlias: string;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutCardViewModel extends WebClient.GenModels.LayoutViewModel {
        /**
         * Gets card info model
         */
        cardInfo: WebClient.GenModels.CardInfoModel;
    }
}
declare namespace WebClient.GenModels {
    interface CardInfoModel {
        /**
         * Gets or sets card id
         */
        id: string;
        /**
         * Gets or sets card type id
         */
        typeId: string;
        /**
         * Gets or sets card kind id
         */
        kindId?: string;
        /**
         * Gets or sets a timestamp of the card.
         */
        timestamp: number;
        /**
         * Create card as link in another card
         */
        createAsLink: WebClient.GenModels.CreateAsLinkParams;
        /**
         * Parent card identifier
         */
        parentCardId?: string;
        /**
         * Folder, that specified in url parameter
         */
        createInFolder?: string;
        /**
         * If true, specified card can't be created in the folder, that specified in url parameter
         */
        createInCurrentFolderForbidden: boolean;
        /**
         * Gets or sets card lock info
         */
        lockInfo: WebClient.GenModels.LockInfoViewModel;
        /**
         * Gets or sets card creation date
         */
        createDate: string;
    }
}
declare namespace WebClient.GenModels {
    interface LockInfoViewModel {
        /**
         * Gets or sets whether card a locked
         */
        isLocked: boolean;
        /**
         * Gets or sets locking user account name
         */
        accountName: string;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutPartParams {
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets layout type
         */
        layoutType: WebClient.GenModels.LayoutType;
        /**
         * Get or sets root control name
         */
        rootControlName: string;
        /**
         * Get or set include root
         */
        includeRootControl: boolean;
        /**
         * Data passed from caller
         */
        contextData: {
            [name: string]: any;
        };
    }
}
declare namespace WebClient.GenModels {
    interface SaveControlDataModel {
        /**
         * Gets or sets a card id
         */
        cardId: string;
        /**
         * Gets or sets a card timestamp
         */
        timestamp: number;
        /**
         * Gets or sets layout type
         */
        layoutType: WebClient.GenModels.LayoutType;
        /**
         * Gets or sets control data
         */
        bindings: Array<WebClient.GenModels.BindingsWriteRequest>;
        /**
         * Create card as link in another card
         */
        createAsLink: WebClient.GenModels.CreateAsLinkParams;
        /**
         * Folder, where card should be placed
         */
        createInFolder: string;
        /**
         * Gets or sets a parent card id (actual for tasks)
         */
        parentCardId?: string;
        /**
         * Gets or sets a card type id
         */
        cardTypeId: string;
    }
}
declare namespace WebClient.GenModels {
    interface BindingsWriteRequest {
        /**
         * Gets or sets control name
         */
        controlName: string;
        /**
         * Gets or sets control type name
         */
        controlTypeName: string;
        /**
         * Gets control bindings results
         */
        bindingResults: Array<WebClient.GenModels.BindingResult>;
    }
}
declare namespace WebClient.GenModels {
    interface BindingResult {
        /**
         * Gets or sets binding property name
         */
        name: string;
        /**
         * Extra information about binding itself.
         */
        metadata: Array<WebClient.GenModels.BindingMetadata>;
        /**
         * Gets items collection
         */
        values: Array<string>;
        /**
         * Binding value
         */
        value: any;
        /**
         * Gets or sets edit operation
         */
        editOperation: string;
    }
}
declare namespace WebClient.GenModels {
    interface BindingMetadata {
        /**
         * Metadata key
         */
        key: string;
        /**
         * Metadata value
         */
        value: string;
    }
}
declare namespace WebClient.GenModels {
    interface ChangeStateDataModel {
        /**
         * Gets or sets card identifier
         */
        cardId: string;
        /**
         * Gets or sets operation identifier
         */
        operationId: string;
        /**
         * Gets or sets layout type
         */
        layoutType: WebClient.GenModels.LayoutType;
        /**
         * Gets or sets change state comment
         */
        comment: string;
    }
}
declare namespace WebClient.GenModels {
    interface DirectoryDesignerSearchQuery {
        /**
         * search string
         */
        searchText: string;
        /**
         * Data source
         */
        searchArea?: WebClient.GenModels.DirectoryDesignerSearchArea;
        /**
         * Department types to search
         */
        rootNodeId?: string;
    }
}
declare namespace WebClient.GenModels {
    interface DirectoryDesignerSearchResult {
        /**
         * List of directory designer row items
         */
        items: Array<WebClient.GenModels.DirectoryDesignerRowModel>;
        /**
         * If there are more items (for pagination)
         */
        hasMore: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface DirectoryDesignerRowModel {
        /**
         * Row id
         */
        id: string;
        /**
         * Row name
         */
        name: string;
        /**
         * Row description
         */
        description: string;
    }
}
declare namespace WebClient.GenModels {
    interface DirectoryDesignerLoadTreeQuery {
        /**
         * Department types to search
         */
        rootNodeId?: string;
        /**
         * Data source
         */
        searchArea?: WebClient.GenModels.DirectoryDesignerSearchArea;
        /**
         * current node id
         */
        currentNodeId?: string;
    }
}
declare namespace WebClient.GenModels {
    interface DirectoryDesignerTreeNode {
        /**
         * Node id
         */
        id: string;
        /**
         * Node name
         */
        name: string;
        /**
         * Node type
         */
        nodeType: WebClient.GenModels.DirectoryDesignerTreeNodeType;
        /**
         * Was children autoloaded or not
         */
        childrenLoaded: boolean;
        /**
         * Children tree node
         */
        children: Array<WebClient.GenModels.DirectoryDesignerTreeNode>;
    }
}
declare namespace WebClient.GenModels {
    interface DirectoryDesignerSearchTreeQuery {
        /**
         * Data source
         */
        searchArea?: WebClient.GenModels.DirectoryDesignerSearchArea;
        /**
         * Department types to search
         */
        rootNodeId?: string;
        /**
         * Search string
         */
        searchQuery: string;
        /**
         * Search result number
         */
        searchResultNumber: number;
        /**
         * Search mode
         */
        searchMode?: WebClient.GenModels.DirectoryDesignerSearchMode;
    }
}
declare namespace WebClient.GenModels {
    interface DirectoryDesignerSearchTreeResult {
        /**
         * Search results items data
         */
        items: Array<WebClient.GenModels.DirectoryDesignerTreeNode>;
        /**
         * Total search results count
         */
        totalResultsCount: number;
        /**
         * Search result number
         */
        searchResultNumber: number;
        /**
         * Matched element id
         */
        matchedElementId: string;
        /**
         * Matched element field name
         */
        matchedFieldName: string;
        /**
         * Matched element field value
         */
        matchedFieldValue: string;
    }
}
declare namespace WebClient.GenModels {
    interface GenerateNumberRequest {
        /**
         * Document card id
         */
        cardId: string;
        /**
         * Save the number to card or not
         */
        save: boolean;
        /**
         * Section and field, where number id stored in the card
         */
        info: WebClient.GenModels.BindingInfo;
        /**
         * Id of the rule, that should be used to generate number
         */
        generationRuleId?: string;
    }
}
declare namespace WebClient.GenModels {
    interface BindingInfo {
        /**
         * Bound field alias in database
         */
        fieldAlias: string;
        /**
         * Bound section id
         */
        sectionId: string;
        /**
         * Gets or sets property name
         */
        propertyName: string;
        /**
         * Gets or sets edit operation
         */
        editOperation: string;
    }
}
declare namespace WebClient.GenModels {
    interface NumberInfo {
        /**
         * Gets or sets number
         */
        number: string;
        /**
         * Gets or sets numerator card busy numbers row identifier
         */
        id: string;
    }
}
declare namespace WebClient.GenModels {
    interface ReleaseNumberRequest {
        /**
         * Card id
         */
        cardId: string;
        /**
         * Section and field, where number id stored in the card
         */
        info: WebClient.GenModels.BindingInfo;
        /**
         * Document number identifier
         */
        numberId: string;
    }
}
declare namespace WebClient.GenModels {
    interface SendForAcquaintanceRequest {
        /**
         * Card id
         */
        cardId: string;
        /**
         * Employees that should acquaintance document
         */
        employeeIds: Array<string>;
        /**
         * Acquaintance end date
         */
        endDate?: string;
    }
}
declare namespace WebClient.GenControllers {
    interface FileUploadApiController {
    }
}
declare namespace WebClient.GenModels {
    interface GetFilesRequest {
        /**
         * Card id
         */
        cardId: string;
        /**
         * Query options
         */
        options: WebClient.GenModels.GetFilesQueryOptions;
    }
}
declare namespace WebClient.GenModels {
    interface GetFilesQueryOptions {
        /**
         * Count of items to skip
         */
        skipCount: number;
        /**
         * Max items count in the result
         */
        maxCount?: number;
    }
}
declare namespace WebClient.GenModels {
    interface FileListDataModelBase {
        /**
         * New timestamp of the card
         */
        timestamp: number;
        /**
         * Updated list of the files in the card
         */
        files: Array<WebClient.GenModels.LayoutFileModel>;
        /**
         * Gets wther document has any signature
         */
        hasAnySignature: boolean;
        /**
         * Total count of files
         */
        totalCount: number;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutFileModel {
        /**
         * File name with extension
         */
        name: string;
        /**
         * File card ID
         */
        fileCardId: string;
        /**
         * File ID
         */
        fileId: string;
        /**
         * Is file locked
         */
        isLocked: boolean;
        /**
         * Is file preview supported
         */
        isFilePreviewSupported: boolean;
        /**
         * Previous versions of the file
         */
        childVersions: Array<WebClient.GenModels.VersionedFileModel>;
        /**
         * Current version of the file
         */
        currentVersion: WebClient.GenModels.VersionedFileModel;
        /**
         * Has file digital signature or not
         */
        hasFileSignature: boolean;
        /**
         * Is file main or additional
         */
        isMain: boolean;
        /**
         * Link for open file via WebDav
         */
        webDavLink: string;
        /**
         * Link for open file via WebDav in readonly mode
         */
        webDavReadonlyLink: string;
        /**
         * File versions count
         */
        versionsCount: number;
    }
}
declare namespace WebClient.GenModels {
    interface VersionedFileModel {
        /**
         * Gets or sets file identifier
         */
        id: string;
        /**
         * Gets or set version id
         */
        versionId: string;
        /**
         * Gets or set version path
         */
        versionPath: string;
        /**
         * Gets or set version number
         */
        versionNumber: number;
        /**
         * Gets or set version author
         */
        author: string;
        /**
         * Gets or sets creation date
         */
        creationDate: string;
        /**
         * Gets or sets file version comments
         */
        comments: Array<WebClient.GenModels.VersionedFileCommentModel>;
    }
}
declare namespace WebClient.GenModels {
    interface VersionedFileCommentModel {
        /**
         * Gets or sets identifier
         */
        id: string;
        /**
         * Gets or sets date
         */
        date: string;
        /**
         * Gets or sets comment
         */
        comment: string;
        /**
         * Gets or sets author
         */
        author: string;
        /**
         * Gets or sets author
         */
        authorId: string;
    }
}
declare namespace WebClient.GenModels {
    interface GetVersionsRequest {
        /**
         * Card id
         */
        cardId: string;
    }
}
declare namespace WebClient.GenModels {
    interface FileListVersionsDataModel {
        /**
         * Updated list of the files versions in the card
         */
        versions: Array<WebClient.GenModels.VersionedFileModel>;
    }
}
declare namespace WebClient.GenModels {
    interface GetCommentsRequest {
        /**
         * File card id
         */
        fileCardId: string;
        /**
         * Version id
         */
        versionId: string;
    }
}
declare namespace WebClient.GenModels {
    interface VersionedFileCommentListModel {
        /**
         * Gets or sets file versin comments
         */
        comments: Array<WebClient.GenModels.VersionedFileCommentModel>;
        /**
         * Gets or sets file name
         */
        fileName: string;
        /**
         * Gets or sets file author name
         */
        fileAuthor: string;
        /**
         * Gets or sets file author id
         */
        fileAuthorId: string;
        /**
         * Gets or sets file creation date
         */
        fileCreationDate: string;
        /**
         * Gets or sets version
         */
        version: string;
        /**
         * Get version id
         */
        versionId: string;
        /**
         * Get current user
         */
        currentEmployee: string;
        /**
         * Gets or sets Id of current employee
         */
        currentEmployeeId: string;
        /**
         * Gets or sets file card identifier
         */
        fileCardId: string;
        /**
         * Gets or sets file card timestamp
         */
        timestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface VersionedFileCommentCreateModel {
        /**
         * Gets or sets comment identifier
         */
        commentId?: string;
        /**
         * Gets or sets container card identifier
         */
        cardId: string;
        /**
         * Gets or sets timestamp
         */
        timestamp: number;
        /**
         * Gets or sests comment
         */
        comment: string;
        /**
         * Gets or sets file card identifier
         */
        fileCardId: string;
        /**
         * Gets or sets version identifier
         */
        versionId: string;
    }
}
declare namespace WebClient.GenModels {
    interface VersionedFileCommentDeleteModel {
        /**
         * Gets or sets comment identifier
         */
        commentId: string;
        /**
         * Gets or sets container card identifier
         */
        cardId: string;
        /**
         * Gets or sets timestamp
         */
        timestamp: number;
        /**
         * Gets or sets file card identifier
         */
        fileCardId: string;
        /**
         * Gets or sets version identifier
         */
        versionId: string;
    }
}
declare namespace WebClient.GenModels {
    interface CommmonFileRequest {
        /**
         * Owner card id
         */
        ownerCardId: string;
        /**
         * File card id
         */
        fileCardId: string;
        /**
         * Timestamp
         */
        timestamp?: number;
    }
}
declare namespace WebClient.GenModels {
    interface FileListDataModel extends WebClient.GenModels.FileListDataModelBase {
    }
}
declare namespace WebClient.GenModels {
    interface GetUserFoldersTreeDataRequest {
        /**
         * Folder id. If value provided, action will return subfolders for specified folder.
         */
        folderId?: string;
    }
}
declare namespace WebClient.GenModels {
    interface FolderNode {
        /**
         * Gets or sets folder identifier
         */
        id: string;
        /**
         * Equalent to Id
         */
        additionalId: string;
        /**
         * Gets or sets folder name
         */
        name: string;
        /**
         * Gets or sets folder node type
         */
        type: WebClient.GenModels.FolderNodeType;
        /**
         * Default folder view style
         */
        defaultStyle: WebClient.GenModels.FolderNodeStyle;
        /**
         * Gets value indicating whether node has unloaded subfolders
         */
        hasUnloadedSubfolders: boolean;
        /**
         * Get or sets folder URL, when folder displayed as web page
         */
        url: string;
        /**
         * Gets or sets default view identifier
         */
        defaultViewId: string;
        /**
         * Gets or sets search identifier for virtual folder
         */
        searchId: string;
        /**
         * Gets or sets target folder identifier for delegate folder
         */
        targetFolderId: string;
        /**
         * Folder setting - seconds to auto refresh. Zero value inidicates, that autorefresh disabled.
         */
        refreshTimeout: number;
        /**
         * Folder setting - show unread counter
         */
        showUnreadCounter: boolean;
        /**
         * Folder setting
         */
        pagedSecurity: boolean;
        /**
         * Gets or sets subfolders
         */
        folders: Array<WebClient.GenModels.FolderNode>;
    }
}
declare namespace WebClient.GenModels {
    interface CheckFolderForAvailableCardKindRequest {
        /**
         * Folder id, where card going to be placed
         */
        folderId: string;
        /**
         * Card id to check
         */
        cardId: string;
    }
}
declare namespace WebClient.GenModels {
    interface CheckResult {
        /**
         * Was check passed or not
         */
        passed: boolean;
        /**
         * If Passed is false, this property should contain reason, why check is failed.
         */
        failReason: string;
    }
}
declare namespace WebClient.GenModels {
    interface GetFolderInfoRequest {
        /**
         * Folder id
         */
        folderId: string;
        /**
         * How many levels of subfolders to return with model
         */
        loadSubfoldersLevel?: number;
    }
}
declare namespace WebClient.GenModels {
    interface GetFolderInfoWithParentsRequest {
        /**
         * Folder id
         */
        folderId: string;
    }
}
declare namespace WebClient.GenModels {
    interface FolderNodeWithParents {
        /**
         * List of parent nodes ids (path)
         */
        parentNodes: Array<string>;
        /**
         * Folder node
         */
        folderNode: WebClient.GenModels.FolderNode;
    }
}
declare namespace WebClient.GenModels {
    interface DetachUserFoldersRequest {
        /**
         * Folders ids to detach
         */
        folderIds: Array<string>;
    }
}
declare namespace WebClient.GenModels {
    interface DeleteLinkRequest {
        /**
         * Card id
         */
        cardId: string;
        /**
         * Simple binding info
         */
        info: WebClient.GenModels.SimpleBindingInfo;
        /**
         * Link id
         */
        linkId: string;
        /**
         * Card timestamp
         */
        timestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface LinksDataModel {
        /**
         * Updated list of the main files in the card
         */
        links: Array<WebClient.GenModels.LayoutLinkModel>;
        bindingInfo: WebClient.GenModels.SimpleBindingInfo;
        /**
         * Allowed card types, that can be added as links (for add existing card).
         */
        allowedLinkCardTypes: Array<string>;
        /**
         * Do model contains links or not
         */
        linksLoaded: boolean;
        /**
         * Total count of the links, including not loaded
         */
        totalLinksCount: number;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutLinkModel {
        /**
         * Gets or sets link id
         */
        linkId: string;
        /**
         * Gets or sets display link name
         */
        displayName: string;
        /**
         * Gets or sets link type name
         */
        linkTypeName: string;
        /**
         * link kind
         */
        kind: WebClient.GenModels.LinkKind;
        /**
         * Linked card Type is document
         */
        isDocument: boolean;
        /**
         * Linked card id
         */
        cardId: string;
        /**
         * Gets or sets Link creation date
         */
        creationDate?: string;
        /**
         * Display name of the author of the link.
         */
        authorDisplayName: string;
        /**
         * Link description
         */
        description: string;
        /**
         * Url
         */
        url: string;
    }
}
declare namespace WebClient.GenModels {
    interface LinkType {
        /**
         * Link type id
         */
        linkTypeId: string;
        /**
         * link type display name
         */
        displayName: string;
    }
}
declare namespace WebClient.GenModels {
    interface AllowedCardKind {
        /**
         * Kind id of the allowed card
         */
        kindId: string;
        /**
         * Gets or sets value whether kind selected with descendants
         */
        withDescendants: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutKindModel {
        /**
         * Card type id
         */
        cardTypeId: string;
        /**
         * Kind id of the allowed card
         */
        kindId: string;
        /**
         * Gets or sets kind name
         */
        name: string;
        /**
         * Gets or set child kinds
         */
        kinds: Array<WebClient.GenModels.LayoutKindModel>;
        /**
         * Card creation is not available
         */
        notAvailable: boolean;
        /**
         * Whether custom layout available for this card kind or not
         */
        layoutAvailable: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutLinkCreateParams {
        /**
         * Card, where link creation was initiated
         */
        sourceCardId: string;
        /**
         * Timestamp of the source card
         */
        sourceCardTimestamp: number;
        /**
         * Link kind
         */
        linkTypeId: string;
        /**
         * Link destination card
         */
        destinationCardId: string;
        /**
         * Where links placed in the card
         */
        linksBinding: WebClient.GenModels.SimpleBindingInfo;
        /**
         * If link is hard link, then removing source card will also remove destination card
         */
        saveHardLink: boolean;
        /**
         * If link is report
         */
        isReport: boolean;
        /**
         * If link is attached file
         */
        isFile: boolean;
        /**
         * Edit operation
         */
        editOperation: string;
    }
}
declare namespace WebClient.GenModels {
    interface AddUrlLinkParams {
        /**
         * Card, that contains the link
         */
        cardId: string;
        /**
         * Binding info for the links in the card
         */
        bindingInfo: WebClient.GenModels.SimpleBindingInfo;
        /**
         * Url
         */
        url: string;
        /**
         * link type id
         */
        linkTypeId?: string;
        /**
         * Known card timestamp
         */
        timestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutSetLinkDescriptionParams {
        /**
         * Card, that contains the link
         */
        cardId: string;
        /**
         * Binding info for the links in the card
         */
        bindingInfo: WebClient.GenModels.SimpleBindingInfo;
        /**
         * Link id to update
         */
        linkId: string;
        /**
         * Description to set
         */
        newDescription: string;
        /**
         * Known card timestamp
         */
        timestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface GetLinksRequest {
        /**
         * Card id
         */
        cardId: string;
        /**
         * Binding info
         */
        bindingInfo: WebClient.GenModels.SimpleBindingInfo;
    }
}
declare namespace WebClient.GenModels {
    interface CheckReadMainFileAvailableRequest {
        /**
         * Card id
         */
        cardId: string;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentSearchQuery {
        /**
         * search string
         */
        searchText: string;
        /**
         * Data source
         */
        source: WebClient.GenModels.DepartmentDataSource;
        /**
         * Department types to search
         */
        itemTypes: WebClient.GenModels.SearchDepartmentType;
        /**
         * Count of items to skip (paginator logic)
         */
        skipCount?: number;
        /**
         * Max items count in the result (paginator logic)
         */
        maxCount?: number;
    }
}
declare namespace WebClient.GenModels {
    interface FindDepartmentsResponse {
        /**
         * List of department items
         */
        items: Array<WebClient.GenModels.DepartmentModel>;
        /**
         * If there are more items (for pagination)
         */
        hasMore: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentLoadTreeQuery {
        /**
         * Parent department identifier
         */
        parentNodeId?: string;
        /**
         * depth of search
         */
        treeLevelDown: number;
        /**
         * Data source
         */
        source: WebClient.GenModels.DepartmentDataSource;
        /**
         * Department types to search
         */
        itemTypes: WebClient.GenModels.SearchDepartmentType;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentTreeNode {
        /**
         * Node Id
         */
        id: string;
        /**
         * Node name
         */
        name: string;
        /**
         * Node full name
         */
        fullName: string;
        /**
         * Node department type
         */
        departmentType: WebClient.GenModels.DepartmentType;
        /**
         * Shows if all children were loaded (for pagination)
         */
        childrenLoaded: boolean;
        /**
         * Shows if node has children
         */
        hasChildren: boolean;
        /**
         * Shows if node has employee
         */
        hasEmployee?: boolean;
        /**
         * Node children (can keep only part of children for pagination)
         */
        children: Array<WebClient.GenModels.DepartmentTreeNode>;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentFindInTreeQuery {
        /**
         * search string
         */
        searchQuery: string;
        /**
         * Data source
         */
        source: WebClient.GenModels.DepartmentDataSource;
        /**
         * Department types to search
         */
        itemTypes: WebClient.GenModels.SearchDepartmentType;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentFindInTreeResult {
        /**
         * Found items
         */
        items: Array<WebClient.GenModels.DepartmentTreeSearchResultNode>;
        /**
         * Total results count
         */
        totalResultsCount: number;
        /**
         * Search result number
         */
        searchResultNumber: number;
        /**
         * Matched field name
         */
        matchedFieldName: string;
        /**
         * Matched field value
         */
        matchedFieldValue: string;
        /**
         * Matched element id
         */
        matchedElementId: string;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentTreeSearchResultNode extends WebClient.GenModels.DepartmentTreeNode {
        matched: boolean;
        /**
         * Name of the field in the element, that matched search query. if this field is not Name (otherwise null).
         */
        matchedFieldName: string;
        /**
         * Value of the matchedFieldName, if this field is not Name (otherwise null).
         */
        matchedFieldValue: string;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentExtendedModel extends WebClient.GenModels.DepartmentModel {
        /**
         * Department email
         */
        email: string;
        /**
         * Department phone
         */
        phone: string;
    }
}
declare namespace WebClient.GenModels {
    interface StaffInfoRequestModel {
        /**
         * Employee id list to get info
         */
        employeeIds: Array<string>;
        /**
         * Department and organisation ids to get info
         */
        departmentIds: Array<string>;
        /**
         * Where to look for employees and departments
         */
        source: WebClient.GenModels.DepartmentDataSource;
    }
}
declare namespace WebClient.GenModels {
    interface StaffInfoResponseModel {
        /**
         * Employee id list to get info
         */
        employeesInfo: Array<WebClient.GenModels.EmployeeModelWithPoneAndEmail>;
        /**
         * Department and organisation ids to get info
         */
        departmentsInfo: Array<WebClient.GenModels.DepartmentExtendedModel>;
    }
}
declare namespace WebClient.GenModels {
    interface EmployeeModel {
        /**
         * Unique identificator of employee
         */
        id: string;
        /**
         * Define if user is current
         */
        isCurrent: boolean;
        /**
         * Employee account name
         */
        accountName: string;
        /**
         * Employee display name
         */
        displayName: string;
        /**
         * Employee first name
         */
        firstName: string;
        /**
         * Employee last name
         */
        lastName: string;
        /**
         * Employee middle name
         */
        middleName: string;
        /**
         * Employee position
         */
        position: string;
        /**
         * Gets or sets security identifier
         */
        sdid?: string;
        /**
         * Represents value indicating whether employee is favourite performer
         */
        isFavoritePerformer: boolean;
        /**
         * Gets or sets unit identifier
         */
        unitId: string;
    }
}
declare namespace WebClient.GenModels {
    interface EmployeeModelWithPoneAndEmail extends WebClient.GenModels.EmployeeModel {
        /**
         * Employee phone
         */
        phone: string;
        /**
         * Employee email
         */
        email: string;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentLoadFlatQuery {
        /**
         * Parent department identifier
         */
        departmentId?: string;
        /**
         * Data source
         */
        source: WebClient.GenModels.DepartmentDataSource;
        /**
         * Department types to search
         */
        itemTypes: WebClient.GenModels.SearchDepartmentType;
        /**
         * Skip n departments from begin (pagination)
         */
        skip: number;
        /**
         * Max departments count in response (pagination)
         */
        maxCount: number;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentLoadFlatResponse {
        /**
         * List of department items
         */
        items: Array<WebClient.GenModels.DepartmentFlatDigest>;
        /**
         * Total items count
         */
        totalItemsCount: number;
        /**
         * Directory timestamp
         */
        directoryTimestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentFlatDigest {
        /**
         * Department tree node data
         */
        data: WebClient.GenModels.DepartmentTreeNode;
        /**
         * True if department tree node data has any children, and false otherwise
         */
        hasChildren?: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentSearchFlatQuery {
        /**
         * Data source
         */
        source: WebClient.GenModels.DepartmentDataSource;
        /**
         * item types
         */
        itemTypes: WebClient.GenModels.SearchDepartmentType;
        /**
         * Text to search
         */
        searchText: string;
        /**
         * Department id
         */
        departmentId?: string;
        /**
         * Count of items to skip (paginator logic)
         */
        skip?: number;
        /**
         * Max items count in the result (paginator logic)
         */
        maxCount?: number;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentSearchFlatResponse {
        /**
         * Department's search items
         */
        items: Array<WebClient.GenModels.DepartmentSearchFlatItem>;
        /**
         * Has more items
         */
        hasMore: boolean;
        /**
         * Directory timestamp
         */
        directoryTimestamp: number;
    }
}
declare namespace WebClient.GenModels {
    interface DepartmentSearchFlatItem extends WebClient.GenModels.DepartmentFlatDigest {
        /**
         * Partner search info
         */
        searchInfo: WebClient.GenModels.PartnerSearchInfo;
        /**
         * Path to search in
         */
        path: Array<WebClient.GenModels.DepartmentModel>;
    }
}
declare namespace WebClient.GenModels {
    interface GetParentDepartmentsRequest {
        departmentId: string;
        /**
         * Staff or partner department
         */
        source: WebClient.GenModels.DepartmentDataSource;
    }
}
declare namespace WebClient.GenModels {
    interface FindEmployeesRequest {
        /**
         * Search term
         */
        term: string;
        /**
         * Some unique id, describing place in UI, where value selection performed
         */
        kindId?: string;
        /**
         * How many records request should return
         */
        maxCount?: number;
        /**
         * How many records client already has from previous requests
         */
        skip?: number;
        /**
         * Resticts results to specified unit when is not null.
         */
        unitId?: string;
        /**
         * List of id of employees, that should be filtered from result list.
         */
        skipEmployees: Array<string>;
    }
}
declare namespace WebClient.GenModels {
    interface FindEmployeesResponse {
        /**
         * Search result
         */
        employees: Array<WebClient.GenModels.EmployeeModel>;
        /**
         * Pagination logic
         */
        hasMore: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface AddCardModalModel {
        /**
         * Links for creation of available cards
         */
        createLinks: Array<WebClient.GenModels.AddCardModalModelLink>;
    }
}
declare namespace WebClient.GenModels {
    interface CardCreateLink {
        /**
         * Gets associated cardType
         */
        cardType: WebClient.GenModels.CardTypeWeb;
        /**
         * Gets or sets KindId
         */
        kindId?: string;
        /**
         * Gets or sets ShowMoreEnabled
         */
        showMoreEnabled: boolean;
        /**
         * Gets or sets KindName
         */
        kindName: string;
    }
}
declare namespace WebClient.GenModels {
    interface CardTypeWeb {
        /**
         * Gets card create route
         */
        route: string;
        /**
         * Get value where indicate card wild save in selected folder
         */
        saveInFolder: boolean;
        /**
         * Get value where indicate card color
         */
        cssClass: string;
        /**
         * Gets card create route
         */
        cardTypeId: string;
        /**
         * Gets display name
         */
        displayName: string;
    }
}
declare namespace WebClient.GenModels {
    interface AddCardModalModelLink extends WebClient.GenModels.CardCreateLink {
        /**
         * Card type
         */
        cardType: WebClient.GenModels.CardTypeWeb;
        /**
         * Layout available
         */
        layoutAvailable: boolean;
        /**
         * Route
         */
        route: string;
        /**
         * Color CSS class name
         */
        colorCssClassName: string;
        /**
         * Default kind
         */
        defaultKind: string;
        /**
         * Save in folder
         */
        saveInFolder: string;
    }
}
declare namespace WebClient.GenModels {
    interface CardNodeInfo {
        kindId: string;
        cardTypeId: string;
        caption: string;
        withDescendants: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementHistoryDataModel {
        /**
         * Gets or sets if history exists
         */
        historyExists: boolean;
        /**
         * Gets agreement card identifier
         */
        agreementCardId: string;
    }
}
declare namespace WebClient.GenModels {
    interface AgreementManagementButtonModel {
        agreementManagementOperation: WebClient.GenModels.AgreementManagementOperations;
        displayName: string;
    }
}
declare namespace WebClient.GenModels {
    interface CardLinkDataModel {
        /**
         * ID карточки, на которую установлена ссылка.
         */
        cardId: string;
        /**
         * Значение Digest карточки. Данный текст будет отображен в качестве текста ссылки.
         */
        cardDigest: string;
        /**
         * Доступен ли текущему пользователю просмотр указанной карточки.
         * Данное свойство будет использовано для отключения ссылки и пунктов меню "Открыть" в контроле.
         */
        cardViewAllowed: boolean;
        /**
         * Доступен ли текущему пользователю чтение основного файла указанной карточки.
         * Данное свойство будет использовано для отключения пункта меню "Просмотреть файл" в контроле.
         */
        mainFileReadAllowed: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface CreateKindDataModel {
        /**
         * Gets create route name
         */
        createRouteName: string;
        /**
         * Gets identifier
         */
        id: string;
        /**
         * Gets card type identifier
         */
        cardTypeId: string;
        /**
         * Gets display name
         */
        displayName: string;
        /**
         * Gets is template
         */
        isTemplate: boolean;
        /**
         * Do layouts available for the card
         */
        layoutAvailable: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface EmployeeDataModel {
        /**
         * Unique identificator of employee
         */
        id?: string;
        /**
         * Define if user is current
         */
        isCurrent: boolean;
        /**
         * Employee display name
         */
        displayName: string;
        /**
         * Employee first name
         */
        firstName: string;
        /**
         * Employee last name
         */
        lastName: string;
        /**
         * Employee middle name
         */
        middleName: string;
        /**
         * Employee position
         */
        position: string;
        /**
         * Section and field name
         */
        fieldPath: string;
        /**
         * Path in directory
         */
        pathInDirectory: Array<WebClient.GenModels.DepartmentExtendedModel>;
    }
}
declare namespace WebClient.GenModels {
    interface CommonFileModel {
        /**
         * File name
         */
        fileName: string;
        /**
         * File id
         */
        fileId: string;
        /**
         * Link to open file with webdav
         */
        webDavLink: string;
        /**
         * Link to open file with webdav readonly
         */
        webDavReadonlyLink: string;
        /**
         * Does file preview available for this file extension
         */
        filePreviewAvailable: boolean;
        /**
         * Does file locked by someone
         */
        isLocked: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutTableBindingModel {
        /**
         * Section id
         */
        sectionId: string;
        /**
         * How many first rows was skipped on rows loading
         */
        skippedCount: number;
        /**
         * Do section contains more rows at the end of the table (after loaded rows)
         */
        hasMore: boolean;
        /**
         * Rows loaded from the server
         */
        loadedRows: Array<string>;
        /**
         * Rows added on the client
         */
        addedRows: Array<string>;
        /**
         * Rows deleted on the client
         */
        deletedRows: Array<string>;
    }
}
declare namespace WebClient.GenModels {
    interface LayoutTableColumnInfo {
        /**
         * Column name
         */
        header: string;
        /**
         * Width
         */
        columnWidth: string;
        /**
         * Tooltip
         */
        tip: string;
        /**
         * Is column visible or not
         */
        visibility: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface MultipleEmployeesDataModel {
        /**
         * Gets or sets employees
         */
        employees: Array<WebClient.GenModels.EmployeeDataModel>;
        /**
         * Gets or sets field path
         */
        fieldPath: string;
    }
}
declare namespace WebClient.GenModels {
    interface OperationDataModel {
        /**
         * Gets or sets operation id
         */
        operationId: string;
        /**
         * Gets or sets display name
         */
        displayName: string;
        /**
         * Gets or sets tooltip
         */
        tooltip: string;
    }
}
declare namespace WebClient.GenModels {
    interface ElementsDataModel {
        /**
         * Available variants to select
         */
        elements: Array<WebClient.GenModels.Element>;
        /**
         * Is empty key allowed
         */
        isEmptyKeyAllowed: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface Element {
        /**
         * Unique key
         */
        key: string;
        /**
         * Element value
         */
        value: string;
        /**
         * Element value code
         */
        valueCode: number;
    }
}
declare namespace WebClient.GenModels {
    interface TasksDataModel {
        /**
         * Updated list of the main files in the card
         */
        tasks: Array<WebClient.GenModels.TaskDataModel>;
        /**
         * Do model contains links or not
         */
        tasksLoaded: boolean;
        /**
         * Task id
         */
        taskID: string;
        /**
         * TaskList ID
         */
        taskListId: string;
        /**
         * Available kinds
         */
        availableKinds: Array<string>;
        /**
         * Total count of tasks, including not loaded
         */
        totalTasksCount: number;
    }
}
declare namespace WebClient.GenModels {
    interface DelegationRecord {
        /**
         * Gets or sets previous performer display name
         */
        fromPerformer: string;
        /**
         * Gets or sets new performer display name
         */
        toPerformer: string;
    }
}
declare namespace WebClient.GenModels {
    interface CardTreeNodeModel extends WebClient.GenModels.TreeNodeModel {
        /**
         * Gets or sets card name
         */
        name: string;
    }
}
declare namespace WebClient.GenModels {
    interface TaskCurrentPerformer {
        /**
         * Gets or sets display name
         */
        displayName: string;
        /**
         * Gets or sets employee model
         */
        employeeModel: WebClient.GenModels.EmployeeModel;
    }
}
declare namespace WebClient.GenModels {
    interface TaskGroupSelectedPerformer {
        /**
         * Gets or sets display name
         */
        displayName: string;
        /**
         * Gets or sets value indicating whther performer is responsible
         */
        isResponsiblePerformer: boolean;
        /**
         * Gets or sets employee model
         */
        employeeModel: WebClient.GenModels.EmployeeModel;
    }
}
declare namespace WebClient.GenModels {
    interface TaskGroupTreeNodeHelpModel extends WebClient.GenModels.TreeNodeHelpModel {
        /**
         * Gets or sets execution type
         */
        executionType: WebClient.GenModels.ExecutionType;
        /**
         * Gets or sets author
         */
        author: WebClient.GenModels.EmployeeModel;
        /**
         * Gets selected performers
         */
        selectedPerformers: Array<WebClient.GenModels.TaskGroupSelectedPerformer>;
        /**
         * Gets or sets task name
         */
        name: string;
        /**
         * Gets or sets task content
         */
        content: string;
        /**
         * Gets or sets task end date
         */
        endDate?: string;
        /**
         * Gets or sets controller
         */
        controller: WebClient.GenModels.EmployeeModel;
        /**
         * Gets or sets task control date
         */
        controlDate?: string;
    }
}
declare namespace WebClient.GenModels {
    interface TaskGroupTreeNodeHintModel extends WebClient.GenModels.TreeNodeHintModel {
        /**
         * Gets or sets task group name
         */
        name: string;
        /**
         * Gets or sets task group end date
         */
        endDate?: string;
        /**
         * Gets or sets execution type
         */
        executionType: WebClient.GenModels.ExecutionType;
        /**
         * Gets state name
         */
        stateDisplayName: string;
        /**
         * Gets task state class name
         */
        stateClassName: string;
        /**
         * Gets task state type
         */
        stateType: number;
        /**
         * Gets selected performers
         */
        selectedPerformers: Array<WebClient.GenModels.TaskGroupSelectedPerformer>;
    }
}
declare namespace WebClient.GenModels {
    interface TaskGroupTreeNodeModel extends WebClient.GenModels.TreeNodeModel {
        /**
         * Gets or sets execution type
         */
        executionType: WebClient.GenModels.ExecutionType;
        /**
         * Gets or sets value indicating whether task group is overdue
         */
        isOverdue: boolean;
        /**
         * Gets or sets task group priority
         */
        priority: WebClient.GenModels.Priority;
        /**
         * Gets or sets state category
         */
        stateCategory: WebClient.GenModels.TaskGroupStateCategory;
        /**
         * Gets or sets value indicating whether task group on control
         */
        onControl: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface TaskTreeNodeHelpModel extends WebClient.GenModels.TreeNodeHelpModel {
        /**
         * Gets or sets author
         */
        author: WebClient.GenModels.EmployeeModel;
        /**
         * Gets current performers
         */
        currentPerformers: Array<WebClient.GenModels.TaskCurrentPerformer>;
        /**
         * Gets or sets delegation hint
         */
        delegationHint: WebClient.GenModels.DelegationRecord;
        /**
         * Gets or sets task name
         */
        name: string;
        /**
         * Gets or sets task content
         */
        content: string;
        /**
         * Gets or sets task end date
         */
        endDate?: string;
        /**
         * Gets or sets controller
         */
        controller: WebClient.GenModels.EmployeeModel;
        /**
         * Gets or sets task control date
         */
        controlDate?: string;
        /**
         * Gets or sets value indicating whether task is overdue
         */
        isOverdue: boolean;
        /**
         * Gets or sets actual end date
         */
        endDateActual?: string;
        /**
         * Gets or sets report
         */
        report: string;
        /**
         * Gets or sets report files
         */
        reportFiles: Array<WebClient.GenModels.LinkModel>;
        /**
         * Gets delegation history
         */
        delegationHistory: Array<WebClient.GenModels.DelegationRecord>;
    }
}
declare namespace WebClient.GenModels {
    interface LinkModel {
        /**
         * Gets link identifier
         */
        linkId: string;
        /**
         * Gets display link name
         */
        displayName: string;
        /**
         * Gets link type name
         */
        linkTypeName: string;
        /**
         * link kind
         */
        kind: WebClient.GenModels.LinkKind;
        /**
         * Is linked card a document card.
         */
        isDocument: boolean;
        /**
         * Gets linked card identifier
         */
        cardId: string;
        /**
         * Gets link creation date
         */
        creationDate?: string;
        /**
         * Gets display name of the author of the link.
         */
        authorDisplayName: string;
        /**
         * Gets link description
         */
        description: string;
        /**
         * Gets link description
         */
        url: string;
    }
}
declare namespace WebClient.GenModels {
    interface TaskTreeNodeHintModel extends WebClient.GenModels.TreeNodeHintModel {
        /**
         * Gets or sets task name
         */
        name: string;
        /**
         * Gets or sets task end date
         */
        endDate?: string;
        /**
         * Gets state name
         */
        stateDisplayName: string;
        /**
         * Gets task state class name
         */
        stateClassName: string;
        /**
         * Gets task state type
         */
        stateType: number;
        /**
         * Gets or sets delegation hint
         */
        delegationHint: WebClient.GenModels.DelegationRecord;
    }
}
declare namespace WebClient.GenModels {
    interface TaskTreeNodeModel extends WebClient.GenModels.TreeNodeModel {
        /**
         * Gets or sets value indicating whether task has delegates
         */
        hasDelegates: boolean;
        /**
         * Gets or sets value indicating whether task has report
         */
        hasReport: boolean;
        /**
         * Gets or sets value indicating whether task has file report
         */
        hasFileReport: boolean;
        /**
         * Gets or sets value indicating whether task on control
         */
        onControl: boolean;
        /**
         * Gets or sets value indicating whether task is task of responsible performer in parent task group
         */
        isResponsiblePerformerTask: boolean;
        /**
         * Gets or sets performer gender
         */
        gender: WebClient.GenModels.PerformerGender;
        /**
         * Gets or sets value indicating whether task is overdue
         */
        isOverdue: boolean;
        /**
         * Gets or sets task priority
         */
        priority: WebClient.GenModels.Priority;
        /**
         * Gets or sets task state category
         */
        stateCategory: WebClient.GenModels.TaskStateCategory;
        /**
         * Gets current performers
         */
        currentPerformers: Array<WebClient.GenModels.TaskCurrentPerformer>;
    }
}
declare namespace WebClient.GenModels {
    interface StateModel {
        /**
         * Gets or sets state idenrifier
         */
        stateId: string;
        /**
         * Gets or sets caption
         */
        caption: string;
    }
}
declare namespace WebClient.GenModels {
    interface CompletionOption {
        /**
         * Gets or sets completion option identifier
         */
        id: string;
        /**
         * Gets or sets name
         */
        name: string;
        /**
         * Gets or sets value
         */
        value: number;
        /**
         * Gets or sets value indicating whether option is default
         */
        isDefault: boolean;
        /**
         * Gets attributes collection
         */
        parameters: Array<WebClient.GenModels.CompletionParameter>;
        /**
         * Gets or sets color
         */
        color: string;
    }
}
declare namespace WebClient.GenModels {
    interface CompletionParameter {
        /**
         * Gets completion parameter type
         */
        type: WebClient.GenModels.CompletionParameterType;
        /**
         * Gets or sets section identifier
         */
        sectionId: string;
        /**
         * Gets or sets field name
         */
        fieldName: string;
        /**
         * Gets or sets value indicating whether attribute is required
         */
        required: boolean;
        /**
         * Gets or sets display name
         */
        displayName: string;
        /**
         * Gets or sets display mode
         */
        displayMode: WebClient.GenModels.CompletionParameterDisplayMode;
        /**
         * Gets or sets value
         */
        value: any;
        /**
         * Gets value indicating whether Value is empty
         */
        isEmpty: boolean;
        /**
         * Gets or sets parameter identifier
         */
        id: string;
    }
}
declare namespace WebClient.GenModels {
    interface TaskDelegationInfoModel {
        /**
         * Gets or sets lis of delegate
         */
        delegates: Array<WebClient.GenModels.TaskCardDelegateItemModel>;
        /**
         * Get deletage status
         */
        status: string;
        /**
         * Get task state type
         */
        stateType: WebClient.GenModels.TaskStateType;
        /**
         * Gets or sets completion option where task state in Completed
         */
        completionOption: WebClient.GenModels.CompletionOptionModel;
        /**
         * Task performer
         */
        taskInitialPerformer: WebClient.GenModels.EmployeeModel;
    }
}
declare namespace WebClient.GenModels {
    interface TaskCardDelegateItemModel {
        /**
         * Gets or sets from delegate
         */
        sourceDelegate: WebClient.GenModels.EmployeeModel;
        /**
         * Gets or sets to delegate
         */
        destinationDelegate: WebClient.GenModels.EmployeeModel;
        /**
         * Gets or set delegate date
         */
        delegateDate: string;
        /**
         * Gets or set return from delegation date
         */
        returnFromDelegationDate?: string;
        /**
         * Is the record about completed delegation
         */
        returnedFromDelegation: boolean;
        /**
         * Gets or set delegate comment
         */
        comment: string;
    }
}
declare namespace WebClient.GenModels {
    interface EmployeeModel {
        /**
         * Gets or sets employee identifier
         */
        employeeId: string;
        /**
         * Display user full name
         */
        displayName: string;
        /**
         * Get employee first name
         */
        fistName: string;
        /**
         * Gets employee last name
         */
        lastName: string;
        /**
         * Get employee middle name
         */
        middleName: string;
        /**
         * Gets or sets employee email address
         */
        email: string;
        /**
         * Gets or sets employee display position
         */
        position: string;
        /**
         * Gets or sets unit
         */
        unit: WebClient.GenModels.UnitModel;
        /**
         * Gets or set user account name
         */
        accountName: string;
        /**
         * Gets or sets deputy display name
         */
        deputyDisplayName: string;
        /**
         * Gets value indicating whether employee is favorite performer
         */
        isFavoritePerformer: boolean;
    }
}
declare namespace WebClient.GenModels {
    interface UnitModel {
        /**
         * Get unit identifier
         */
        unitId: string;
        /**
         * Get unit name
         */
        unitName: string;
    }
}
declare namespace WebClient.GenModels {
    interface CompletionOptionModel {
        /**
         * Gets or sets completion option identifier
         */
        id: string;
        /**
         * Gets or sets name
         */
        name: string;
        /**
         * Gets or sets value
         */
        value: number;
        /**
         * Gets or sets IsDefault
         */
        isDefault: boolean;
        /**
         * Gets or sets value indicated whether has report filed in completion option
         */
        hasReportFielInCompletionOption: boolean;
        /**
         * Gets attributes collection
         */
        parameters: Array<WebClient.GenModels.CompletionParameterModel>;
        /**
         * Gets or sets color
         */
        color: string;
    }
}
declare namespace WebClient.GenModels {
    interface CompletionParameterModel {
        /**
         * Gets or sets parameter idenitifer
         */
        id: string;
        /**
         * Gets or sets field name
         */
        name: string;
        /**
         * Gets or sets value indicated where field is required
         */
        required: boolean;
        /**
         * Gets or sets field type
         */
        type: WebClient.GenModels.CompletionParameterType;
        /**
         * Gets or sets value
         */
        value: string;
        isEmpty: boolean;
        /**
         * Gets or sets employee
         */
        employee: WebClient.GenModels.EmployeeModel;
    }
}
declare namespace WebClient.GenModels {
    interface CardKindModel {
        /**
         * Gets card kind name
         */
        cardKindName: string;
        /**
         * Gets card kind name with parent kinds
         */
        cardKindFullName: string;
        /**
         * Gets card kind identifier
         */
        cardKindId?: string;
        /**
         * Gets loading error
         */
        loadingError: string;
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents search context option
     */
    enum SearchContextOption {
        /**
         * Search in current folder
         */
        CurrentFolder = 0,
        /**
         * Search in current folder and subfolders
         */
        CurrentFolderAndSubFolders = 1,
        /**
         * Search in search results
         */
        SearchInSearchResults = 2,
        /**
         * Search everywhere
         */
        EveryWhere = 3,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents type of {@link WebClient.GenModels}
     */
    enum BusinessCalendarSourceType {
        /**
         * Employee
         */
        Employee = 0,
        /**
         * Staff unit
         */
        StaffUnit = 1,
    }
}
declare namespace WebClient.GenModels {
    enum DigitalSignatureKind {
        Auto = 0,
        HashSignature = 1,
        CadesBesSignature = 2,
        CadesTSignature = 3,
        CadesXLongType1Signature = 4,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Partner search mode
     */
    enum PartnerSearchMode {
        SearchDepartments = 0,
        SearchEmployees = 1,
        SearchAll = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Partner item type
     */
    enum PartnerItemType {
        /**
         * Organization
         */
        Organization = 0,
        /**
         * Department
         */
        Department = 1,
        /**
         * Employee
         */
        Employee = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Type of department
     */
    enum DepartmentType {
        /**
         * Organization
         */
        Organization = 0,
        /**
         * Department
         */
        Department = 1,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Declare device types
     */
    enum DeviceType {
        /**
         * Desktop
         */
        Desktop = 0,
        /**
         * Smartphone
         */
        Smartphone = 1,
        /**
         * Tablet
         */
        Tablet = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Folder DocsVision.Platform.Cards.Constants.FoldersCard.Folders.DefaultStyle property value
     */
    enum DvFolderStyles {
        /**
         * None
         */
        None = 0,
        /**
         * View displayed
         */
        FolderView = 1,
        /**
         * Card displayed
         */
        FolderCard = 2,
        /**
         * HTML page displayed
         */
        FolderURL = 4,
        /**
         * Digest view displayed
         */
        FolderDigest = 8,
        /**
         * All
         */
        All = 15,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Declare column type
     */
    enum ColumnType {
        /**
         * Int
         */
        Integer = 0,
        /**
         * String
         */
        String = 1,
        /**
         * Double
         */
        Float = 2,
        /**
         * Datetime
         */
        DateTime = 3,
        /**
         * Boolean
         */
        Bool = 5,
        /**
         * Decimal column type
         */
        Decimal = 6,
        /**
         * Unique id data type
         */
        UniqueId = 7,
    }
}
declare namespace WebClient.GenModels {
    enum FormFactor {
        Desktop = 1,
        Mobile = 2,
    }
}
declare namespace System.Web.UI.WebControls {
    enum SortDirection {
        Ascending = 0,
        Descending = 1,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents layout type
     */
    enum LayoutType {
        /**
         * Layout for view
         */
        View = 0,
        /**
         * Layout for edit
         */
        Edit = 1,
        /**
         * Layout for creating card
         */
        Create = 2,
    }
}
declare namespace WebClient.GenModels {
    enum AgreementStateType {
        Draft = 0,
        Started = 1,
        Stopped = 2,
        Agreed = 3,
        Other = 4,
    }
}
declare namespace WebClient.GenModels {
    enum ApprovalType {
        Sequential = 0,
        Parallel = 1,
        Consolidation = 2,
        Alternative = 3,
    }
}
declare namespace WebClient.GenModels {
    enum StageSemantics {
        Positive = 1,
        Negative = 2,
        Neutral = 3,
        Other = 4,
    }
}
declare namespace WebClient.GenModels {
    enum ApprovalOperationKind {
        Resume = 0,
        Finish = 1,
        Pause = 2,
        Cancel = 3,
        ToApprove = 4,
        AbortStage = 5,
        Management = 6,
    }
}
declare namespace WebClient.GenModels {
    enum DecisionSemantics {
        Positive = 1,
        Negative = 2,
        Neutral = 3,
        Cancellation = 4,
        NewCycle = 5,
        ApproversAddition = 6,
        Completion = 100,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents what and how to search in directory designer tree
     */
    enum DirectoryDesignerSearchArea {
        /**
         * Query should return only specified node and its rows
         */
        OnlyNode = 0,
        /**
         * Query should return only node, children and chlidren rows (without node rows).
         */
        OnlyChildren = 1,
        /**
         * Query should return node, children, node rows and children rows (i.e. everything).
         */
        NodeWithChildren = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents type of tree node
     */
    enum DirectoryDesignerTreeNodeType {
        /**
         * directory designer item type (node)
         */
        Node = 0,
        /**
         * directory designer row
         */
        Row = 1,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents how to search in directory designer tree
     */
    enum DirectoryDesignerSearchMode {
        /**
         * Search by id
         */
        Id = 0,
        /**
         * Search by name and description
         */
        NameAndDesc = 1,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents folder node type
     */
    enum FolderNodeType {
        /**
         * Regular
         */
        Regular = 1,
        /**
         * Virtual
         */
        Virtual = 4,
        /**
         * Delegate
         */
        Delegate = 8,
        /**
         * SystemHidden
         */
        SystemHidden = 16,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents folder node style
     */
    enum FolderNodeStyle {
        /**
         * View displayed
         */
        FolderView = 1,
        /**
         * Card displayed
         */
        FolderCard = 2,
        /**
         * HTML page displayed
         */
        FolderURL = 4,
        /**
         * Digest view displayed
         */
        FolderDigest = 8,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represent link kind
     */
    enum LinkKind {
        /**
         * card link type
         */
        Card = 0,
        /**
         * file link type
         */
        File = 1,
        /**
         * Url link type
         */
        Url = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * department data source
     */
    enum DepartmentDataSource {
        /**
         * Staff directory
         */
        StaffDirectory = 0,
        /**
         * Partners directory
         */
        PartnersDirectory = 1,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Department type for different search requests
     */
    enum SearchDepartmentType {
        /**
         * Not specified (any)
         */
        None = 0,
        /**
         * Department
         */
        Department = 1,
        /**
         * Organization
         */
        Organization = 2,
    }
}
declare namespace WebClient.GenModels {
    enum RadioGroupLabelLocation {
        Right = 0,
        Left = 1,
    }
}
declare namespace WebClient.GenModels {
    enum TaskGroupWithOneTaskDisplayMode {
        Both = 0,
        Group = 1,
        Task = 2,
    }
}
declare namespace WebClient.GenModels {
    enum TasksDisplayMode {
        ListAndCreation = 0,
        OnlyCreation = 1,
    }
}
declare namespace WebClient.GenModels {
    enum TasksTreeDisplayMode {
        Button = 0,
        Layout = 1,
    }
}
declare namespace WebClient.GenModels {
    enum DepartmentDialogMode {
        Tree = 0,
        List = 1,
    }
}
declare namespace WebClient.GenModels {
    enum EmployeeViewMode {
        Fio = 0,
        DisplayName = 1,
        Auto = 2,
    }
}
declare namespace WebClient.GenModels {
    enum FolderMode {
        Empty = 0,
        CurrentFolder = 1,
    }
}
declare namespace WebClient.GenModels {
    enum HtmlViewMode {
        FromCard = 0,
        FromFile = 1,
        External = 2,
    }
}
declare namespace WebClient.GenModels {
    enum PartnerTipModeItems {
        Fio = 0,
        FioAndPosition = 1,
        NotUsed = 2,
    }
}
declare namespace WebClient.GenModels {
    enum AgreementManagementAvailableButtons {
        Pause = 1,
        Cancel = 2,
        Complete = 4,
        All = -1,
    }
}
declare namespace WebClient.GenModels {
    enum AgreementHistoryMode {
        Button = 0,
        Layout = 1,
    }
}
declare namespace WebClient.GenModels {
    enum AgreementMode {
        StartAndManagement = 0,
        StartOnly = 1,
        ManagementOnly = 2,
    }
}
declare namespace WebClient.GenModels {
    enum ApproverViewType {
        Fio = 0,
        FioAndPosition = 1,
        DisplayString = 2,
    }
}
declare namespace WebClient.GenModels {
    enum DateTimePickerType {
        DateTime = 0,
        Date = 1,
    }
}
declare namespace WebClient.GenModels {
    enum Orientation {
        Horizontal = 0,
        Vertical = 1,
    }
}
declare namespace WebClient.GenModels {
    enum AgreementManagementOperations {
        Resume = 0,
        Complete = 1,
        Pause = 2,
        Cancel = 3,
        ToApprove = 4,
        AbortStage = 5,
        Management = 6,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Default time modes for DateTime
     */
    enum DateTimeDefaultTimeModes {
        /**
         * Current time
         */
        CurrentTime = 0,
        /**
         * Start of day
         */
        StartOfDay = 1,
        /**
         * Start of work day
         */
        StartOfWorkDay = 2,
        /**
         * End of day
         */
        EndOfDay = 3,
        /**
         * End of work day
         */
        EndOfWorkDay = 4,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents performer gender
     */
    enum PerformerGender {
        /**
         * Gender not specified
         */
        NotSpecified = 0,
        /**
         * Male
         */
        Male = 1,
        /**
         * Female
         */
        Female = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents priority
     */
    enum Priority {
        /**
         * Low
         */
        Low = 0,
        /**
         * Normal
         */
        Normal = 1,
        /**
         * High
         */
        High = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents task group state category
     */
    enum TaskGroupStateCategory {
        /**
         * TBD
         */
        Preparing = 0,
        /**
         * TBD
         */
        Performing = 1,
        /**
         * TBD
         */
        Completed = 2,
        /**
         * TBD
         */
        Other = 3,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents execution type
     */
    enum ExecutionType {
        /**
         * Serial
         */
        Serial = 0,
        /**
         * Parallel
         */
        Parallel = 1,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents task state category
     */
    enum TaskStateCategory {
        /**
         * Initialization and Recalled
         */
        Preparing = 0,
        /**
         * InWork Delegated ReturnFromDelegation OnAcceptance
         */
        InWork = 1,
        /**
         * Rejected
         */
        Rejected = 2,
        /**
         * OnRework
         */
        OnRework = 3,
        /**
         * Completed
         */
        Completed = 4,
        /**
         * Other
         */
        Other = 5,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Completion variant type
     */
    enum CompletionParameterType {
        /**
         * One row string
         */
        String = 0,
        /**
         * Multi row string
         */
        Text = 1,
        /**
         * Boolean
         */
        Boolean = 2,
        /**
         * DateTime
         */
        DateTime = 3,
        /**
         * Time
         */
        Time = 4,
        /**
         * Double
         */
        Double = 5,
        /**
         * Int
         */
        Int = 6,
        /**
         * Employee
         */
        Employee = 7,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents parameter display mode
     */
    enum CompletionParameterDisplayMode {
        /**
         * Always
         */
        Always = 0,
        /**
         * Never
         */
        Never = 1,
        /**
         * If empty
         */
        IfEmpty = 2,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Declares available task states
     */
    enum TaskStateType {
        /**
         * Task created by author
         */
        Draft = 0,
        /**
         * Task processed by performer
         */
        InWork = 1,
        /**
         * Task completed by performer
         */
        Completed = 2,
        /**
         * Task rejected by performer
         */
        Rejected = 3,
        /**
         * Task is on agreement with somebody
         */
        OnAgreement = 4,
        /**
         * Task agreement was successfully completed
         */
        Agreed = 5,
        /**
         * Task state not supported by 6.0
         */
        Unknown = 6,
        /**
         * Task is not agreed
         */
        NotAgreed = 7,
        /**
         * Task is on acceptance
         */
        OnAcceptance = 8,
        /**
         * Task is on modification
         */
        OnModification = 9,
        /**
         * Task is deferred
         */
        Deferred = 10,
        /**
         * Task is recalled
         */
        Recalled = 11,
        /**
         * Task is delegated
         */
        Delegated = 12,
        /**
         * Task is returned from delegation
         */
        ReturnedFromDelegation = 13,
        /**
         * Task is started
         */
        Started = 14,
        /**
         * Task is stopped
         */
        Stopped = 15,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Represents task group card state type
     */
    enum TaskGroupStateType {
        /**
         * Preparation
         */
        Preparation = 0,
        /**
         * Performance
         */
        Performance = 1,
        /**
         * Completed
         */
        Completed = 2,
        /**
         * Recalled
         */
        Recalled = 3,
        /**
         * Unknown
         */
        Unknown = 6,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Field types
     */
    enum FieldType {
        /**
         * Integer
         */
        Int = 0,
        /**
         * Boolean
         */
        Bool = 1,
        /**
         * DateTime
         */
        DateTime = 2,
        /**
         * Date
         */
        Date = 3,
        /**
         * Time
         */
        Time = 4,
        /**
         * Enum
         */
        Enum = 5,
        /**
         * Bitmask
         */
        Bitmask = 6,
        /**
         * Unique identifier
         */
        UniqueId = 7,
        /**
         * User identifier
         */
        UserId = 8,
        /**
         * String
         */
        String = 9,
        /**
         * Unicode string
         */
        Unistring = 10,
        /**
         * File identifier
         */
        FileId = 11,
        /**
         * Float
         */
        Float = 12,
        /**
         * Reference identifier
         */
        RefId = 13,
        /**
         * Reference card identifier
         */
        RefCardId = 14,
        /**
         * Text
         */
        Text = 15,
        /**
         * Unicode text
         */
        Unitext = 16,
        /**
         * Binary
         */
        Binary = 17,
        /**
         * Image
         */
        Image = 18,
        /**
         * Secure Digital Identification
         */
        Sdid = 19,
        /**
         * Decimal
         */
        Decimal = 20,
        /**
         * Variant
         */
        Variant = 21,
    }
}
declare namespace WebClient.GenModels {
    /**
     * Field subtype
     */
    enum FieldSubtype {
        /**
         * None
         */
        None = 0,
        /**
         * String
         */
        String = 1,
        /**
         * Integer
         */
        Int = 2,
        /**
         * Double
         */
        Double = 3,
        /**
         * Date
         */
        Date = 4,
        /**
         * Boolean
         */
        Bool = 5,
        /**
         * Employee
         */
        Employee = 6,
        /**
         * Department
         */
        Department = 7,
        /**
         * Group
         */
        Group = 8,
        /**
         * Role
         */
        Role = 9,
        /**
         * Universal
         */
        Universal = 10,
        /**
         * Time
         */
        Time = 11,
        /**
         * DateTime
         */
        DateTime = 12,
        /**
         * PartnerEmployee
         */
        PartnerEmployee = 13,
        /**
         * PartnerDepartment
         */
        PartnerDepartment = 14,
        /**
         * Card reference
         */
        CardRef = 15,
        /**
         * Card type
         */
        CardType = 16,
        /**
         * Card state
         */
        CardState = 17,
    }
}
declare namespace WebClient {
    /**
     * Позволяет создавать контейнеры в <body> и хранить свои html-узлы в них.
     */
    class BodyContainerProvider {
        /** Активные контейнеры */
        static ActiveContainers: HTMLElement[];
        /** Текущий контейнер */
        private mContainer;
        constructor(id: string);
        /**
         * Возвращает контейнер по его идентификатору.
         *
         * Если контейнер не был создан, то в начале тега <body> создаётся новый контейнер с указанным идентификатором.
         *
         * @param id Идентификатор контейнера
         */
        private getContainer(id);
        /**
         * Уничтожает контейнер.
         */
        dispose(): void;
        /**
         * Создаёт элемент с указанным классом и присоединяет его в конец контейнера.
         * @param className Название класса
         */
        createElement(className?: string): HTMLElement;
        /**
         * Убирает указанный элемент из DOM.
         * @param elem Убираемый элемент
         */
        freeElement(elem: HTMLElement): JQueryDeferred<any>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IBoxWithButtonsProps {
        /** Tooltip of the menu item */
        title?: string;
        /** React.ReactNode that repersents a box content */
        children?: React.ReactNode;
        /** Custom class for menu item */
        className?: string;
        /** ReactJS key */
        key?: string;
        /** Shows loading incon at the left of the buttons */
        loadingState?: LoadingState;
        /** Buttons, that will be showed on the right side of the box */
        buttons: IBoxWithButtonsButtonInfo[];
        /** Show buttons inside the box with absolute positioning. Defautl value: false */
        buttonsInside?: boolean;
    }
    /** @internal */
    interface IBoxWithButtonsButtonInfo extends IIconButtonProps {
        /**
         * If value is true, then button will hiden by zero-opacity, and shown on box hover
         * Default value: false
         */
        showOnlyOnHover?: boolean;
    }
    /** @internal */
    class BoxWithButtonsDefault {
        /**
         * Creates IBoxWithButtonsButtonInfo with default values, that forms clear button.
         * @param props Overrides of default values
         *
         * @internal
        */
        static clearButton(props?: IBoxWithButtonsButtonInfo): IBoxWithButtonsButtonInfo;
    }
    /** Represents a box with buttons at the right side.
      * Usage example:
      *  <BoxWithButtons buttons={[BoxWithButtonsDefault.clearButton({ onClick: this.onClearClick })]} >
      *     { super.renderInput() }
      *  </BoxWithButtons>
      * @internal
      */
    const BoxWithButtons: (props: IBoxWithButtonsProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal Свойства для {@link Button} */
    interface IButtonProperties {
        /** Отображаемый текст. */
        text?: string;
        /**
         * Позволяет показать указанную иконку слева от текста.
         * Класс должен оределять ширину и высоту фона, представляющего собой иконку.
         * Предпочтительная ширина иконка - 18px (это ширина иконки загрузки), но можно использовать и иконку любых других размеров.
         * Если размер иконки не 18x18, то вы должны установить в свойстве loadingIconClass свою загрузочную иконку,
         * иначе текст будет прыгать во время загрузки.
         * По умолчанию: null.
         */
        iconClass?: string;
        /**
         * Показывать ли иконку загрузки во время загрузки вместо иконки указанной в свойстве iconClass.
         * По умолчанию: false.
         */
        loading?: boolean;
        /**
         * Пользовательский класс для загрузочной иконки (свойство loading должно быть истинно).
         * По умолчанию: "dv-ico icon-spin loader-animate".
         */
        loadingIconClass?: string;
        /** Видна ли кнопка. По умолчанию: true. */
        visible?: boolean;
        /** Дополнительный класс. */
        className?: string;
        /** Событие клика. Оно Вызывается также при нажатии клавиш Enter или Space (пробел), когда кнопка находится в фокусе. */
        onClick?: (ev: React.MouseEvent<any>) => void;
        /** Обработчик нажатия клавиши. */
        onKeyDown?: (ev?) => void;
        /** Вызывается при получении кнопкой фокуса. */
        onFocus?: (ev?) => void;
        /** Вызывается при потери кнопкой фокуса. */
        onBlur?: (ev?) => void;
        /**
         * Должна ли кнопка иметь ширину 100% или нет.
         * По умолчанию: true.
         */
        stretchWidth?: boolean;
        /** Всплывающая подсказка. */
        title?: string;
        /**
         * Отображать кнопку с указанным стилем Primary.
         * По умолчанию: false
         */
        primaryButton?: boolean;
        /**
         * Как текст кнопки и её иконка должны быть выровнены.
         * По умолчанию: ButtonAlignModes.Center
         */
        align?: ButtonAlignModes;
        /** Значение свойства TabIndex для навигации по клавише Tab. */
        tabIndex?: number;
        /** Содержимое кнопки (может быть использовано вместо свойства text). */
        children?: any;
        /** Поддержка для присоединения к корневому элементу. */
        attach?: (instance: HTMLElement) => any;
        /** Значение атрибута data-button-name для автотестирования. */
        name?: string;
        /**
         * Выключена ли конпка или включена.
         * Если кнопка выключена, то она будет иметь особый внешний вид и событие onClick не будет вызываться.
         * По умолчанию: false.
         */
        disabled?: boolean;
    }
    /** @internal Режимы выравнивания кнопки. */
    enum ButtonAlignModes {
        Center = 0,
        Left = 1,
    }
    /** @internal Представляет собой кнопку с иконкой. */
    const Button: (props: IButtonProperties) => JSX.Element;
}
declare namespace WebClient {
    /** @internal Свойства для {@link CommandBarButton} */
    interface ICommandBarButtonProps {
        /**
         * Предполагается, что по умолчанию expanded = false. В этом случае кнопка выглядит как "+".
         * При изменении значения на true инициируется анимация поворота и кнопка превращается в "x".
         */
        expanded: boolean;
        /** При нажатии на кнопку. В большинстве случаев, свойство expanded меняется именно в этом обработчике. */
        onClick(event: React.MouseEvent<any>): void;
        /** Дополнительный класс. */
        className?: string;
        /** Видна ли кнопка */
        visible?: boolean;
        /** значение атрибута data-button-name для автотестирования. */
        name?: string;
        /** Всплывающая подсказка. */
        title?: string;
    }
    /**
     * @internal Представляет собой анимированную кнопку, которая выглядит как знак "+" в свёрнутом состоянии, и как "x" в развёрнутом.
     *
     * Смотрите также: {@link CommandBarHelper}.
     */
    const CommandBarButton: (props: ICommandBarButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** См. {@link RecursiveVisitorCallback} */
    enum VisitResult {
        /** Продолжить рекурсивный обход дерева */
        Continue = 0,
        /** Остановить рекурсивный обход дерева */
        Stop = 1,
    }
    /** См. {@link RecursiveVisitor} */
    type RecursiveVisitorCallback<NodeT> = (node: NodeT, parent?: NodeT, level?: number) => VisitResult | void;
    /**
     * @review Вспомогательный класс для рекурсивного обхода древовидных структур с использованием {@link IReadonlyAccessor} для доступа к дочерним узлам.
     */
    class RecursiveVisitor<NodeT> {
        children: IReadonlyAccessor<NodeT, NodeT[]>;
        /**
         * @param children Способ, при помощи которого будет осуществляться доступ к дочерним узлам.
         */
        constructor(children: IReadonlyAccessor<NodeT, NodeT[]>);
        /**
         * @review Рекурсивно обходит дерево вглубь (то есть, сначала спускается вниз, потом вширь).
         * @param node Текущий узел дерева
         * @param visitor Логика, которую необходимо выполнить для каждого узла.
         * @param parent Родительский узел (будет передан в visitor, параметр не обязателен)
         * @param currentLevel Текущий уровень узла (0 - корень дерева). Если не значение не задано, то считается что node - корень дерева.
         */
        visitDeep(node: NodeT, visitor: RecursiveVisitorCallback<NodeT>, parent?: NodeT, currentLevel?: number): VisitResult | void;
        /**
         * @review Рекурсивно обходит дерево вширь (то есть, сначала просматриваются соседние узлы, потом их дети).
         * @param node Текущий узел дерева
         * @param visitor Логика, которую необходимо выполнить для каждого узла.
         * @param parent Родительский узел (будет передан в visitor, параметр не обязателен)
         * @param currentLevel Текущий уровень узла (0 - корень дерева). Если не значение не задано, то считается что node - корень дерева.
         */
        visitWide(node: NodeT, visitor: RecursiveVisitorCallback<NodeT>, parent?: NodeT, currentLevel?: number): VisitResult | void;
        /**
         * @internal См. {@link visitWide}
         */
        visitWideInternal(visitor: RecursiveVisitorCallback<NodeT>, node: NodeT, currentLevel?: number): VisitResult | void;
        /**
         * @review Преобразует дерево в плоский список
         * @param tree Дерево
         * @param onVisitNode Вызывается при посещении каждого узла дерева. Должно вернуть булево значение - добавлять ли узел в плоский список или нет
         */
        getFlatTree<T>(tree: NodeT[], onVisitNode?: (node: NodeT) => boolean): NodeT[];
    }
}
declare namespace WebClient {
    class ControlsRecursiveVisitor extends RecursiveVisitor<LayoutControl> {
        constructor();
    }
}
declare namespace WebClient {
    /**
     * @internal Реализация Debouncer (пример использования см. в {@link QuickSearchLogic}).
     * Позволяет откладывать вызов функции на определённое время.
     */
    class Debouncer {
        /** Хранит идентификатор таймера */
        private timerHandle;
        /** Сохранённая функция для последующего отложенного вызова */
        private callback;
        /** Таймаут в мс */
        private timeout;
        constructor(callback: Function, timeout?: number);
        /**
         * Старт нового вызова хранимой функции после определённого промежутка времени.
         *
         * Переданные аргументы, будут использованы при вызове хранимой функции.
         */
        trigger(...params: any[]): void;
        /**
         * Очистка таймера для вызова хранимой функции.
         */
        clear(): void;
    }
}
declare namespace WebClient {
    namespace Styled {
        /**
         * @internal
         */
        namespace Helpers {
            /**
             * Позволяет присоединить свой интерфейс для стандартных html-узлов (styled.div, styled.button и т.п.) для автодополнения.
             * Для своих компонентов его использовать обычно не имеет смысла, так как в своём компоненте вы сами можете указать интерфейс для props.
             * Пример использования:
             *
             *     export interface IButtonProps {
             *         primary?: boolean;
             *     }
             *
             *     export const Button = Styled.Helpers.withProps<IButtonProps>()(styled.styled.button)`
             *         color: ${props => props.primary ? 'white' : 'black'};
             *     `;
             *
             */
            const withProps: <U>() => <P, T, O>(fn: styled.ThemedStyledFunction<P, T, O>) => styled.ThemedStyledFunction<P & U, T, O & U>;
            /**
             * Проверяет, является ли компонент Styled-компонентом
             * @param component Проверяемый компонент
             */
            const isStyled: (component: any) => boolean;
            /**
             * Позволяет скомбинировать несколько миксинов
             * @param mixins Список миксинов
             *
             * Пример использования:
             *
             *     export const Button = styled.styled.span`
             *         ${Styled.Helpers.combineMixins(Styled.Mixins.hover, Styled.Mixins.focus)`
             *             color: lime;
             *         `}
             *     `;
             *
             */
            const combineMixins: (...mixins: styled.ThemedCssFunction<any>[]) => (strings: any, ...values: any[]) => styled.InterpolationValue[];
            /**
             * @internal
             * Альтернатива для создания новых компонентов
             * Пример использования:
             *
             *     interface IShopItem {
             *         className?: string;
             *         available: boolean;
             *         price?: number;
             *         comments?: string[];
             *         name: string;
             *         onClick?: (e: React.MouseEvent<any>) => void
             *     }
             *
             *     class ShopItem extends React.Component<IShopItem, undefined> {
             *         render() {
             *             return <div className={this.props.className} onClick={this.props.onClick}>{this.props.name}</div>;
             *         }
             *     }
             *
             *     const PerfectQualityShopItem = new Styled.Helpers.ComponentBuilder(ShopItem)
             *         .setClasses('shop-item', ['shop-item_perfect-quality'])
             *         .setPropsForClasses({
             *             price: (name: string, value: number) => (value > 1000) ? 'highPrice' : 'lowPrice', // могут быть в camelCase
             *             comments: (name: string, value: string[] | null) => value && (value.length > 0) ? name : null;
             *         })
             *         .build()`
             *             color: ${props => props.available ? 'green' : 'gray'};
             *         `;
             *
             */
            class ComponentBuilder<P, T = any, O = P> {
                static readonly MODIFIER_DELIMITER: string;
                protected component: styled.ThemedStyledFunction<P, T, O>;
                /** Название главного класса. Отличается от дополнительных тем, что на основе него строятся названия классов для свойств. */
                protected mainClassName: string;
                /** Список дополнительных классов */
                protected additionalClassNames: string;
                /** Список аттрибутов, которые будут указаны в HTML-классах */
                protected propsTransformers: IComponentBuilderPropsTransformers<Partial<P>>;
                /** Список свойств не преобразовывающихся в модификаторы */
                protected excludedProps: Array<keyof P>;
                /** @deprecated Use {@link propsTransformers} */
                protected propsForClasses: IComponentBuilderPropsTransformers<Partial<P>>;
                /**
                 * Создание из Styled-компонента с кастомным интерфейсом (styled.div и т.д.)
                 */
                static createWithProps<CustomInterface = {}>(): <SP, ST, SO>(component: styled.ThemedStyledFunction<SP, ST, SO>) => ComponentBuilder<SP & CustomInterface, ST, SO & CustomInterface>;
                constructor(component: styled.ThemedStyledFunction<P, T, O> | styled.Component<P>);
                /**
                 * Устанавливает классы для компонента
                 * Разделение основного класса от других нужно для создания модификаторов на основе основного класса.
                 * @param mainClassName Название главного класса {@link mainClassName}
                 * @param additionalClassNames Список дополнительных классов {@link additionalClassNames}
                 */
                setClasses(mainClassName: string, additionalClassNames?: string[] | string): this;
                /**
                 * Устанавливает список свойств, который будет использован для формирования CSS классов-модификаторов.
                 *
                 * Если свойство - функция, то генерирование класса-модификатора делается самостоятельно.
                 * Если свойство - не функция, то считается, что оно булево и название класса-модификатора соответствует названию свойства.
                 *
                 * Названия в camelCase автоматически переводятся в snake-case
                 * Пример использования:
                 *
                 *     .transformPropsToClasses({
                 *         price: (name: string, value: number) => (value > 50) ? 'highPrice' : 'lowPrice',
                 *         errors: (name: string, value: string[]) => value && (value.length > 0) ? name : '';
                 *     })
                 *
                 * @param propsForClasses Список трансформеров
                 */
                transformPropsToClasses(propsTransformers: IComponentBuilderPropsTransformers<Partial<P>>): this;
                /** @deprecated Use {@link transformPropsToClasses} */
                setPropsForClasses(propsTransformers: IComponentBuilderPropsTransformers<Partial<P>>): this;
                /**
                 * Исключает указанные свойства при создании классов-модификаторов.
                 * По умолчанию все истинные булевы свойства переводятся в модификаторы.
                 */
                excludeProps(props: Array<keyof P>): this;
                protected buildClasses: (props: any) => string;
                protected attributeToClassName(attribute: string): string;
                /**
                 * Создаёт компонент (должен вызываться в самом конце).
                 */
                build(): styled.ThemedStyledFunction<P, T, O>;
            }
            /**
             * Функция, позволяющая преобразовать переданное название параметра в нужное название css-класса. Также может использоваться как фильтр.
             *
             * Поведение зависит от возвращаемого результата:
             *   1) true - в качестве CSS-класса используется исходное название переданного параметра name
             *   2) false - атрибут не преобразуется в CSS-класс
             *   3) string - модифицированное название атрибута name для последующего преобразования в
             *   CSS-класс (желательно использовать camelCase или hyphen-case).
             */
            type AttributesForClassesHandler = (name: string, value: any) => boolean | string;
            type IComponentBuilderPropsTransformers<T> = {
                [N in keyof T]: AttributesForClassesHandler;
            };
            /** @deprecated Use {@link IComponentBuilderPropsTransformers} */
            type IComponentBuilderPropsForClasses<T> = IComponentBuilderPropsTransformers<T>;
            type IComponentBuilderExcludedProps<T> = {
                [N in keyof T]: AttributesForClassesHandler;
            };
        }
    }
}
declare namespace WebClient {
    namespace Styled {
        /**
         * @internal
         */
        namespace Mixins {
            /** Добавляет стили при наведении курсора. */
            const hover: (strings: TemplateStringsArray, ...values: styled.SimpleInterpolation[]) => styled.InterpolationValue[];
            /** Добавляет стили при фокусе элемента. */
            const focus: (strings: TemplateStringsArray, ...values: styled.SimpleInterpolation[]) => styled.InterpolationValue[];
            /** Добавляет стили при активации элемента. */
            const active: (strings: TemplateStringsArray, ...values: styled.SimpleInterpolation[]) => styled.InterpolationValue[];
            /** Добавляет стили при  наведении  */
            const parentHover: (strings: TemplateStringsArray, ...values: styled.SimpleInterpolation[]) => styled.InterpolationValue[];
            const parentFocus: (strings: TemplateStringsArray, ...values: styled.SimpleInterpolation[]) => styled.InterpolationValue[];
            const parentActive: (strings: TemplateStringsArray, ...values: styled.SimpleInterpolation[]) => styled.InterpolationValue[];
        }
    }
}
declare namespace WebClient {
    /**
     * Поле ввода для поиска в справочнике.
     */
    const DirectorySearchInput: styled.StyledComponentClass<React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>, any, React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>>;
}
declare namespace WebClient {
    /** Свойства для {@link EmployeeName} */
    interface IEmployeeNameProps {
        /** Имя сотрудника, которое необходимо отобразить. */
        name: string;
    }
    /**
     * Компонент, который заменят пробелы перед инициалами на неразрывные пробелы, для избежания переноса инициалов отдельно от фамилии.
     * Инициалы распознаются как последовательность символов "Пробел", "Буква", "Точка".
     */
    class EmployeeName extends React.Component<IEmployeeNameProps, any> {
        private updateText(name);
        /** @internal */
        componentDidMount(): void;
        /** @internal */
        componentDidUpdate(): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link HighlightedSearchResult} */
    interface IHighlightedSearchResultProps {
        /** Текст результата поиска. */
        text: string;
        /** Текст поиска, который должен быть подсвечен. */
        searchQuery: string;
        /** Заголовок результата поиска. */
        title?: string;
        /** CSS-класс. */
        className?: string;
        /** Ключ для React. */
        key?: any;
        /** Обрезать длинный текст с помощью многоточия или нет. По умолчанию: true. */
        useEllipsis?: boolean;
    }
    /**
     * @internal Показывает текст с выделенным в нём результатом поиска.
     *
     * Пример использования:
     *
     *     <HighlightedSearchResult text={item.name} searchQuery={this.state.searchInput.value}  />
     */
    const HighlightedSearchResult: (props: IHighlightedSearchResultProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal Свойства для {@link HighlightedSimpleSearchResult} */
    interface IHighlightedSimpleSearchResult {
        /** Текст результата поиска. */
        text: string;
        /** Текст поиска, который должен быть подсвечен. */
        searchQuery: string;
        /** Заголовок результата поиска. */
        title?: string;
        /** CSS-класс. */
        className?: string;
    }
    /**
     * Показывает текст с выделенным в нём результатом поиска.
     *
     * Пример использования:
     *
     *     <HighlightedSimpleSearchResult text={item.name} searchQuery={this.state.searchInput.value}  />
     */
    const HighlightedSimpleSearchResult: (props: IHighlightedSimpleSearchResult) => JSX.Element;
}
declare namespace WebClient {
    /** @internal Свойства для {@link IconButton} */
    interface IIconButtonProps {
        /** Всплывающая подсказка. */
        title?: string;
        /** Класс, который добавляет иконку в виде фона для кнопки. */
        iconClassName?: string;
        /** Дополнительный класс. Может использоваться, чтобы добавить иконку для кнопки. */
        className?: string;
        /** Видна ли кнопка или нет. По умолчанию: true. */
        visible?: boolean;
        /** Обработчик клика по кнопке. */
        onClick: (event: React.MouseEvent<any>) => void;
        /** Обработчик нажатия клавиши. */
        onKeyDown?: (event: React.KeyboardEvent<any>) => void;
        /** Вызывается при получении кнопкой фокуса. */
        onFocus?: (event: React.FocusEvent<any>) => void;
        /** Вызывается при потери кнопкой фокуса. */
        onBlur?: (event: React.FocusEvent<any>) => void;
        /** Значение свойства TabIndex для навигации по клавише Tab. */
        tabIndex?: number;
        /** Значение атрибута data-button-name для автотестирования. */
        name?: string;
        /**
         * Выключена ли конпка или включена.
         * Если кнопка выключена, то она будет иметь особый внешний вид и событие onClick не будет вызываться.
         * По умолчанию: false.
         */
        disabled?: boolean;
    }
    /**
     * @internal Представляет собой кнопку, которая выглядит как маленькая иконка.
     *
     * Пример использования:
     *
     *     <IconButton name="open-dictionary" onClick={this.onOpenDictionaryClick}
     *         iconClassName="dv-ico dv-ico-dictionary" visible={super.getEditAvailable()}
     *         title={resources.Numerator_GenerateNewNumberTooltip}  />
     */
    const IconButton: (props: IIconButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface ILabeledText {
        /** Label to text value */
        label: string;
        /** Text value to show */
        text: React.ReactNode;
        /** If this parameter true and labelText specified, text stub (dashed line) will replace empty text.
          * Default value: false
          */
        showEmpty?: boolean;
        visible?: boolean;
        className?: string;
        /** Click on text element handler */
        onTextClick?: (ev: React.MouseEvent<any> | React.KeyboardEvent<any>) => void;
        /** Ref to text element handler */
        attachText?: (elem: HTMLElement) => void;
        /** Show colon after label or not. If value is AutoDots, then requirement for the colons will be detected automaticly.
          * Default value: AutoDots
          */
        labelDots?: LabelDotsMode;
        /** This param describes how value will be placed if control too narrow for it
          * If param is true, value will go to new line uner a label first
          * Otherwise it will occupy rest of space to the right of a label
          * Default value: true.
          */
        wrapLongTextUnderLabel?: boolean;
        /** If this parameter true, text will be rendered as clickable (blue and with dashed underline)
          * Default value: false
          */
        clickableText?: boolean;
        /** Tooltip */
        title?: string;
        /** Tooltip for value. If not specified, used title value */
        valueTitle?: string;
        /** Tab index for case, when onTextClick specified */
        tabIndex?: number;
        onFocus?: (event: React.FocusEvent<any>) => void;
        onBlur?: (event: React.FocusEvent<any>) => void;
    }
    /** @internal */
    enum LabelDotsMode {
        Dots = 0,
        NoDots = 1,
        AutoDots = 2,
    }
    /** @internal */
    const LabeledText: (props: ILabeledText) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalBackdrop} */
    interface IModalBackdropProps {
        /** Видимость.*/
        visible: boolean;
        /** Обработчик события click. */
        onClick?: (ev: React.MouseEvent<any>) => void;
        /** Элементы, располагающиеся поверх затемнения.  */
        children?: React.ReactNode;
    }
    /** Состояние для {@link ModalBackdrop} */
    interface IModalBackdropState {
    }
    /**
     * Представляет затемнение страницы, используемое для модальных окон и панелей.
     *
     * Пример использования:
     *
     *     <ModalBackdrop onClick={() => this.setState({ sidebarOpen: false })} >
     *         <ModalSidebar isOpen={this.state.sidebarOpen} >
     *             Sidebar content
     *         </ModalSidebar>
     *     </ModalBackdrop>
     */
    class ModalBackdrop extends React.Component<IModalBackdropProps, IModalBackdropState> {
        currentClickTarget: EventTarget;
        el: HTMLElement;
        onMouseDown: (e: React.MouseEvent<any>) => void;
        onMouseUp: (e: React.MouseEvent<any>) => void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Предоставляет контейнер для отрисовки модального окна. Позволяет отображать диалоговое окно вне react-компонент.
     *
     * Пример использования:
     *
     *     let host = new ModalHost("time-dialog", () => {
     *          return (
     *              <ModalBackdrop visible={true}>
     *                  <ModalDialog isOpen={true}>
     *                      <ModalDialogCloseButton onClick={() => host.unmount()} />
     *                      <ModalDialogHeader>Текущее время</ModalDialogHeader>
     *                      <div>Текущее время: {(new Date()).toTimeString()}</div>
     *                  </ModalDialog>
     *              </ModalBackdrop>
     *          );
     *      });
     *      host.mount();
     *      setInterval(() => host.forceUpdate(), 1000);
     *
     */
    class ModalHost {
        private mId;
        private mContainer;
        private mRenderFunction;
        private static mModalDialogHostContainerProvider;
        private static getModalDialogHostContaier();
        /**
         * Инициализирует объект ModalDialogHost
         * @param className Класс, который будет задан элементу-контейнеру в DOM
         * @param render Функция, выполняющая отрисовку модального окна
         */
        constructor(className: string, render: () => React.ReactNode | React.ReactNode[]);
        /**
         * Иницирует перерисовку модального окна. При этом вызывается функция render, переданная в конструктор.
         */
        forceUpdate(callback?: Function): void;
        /**
         * Создает в DOM элемент-контейнер, и запускает отрисовку модального окна.
         */
        mount(callback?: Function): void;
        /**
         * Удаляет все созданные элементы из DOM.
         */
        unmount(): JQueryDeferred<any>;
        private render(callback?);
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNodeIconDefault }  */
    interface IProclamationProps {
    }
    /** Область с важным сообщением, выделенная оранжевым цветом и рамкой. */
    const Proclamation: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IProclamationProps, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IProclamationProps>;
}
declare namespace WebClient {
    /**
     * @internal Предоставляет логику для отправки поисковых запросов после того как пользователь закончил ввод в текстовом поле.
     */
    class QuickSearchLogic {
        private debouncer;
        private searchIndex;
        constructor(searchCallback: Function, searchIndex?: number, searchTimeout?: number);
        /**
         * Обработка содержимого текстового поля и установка таймера для отправки поискового запроса с задержкой в случае успеха.
         * @param newText Содержимое текстового поля.
         */
        processInput(newText: string): void;
        /**
         * Очистка таймера для отправки поискового запроса
         */
        clear(): void;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link SearchBar} */
    interface ISearchBarProps {
        /** Дополнительный класс */
        className?: string;
        /** Значение инпута */
        value?: string;
        /** Плейсхолдер */
        placeholder?: string;
        /** Минимальное количество символов для начала поиска */
        searchIndex?: number;
        /** Временная задержка перед вызовом props.onSearch, позволяет не вызывать props.onSearch после каждого быстрого изменения содержимого инпута */
        searchTimeout?: number;
        /** При изменении значения */
        onChange?: (value: string) => void;
        /** При изменении значения с учётом props.searchIndex и props.searchTimeout */
        onSearch?: (value: string) => void;
        /** При нажатии клавиши */
        onKeyDown?: (e: React.KeyboardEvent<any>) => void;
    }
    /**
      * @review
      * @internal Хелпер для создания блока с поиском.
      *
      * Пример использования:
      *
      *     <Focusable>
      *         <SearchBar value="Значение"
      *             placeholder="Введите значение"
      *             searchIndex={3}
      *             searchTimeout={2000}
      *             onChange={value => console.log(value)}
      *             onSearch={value => console.log(value)} />
      *     </Focusable>
      */
    class SearchBar extends React.Component<ISearchBarProps, undefined> {
        protected quickSearchLogic: QuickSearchLogic;
        constructor(props: ISearchBarProps);
        /** @internal */
        componentWillReceiveProps(nextProps: ISearchBarProps): void;
        /**
         * Сбрасывает и заново инициализирует логику для поиска
         */
        protected resetSearchLogic: () => void;
        protected onChange: (value: string) => void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Свойства для {@link StackingModal} */
    interface IStackingModalProps {
        /** Видимость.*/
        visible: boolean;
        focusTrap?: boolean;
    }
    /** Состояние для {@link StackingModal} */
    interface IStackingModalState {
        /** zIndex модального окна */
        zIndex: number;
    }
    /**
     * @internal
     * Создаёт обёртку над модальным окном для показывания последнего созданного модального окна поверх других.
     */
    class StackingModal extends React.Component<IStackingModalProps, IStackingModalState> {
        constructor(props: IStackingModalProps);
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: IModalBackdropProps): void;
        componentWillUnmount(): void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITabsNavPanelItemProps {
        /** Active tab will be highlighted */
        active: boolean;
        /** Handler, that switch active tab */
        onClick(event: React.MouseEvent<any> | React.KeyboardEvent<any>): void;
        /** Tooltip of the menu item */
        title?: string;
        /** React.ReactNode that repersents menu item look */
        children?: React.ReactNode;
        /** Class "hide" will be added to command if visible = false */
        visible?: boolean;
        /** Custom class for menu item */
        className?: string;
        /** ReactJS key */
        key?: string;
        /** Name for autotest purposes */
        name: string;
        /** State of the tab content loading */
        loadingState?: LoadingState;
        /** Should tab item have positive tab index */
        tabIndex?: number;
    }
    /** @internal */
    interface ITabsNavPanelProps {
        /** Children tags, created by MenuBarItem */
        children?: React.ReactNode;
        className?: string;
        /** Should tabs fill all width of the tabs. Default value: true */
        stretchTabs?: boolean;
    }
    /** @internal Represents a row of tabs (only links, without tab content management)
      * Tab items should be rendered with TabsNavPanelItem.
      * Usage example:
      *  <TabsNavPanel expanded={this.state.menuBarExpanded} >
      *     <TabsNavPanelItem active={this.state.activeTab == 0} onClick={() => this.setState({ activeTab: 0 }); } >
      *        Tab 1
      *     </TabsNavPanelItem>
      *     <TabsNavPanelItem active={this.state.activeTab == 1} onClick={() => this.setState({ activeTab: 1 });} >
      *        Tab 2
      *     </TabsNavPanelItem>
      *  </TabsNavPanel>
      */
    const TabsNavPanel: (props: ITabsNavPanelProps) => JSX.Element;
    /** @internal */
    const TabsNavPanelItem: (props: ITabsNavPanelItemProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal Свойства для {@link TextInput} */
    interface ITextInputProps {
        /** Дополнительный класс */
        className?: string;
        /** Значение инпута */
        value?: string;
        /** Плейсхолдер */
        placeholder?: string;
        /** При изменении значения */
        onChange?: (value: string) => void;
        /** При нажатии клавиши */
        onKeyDown?: (e: React.KeyboardEvent<any>) => void;
    }
    /**
     * @internal Текстовое поле для ввода теста
     */
    class TextInput extends React.Component<ITextInputProps, undefined> {
        protected onChange: (e: any) => void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link UnreadCountIndicator} */
    interface IUnreadCountIndicatorProps {
        /** Количество */
        count: number;
        /** Дополнительный класс */
        className?: string;
    }
    /**
     * Отображает количество непрочитанных карточек.
     */
    const UnreadCountIndicator: (props: IUnreadCountIndicatorProps) => JSX.Element;
}
declare namespace WebClient {
    /** @deprecated */
    interface ILayoutManagerParams {
        rootElementId: string;
        applicationTimestamp: number;
        siteUrl: string;
    }
}
declare namespace WebClient {
    /** Параметры запуска валидации элемента управления. */
    interface IValidationParams {
        /** Показывать ли в интерфейсе элемента управления сообщение об ошибке. */
        ShowErrorMessage: boolean;
    }
}
declare namespace WebClient {
    /** Результат валидации контрола. */
    interface IValidationResult {
        /** Валидация была успешно пройдена. */
        Passed: boolean;
        /** Сообщение об ошибке. */
        Message: string;
    }
}
declare namespace WebClient {
    /** См. {@link LayoutManager.showLayout}. */
    interface ShowLayoutParams {
        /** HTML-элемент, в котором необходимо отобразить разметку, либо его идентификатор. */
        root: HTMLElement | string;
        /** Уникальное наименование данного экземпляра разметки. */
        name: string;
        /** Описание разметки и ее контролов. */
        model: GenModels.LayoutViewModel;
        /** Родительская разметка. */
        owner?: string;
        /** Тип разметки (идентификатор разметки на сервере). */
        layoutPosition?: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class Control implements IControl {
        rootElement: HTMLElement;
        isInit: boolean;
        ID(value?: string): string;
        constructor(root: HTMLElement);
        Init(onComplete?: () => void): void;
        Destroy(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IDecisionControlOptions {
        buttonsCount?: number;
    }
    /** @internal */
    class DecisionControl extends Control {
        private buttons;
        private moreButton;
        private moreButtonInnerText;
        private sidebar;
        private taskDecision;
        constructor(root: HTMLElement, options?: IDecisionControlOptions);
        private Initialize(options);
        protected InitiDecision(): void;
        protected TaskDecision: Cards.TaskDecision;
        private AddMoreButton();
    }
}
declare namespace WebClient.Approval {
    class ApprovaDecisionControl extends DecisionControl {
        protected InitiDecision(): void;
    }
}
declare namespace Approval {
    class ApprovalFilePanel {
        private static FileLinkCssClass;
        private static FileSettingsCssClass;
        private static FileItemCssClass;
        private static FileVersionCssClass;
        private static VersionSettingsCssClass;
        private static SettingMenuCssClass;
        private static VersionSettingMenuCssClass;
        private static CopyToFinalCmdCssClass;
        private static DeleteFileVersionCssClass;
        private static VersionCommentCssClass;
        private static MenuVersionCommentCssClass;
        private static MainFilesPlaceholder;
        private static AdditionalFilesPlaceholder;
        private filePanel;
        private currentSettings;
        private selectedElement;
        private taskId;
        private disclosureId;
        constructor(filePanelId: string);
        private Initialize();
        private initFilesHandlers(container);
        private SelectEventClick(item);
        private SettingEventHandler(fileItem);
        private UpdatePanel();
        private VersionEventHandler(fileItem);
        private ShowVersions(item, show?);
        private DeleteFileVersionEventHandler(item);
        private AddCopyToFinalEventHandler(item);
        private VersionsSettingsEventHandlers(versionItem);
        private ShowSettingsEventClick(item);
        private ShowSettings(item, show?);
        private PreviewFileEventHandler(item);
        private AddFileCommentEventHandler(item);
        private SuppressEvents(e);
        private WrapperEventHandler();
    }
}
declare namespace Approval {
    class ApprovalHistory {
        private rootElement;
        private selectedCycleNumber;
        private tabElement;
        private cycleUl;
        private elementId;
        constructor(elementId: string);
        private SetSelectedCycleNumber();
        private buildCyclePaginator(cycleUl, current);
        private createCycleLi(text, cycleNumber, cycleUl, isActive);
        private AttachEventHandlers();
        private LoadCycle();
        private SetActiveCycle(currentCycleNumber);
    }
}
declare namespace WebClient.Cards {
    class ApprovalHistoryCycle {
        private rootElement;
        private static FileLinkCssClass;
        private static ApprovalStageItemCssClass;
        private static DecisionInfoCssClass;
        constructor(root: HTMLElement);
        private Initialize();
        private InitGetFullInfo();
        private InitStageItem(item);
        private ShowFullStageInfo(item);
        private InitComments();
        private InitCommentButton(item);
        private ShowCommentDialog(item);
        private InitializeCommentDialogContent(clone, item);
        private PreviewFileEventHandler(item);
    }
}
declare namespace WebClient {
    class ApprovalPanel {
        private static CommandButtonsSelector;
        private rootElement;
        constructor(root: HTMLElement);
        private Init();
    }
}
declare namespace WebClient.Cards {
    class TaskCardView {
        private static DelegateListClassName;
        private static ReportPanelClassName;
        private static ShowCommentsButtonId;
        private static CommentFormId;
        private static TaskCommentsId;
        private static TaskCommentCountId;
        protected widget: HTMLElement;
        protected widgetId: string;
        private commentForm;
        private reportPanel;
        constructor(widgetId: string);
        private Initialize();
        protected onCardChanged: (message: IRealTimeCommunicationMessage<any>) => void;
        private ShowDelegateList(element);
        private SaveComment();
        private RefreshComments(response);
        private readonly CommentsContainer;
        private readonly CommentData;
        readonly CardInfo: CardInfoModel;
        private InitializeCommentsPanel();
        private AnimateCommentButtons(needShow);
        private EditComment(item);
        private DeleteComment(item);
        EditCommentMode: boolean;
        private ExpandCommentsEventHandler();
    }
    class TaskReportPanel {
        private static ReportContainerClassName;
        private static ReportTextClassName;
        private static DropZoneWithReportContentClassName;
        private static DropZoneWithFilesClassName;
        private static CommandExpandCssClass;
        private static FileLinkCssClass;
        private panel;
        private layout;
        private reportContainer;
        private commandBtn;
        private reportText;
        private dropZoneWithFiles;
        private dropZoneWithReportContent;
        private linkControl;
        private reportForm;
        private traceProvider;
        constructor(layout: Layout | TaskCardView, element: Element);
        private Initialize();
        private SaveTextReport();
        private SaveReportButton(button, refresh?, isAsync?);
        private CancelReportButton(button);
        private GetTextReportData();
        private readonly ReportInput;
        private ShowReportInput();
        private CommandExpandEventHandler(item);
    }
    class TaskDecision {
        static WidgetClassName: string;
        private static DecisionSelector;
        private selectedDecisionItem;
        private reverseBtn;
        private widget;
        constructor(widgetId: string, needReverseBtn?: boolean);
        private Initialize();
        protected RunDecision(item: HTMLElement): JQueryDeferred<any>;
        protected ShowPanel(response: any, isSingleClick?: boolean): JQueryDeferred<any>;
        private SubmitForm(form, panel, isSingleClick?);
        protected SendFormData(form: HTMLFormElement, panel: RightSidebar, callback?: Function): JQueryDeferred<any>;
        protected ExcecuteDecision(url: string, needShowDialog: boolean, callback?: Function): JQueryDeferred<any>;
        protected readonly SelectedDecision: HTMLElement;
        protected readonly Widget: HTMLElement;
    }
}
declare namespace WebClient.Approval {
    class ApprovalTaskDecision extends Cards.TaskDecision {
        protected ExcecuteDecision(url: string, needShowDialog: boolean, callback?: Function): JQueryDeferred<any>;
        private SignData(url, taskId, timestamp, comment, decisionId, encryptedInfo, isSimpleSign, callBack);
        protected SendFormData(form: HTMLFormElement, panel: RightSidebar, callback?: Function): JQueryDeferred<any>;
        private ShowSelectCertificateDialog(url, taskId, timestamp, comment, decisionId, callback?);
    }
}
declare namespace Approval.Cards {
    class ApprovalTaskView {
        private widget;
        private widgetId;
        private decision;
        constructor(widgetId: string);
        private Initialize();
        protected onCardChanged: (message: WebClient.IRealTimeCommunicationMessage<any>) => void;
    }
}
declare namespace WebClient.Cards {
    class TaskCardCreate {
        protected form: HTMLFormElement;
        protected url: string;
        protected parentCardId: HTMLInputElement;
        protected controllerForm: HTMLElement;
        protected saving: boolean;
        private saveButtonElement;
        private submiteButtonElement;
        private cancelButtonElement;
        private controllerCheckBox;
        private acceptanceCheckBox;
        private addFileCheckBox;
        private sendTaskInput;
        private uploadFilePanel;
        private documentsBlock;
        private performerControl;
        private controllerControl;
        private dropDownContainer;
        private dropdownControl;
        protected traceProvider: TraceProvider;
        constructor(formName: HTMLFormElement);
        static DisableButtons(): void;
        static EnableButtons(): void;
        static AddDocumentId(documentPanel: string, documentId: string): void;
        Save(): JQueryDeferred<any>;
        protected Initialize(): void;
        protected SendRequest(form: any): Promise<void>;
        protected readonly ControllerCheckBox: HTMLInputElement;
        protected readonly AcceptanceCheckBox: HTMLInputElement;
        protected readonly ControllerControl: EmployeeAutoComplete;
    }
}
declare namespace WebClient.Cards {
    class GroupTaskCardCreate extends TaskCardCreate {
        private dateRange;
        private executionType;
        private localResourses;
        private performersTable;
        private dateTimeFormat;
        private onControlDate;
        private responsePerformer;
        private employeeAutocomplete;
        private changePerformerControls;
        private allowResponsiveAcceptance;
        private allowAcceptance;
        private controlHour;
        constructor(formName: HTMLFormElement);
        Save(): JQueryDeferred<any>;
        private ValidateAndSend(validated, acceptanceInerrupt, $form);
        private ShowAcceptanceNotAllowedDlg(acceptanceInerrupt);
        protected Initialize(): void;
        protected SendRequest(form: any): Promise<void>;
        private UpdateIntervalManager(tasksIntervalsManager);
        private UpdateIntervalsView(tasksIntervalsManager);
        private disableSelection($el);
        private fixHelper(e, ui);
        private CompareTaskIntervals(a, b);
        private GetExistingPerformers(except?);
        private ChangeExecutionTypeEventHandler();
        private EditTaskIntervalEventHandler();
        private UpdateTaskInterval(changeDateInfo, currentTaskInterval, startDateControl, endDateControl, durationControl, rootElement);
        private EditTaskDescriptionEventHandler();
        private RemovePerformerEventHandler();
        private MoveUpPerformerEventHandler();
        private MoveDownPerformerEventHandler();
        private ChangePerformerEventHandler();
        private ChangePerformerResponseEventHandler();
        private CreateGroupTaskModelFromView();
    }
}
declare namespace WebClient.Cards {
    class TaskGroupCardView extends TaskCardView {
        constructor(widgetId: string);
    }
}
declare var tempPrivateKey: any;
declare namespace WebClient {
    /** @internal */
    interface ICryptoCertificate {
        /** Идентификатор сертификата (он же отпечаток). */
        Id: string;
        /** Отображаемое имя сертификата (с краткой информацией и сроком действия сертификата). */
        DisplayName: string;
        /** Дата, отражающая срок действия сертификата. */
        ExpirateDate: string;
        /** Кем серификат выпущен. */
        Issue: string;
        /** Название сертификата. */
        Name: string;
        /** Имеется ли приватный ключ. */
        hasPrivateKey: boolean;
        /** Действителен ли сертификат. */
        isValid: boolean;
        /** Действителен начиная с указанной даты. */
        validFromDate: Date;
        /** Срок действия до указанной даты. */
        validToDate: Date;
    }
    /** @internal */
    interface ICryptoCertificateInfo {
        /** Идентификатор сертификата */
        id: string;
        /** Отображаемое имя сертификата. */
        displayName: string;
    }
    /** @internal */
    enum SignatureItemType {
        MainFileSignaturePartType = 0,
        MainFileWithContentSignaturePartType = 1,
        DocumentFieldsSignaturePartType = 2,
        DocumentAttachmentsSignaturePartType = 3,
    }
    /** @internal */
    class Crypto {
        static LabelOIDAttirbute: string;
        static ProviderName: string;
        static ProviderType: string;
        static CADESCOM_CERT_INFO_TYPE_SUBJECT_SIMPLE_NAME: number;
        static CADESCOM_CERT_INFO_TYPE_ISSUER_SIMPLE_NAME: number;
        static CADESCOM_CURRENT_USER_STORE: number;
        static CADESCOM_MY_STORE: string;
        static CADESCOM_STORE_OPEN_MAXIMUM_ALLOWED: number;
        static CADESCOM_CERTIFICATE_FIND_SUBJECT_NAME: number;
        static CADESCOM_CERTIFICATE_FIND_SHA1_HASH: number;
        static CADESCOM_BASE64_TO_BINARY: number;
        static CADESCOM_CADES_BES: number;
        static CADESCOM_CADES_T: number;
        static CADESCOM_CADES_X_LONG_TYPE_1: number;
        static CADESCOM_ENCODE_BASE64: number;
        static CADESCOM_ENCODE_BINARY: number;
        static CADESCOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME: number;
        static CADESCOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION: number;
        static CADESCOM_ATTRIBUTE_OTHER: number;
        private static CertListContainerPrefix;
        /** @deprecated */
        static CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION: number;
        /** @deprecated */
        static CAPICOM_CERTIFICATE_FIND_SHA1_HASH: number;
        /** @deprecated */
        static CAPICOM_CERTIFICATE_FIND_SUBJECT_NAME: number;
        /** @deprecated */
        static CAPICOM_CERT_INFO_TYPE_ISSUER_SIMPLE_NAME: number;
        /** @deprecated */
        static CAPICOM_CERT_INFO_TYPE_SUBJECT_SIMPLE_NAME: number;
        /** @deprecated */
        static CAPICOM_CURRENT_USER_STORE: number;
        /** @deprecated */
        static CAPICOM_MY_STORE: string;
        /** @deprecated */
        static CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED: number;
        private widgetId;
        private widget;
        private certListElement;
        private static asyncCodeIncluded;
        private static asyncPromise;
        private static asyncResolve;
        constructor();
        static include_async_code(): void;
        static GetCertificateByThumbprint(thumbprint: any): Promise<string>;
        static GetCertificateInfoByThumbprint(thumbprint: any): Promise<ICryptoCertificateInfo>;
        private static GetCertificateByThumbprint_NPAPI(thumbprint);
        static CheckForPlugIn(): any;
        static SignFilesWithCertificate(encryptedInfo: EncryptedInfo, files: NodeListOf<Element>, cardId: string, signFields?: boolean, signAttachments?: boolean): Promise<any>;
        static SignFilesWithCertificateEx(encryptedInfo: EncryptedInfo, files: IFileSignInfo[], cardId: string, signFields?: boolean, signAttachments?: boolean, signType?: number, tspService?: string): Promise<any>;
        static CanAsync(): boolean;
        static SignData(encryptedInfo: EncryptedInfo, dataToSign: any, signType?: any, tspService?: any): any;
        private static Verify(sSignedMessage, dataToVerify);
        static GetCertsList(): Promise<ICryptoCertificate[]>;
        private static GetCertsList_NPAPI();
        private static CheckForPlugIn_NPAPI();
        private static GetBlobInBase64(href);
        static VerifySign(signHash: any, fileId: any): Promise<{}>;
        static GetPluginInfo(): any;
        static SetPluginInfo_NAPI(): void;
        private static SignData_NPAPI(encryptedInfo, dataToSign, signType?, tspService?);
    }
}
declare namespace WebClient {
    /** @internal */
    class Dashboard {
        static SaveLastUserFolder(folderId: string, folderName: string): void;
        static RemoveFromLastUserFolder(folderId: string): void;
        private static GetUserSettings();
    }
}
declare namespace WebClient {
    /** @internal */
    class FileSignOld {
        private static SignAllButton;
        private static SignLogButton;
        private filePanel;
        private crypto;
        private traceProvider;
        private interactionModel;
        constructor(filePanel: Element, interactionModel?: IFileSignOldInteractionModel);
        private Initialize();
        ShowSignDialog(item: HTMLElement, url: any, requestData: any): void;
        private AddSelectedSignatureRowEventHandler(rows, context);
        private ProcessSigns(dialog);
        private ShowSignLogDialog(item);
        private GetDialogParams(item);
        private ShowDialog(dialogParams, response);
        protected SignData(selectedThumbprint: string, dialog: ModalWindow): Promise<any>;
        private static AttachSign(dialog, encryptedInfo, interactionModel?);
        static ShowSignWarningDialog(okFunction: Function): void;
    }
}
declare namespace WebClient {
    /** Сервис для хранения загруженной информации о папках. */
    class Folders {
        private services;
        constructor(services: $LayoutFolderController & $Router & $LocalStorage);
        private LoadedFolderInfo;
        /** Зарегистрировать загруженную инфомрацию о папке. */
        registerFolderInfo(folderId: string, info: GenModels.FolderNode): void;
        /** Очистить сохраненные сведения для папки. */
        unregisterFolderInfo(folderId: string, info: GenModels.FolderNode): void;
        /** Возвращает загруженную ранее информацию о папке, если таковая присутствует в локальном хранилище. */
        getCachedFolderInfo(folderId: string): GenModels.FolderNode | undefined;
        /** Загружает или возвращает загруженную ранее информацию о папке. */
        getFolderInfo(folderId: any): JQueryDeferred<GenModels.FolderNode>;
        /** Возвращает идентификатор текущей папки, открытой в Web-клиенте. */
        getCurrentFolderId(): string | undefined;
        /** @internal */
        static SaveFolderSettings(folderId: any, settingName: any, value: any): void;
        /** @internal */
        static LoadFolderSetting(folderId: any, settingName: any): any;
    }
    /** Сервис для хранения загруженной информации о папках. */
    type $Folders = {
        folders: Folders;
    };
}
declare namespace WebClient {
    /** @internal */
    interface IFileCommentCallbacks {
        beforeAddCallback: (commentText: string) => JQueryDeferred<any>;
        beforeDeleteCallback: (commentId: string) => JQueryDeferred<any>;
        afterAddCallback: (commentText: string) => void;
        afterDeleteCallback: (commentId: string) => void;
    }
}
declare class JQueryDeferred<T> {
    constructor(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void);
}
declare namespace WebClient {
    /** Свойства для {@link ModalDialogHeader} */
    interface IModalDialogContentProps {
        /** Содержимое заголовка */
        children?: React.ReactNode;
        /** Пользовательский CSS-класс */
        className?: string;
    }
    /** Добавляет отступы и некоторые другие стили, обеспечивающие аккуратное отображение содержимого в ({@link ModalDialogBox}).
      *
      * Пример использования:
      *
      *     <ModalDialog isOpen={this.state.dialogOpen}>
      *         <ModalDialogBox defaultWidth={true}>
      *             <ModalDialogHeader>Dialog header</ModalDialogHeader>
      *             <ModalDialogContent>Dialog content</ModalDialogContent>
      *         </ModalDialogBox>
      *     </ModalDialog>
      */
    const ModalDialogContent: (props: IModalDialogContentProps) => JSX.Element;
}
declare namespace WebClient {
    /**
     * @internal
     * Свойства для {@link ScrollableModalDialog}
     */
    interface IScrollableModalProps {
        /** При смене значения на true модальное окно откроется, при смене в false - скроется. */
        isOpen: boolean;
        /** Вызывается при попытке закрыть модальное окно. */
        onClose?: () => void;
        /** Существует ли кнопка закрытия модального окна (крестик) */
        closeButtonDisabled?: boolean;
        header?: React.ReactNode;
        content?: React.ReactNode;
        buttons?: React.ReactNode;
        /** Максимальная высота, которая будет назначена если браузер - IE. В других браузерах будет работать flexbox.
         *  По умолчанию: 50vh */
        maxHeight?: string;
        headerClassName?: string;
        contentClassName?: string;
        buttonsClassName?: string;
    }
    /**
     * @internal
     * Представляет всплывающее окно со скроллящимся контентом.
     */
    class ScrollableModal extends React.Component<IScrollableModalProps, undefined> {
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class LayoutSearchParametrsDialog {
        private services;
        static SearchParametersDialogLayoutPosition: string;
        static LastSearchLocalStoragePrefix: string;
        constructor(services: $LayoutManager & $LayoutController & $LocalStorage);
        showDialog(searchId: string, layout?: GenModels.LayoutViewModel): JQueryDeferred<GenModels.SearchParameter[]>;
        getParameters(layout: Layout): GenModels.SearchParameter[];
        clearAll(layout: Layout): void;
        enableAll(layout: Layout): void;
        loadLastSearch(searchId: string, layout: Layout): void;
        saveLastSearch(searchId: string, layout: Layout): void;
    }
}
declare namespace WebClient {
    /** Сервис для работы с localStorage. */
    class LocalStorage {
        private services;
        private supportsLocalStorageCache;
        constructor(services: $BaseName & $CurrentEmployeeId);
        /** @deprecated Use service $LocalStorage */
        static SupportsLocalStorage(): boolean;
        /** @deprecated Use service $LocalStorage */
        static SaveData(id: string, obj: any): boolean;
        /** @deprecated Use service $LocalStorage */
        static LoadData(id: string): any;
        /** Поддерживает ли браузер localStorage. */
        supportsLocalStorage(): any;
        /** Сериализует из записывает значение в localStorage.
         *
         * Внимание, к ключу добавляется имя базы и идентификатор пользователя!
         * Для чтения значения используйте {@link getData}.
         */
        setData<T>(id: string, obj: T): boolean;
        /** Получает данные из localStorage и десериализует их.
         *
         * Внимание, к ключу добавляется имя базы и идентификатор пользователя!
         * Для записи значения используйте {@link getData}.
         */
        getData<T>(id: string): T;
        /** Записывает значение в localStorage.
         *
         * Внимание, к ключу добавляется имя базы и идентификатор пользователя!
         * Для чтения значения используйте {@link getItem}.
         */
        setItem(id: string, data: string): boolean;
        /** Возвращает значение из localStorage.
         *
         * Внимание, к ключу добавляется имя базы и идентификатор пользователя!
         * Для записи значения используйте {@link setItem}.
         */
        getItem(id: string): string;
        /** Удаляет значение из localStorage.
         *
         * Внимание, к ключу добавляется имя базы и идентификатор пользователя!
         * Для записи значения используйте {@link setItem}.
         */
        removeItem(id: string): void;
        /**
         * Преобразует ключ, добавляя к нему имя базы и идентификатор пользователя.
         *
         * Используется остальными методами сервиса. Необходим для исключения
         * конфликтов при одновременной работе с разными базами и разными пользователями.
         */
        transformId(id: string): string;
    }
    /** Сервис для работы с localStorage. */
    type $LocalStorage = {
        localStorage: LocalStorage;
    };
}
declare namespace WebClient {
    /** @internal */
    interface IModalStackItem {
        zIndex: number;
        onUpdate: (newZIndex: number) => void;
    }
    /**
     * Вспомогательный класс для работы с приоритетом модальных окон.
     * По умолчанию он уже используется в ModalBackdrop и ModalWindow,
     * поэтому интегрировать его самостоятельно обычно не требуется.
     *
     * Пример использования (регистрируемся при показе окна и убираем регистрацию при скрытии):
     *
     *     export interface IModalProps {
     *     }
     *
     *     export interface IModalState {
     *         zIndex: number;
     *     }
     *
     *     export class Modal extends React.Component<IModalProps, IModalState> {
     *         constructor(props) {
     *             super(props);
     *
     *             this.state = {
     *                 zIndex: ModalStack.DEFAULT_ZINDEX
     *             }
     *         }
     *
     *         componentDidMount() {
     *             if (this.props.visible) {
     *                 ModalStack.register(this, newZIndex => this.setState({ zIndex: newZIndex }));
     *             }
     *         }
     *
     *         componentWillReceiveProps(nextProps: IModalBackdropProps) {
     *             if (this.props.visible != nextProps.visible) {
     *                 if (nextProps.visible) {
     *                     ModalStack.register(this, newZIndex => this.setState({ zIndex: newZIndex }));
     *                 } else {
     *                     ModalStack.unregister(this);
     *                 }
     *             }
     *         }
     *
     *         componentWillUnmount() {
     *             ModalStack.unregister(this);
     *         }
     *
     *         render() {
     *             return (
     *                 <div style={{ zIndex: this.state.zIndex }}>Моё модальное окно</div>
     *             );
     *         }
     *     }
     *
     */
    class ModalStack {
        static readonly DEFAULT_ZINDEX: number;
        static lastZIndex: number;
        static data: Map<any, IModalStackItem>;
        static ModalRegistered: SimpleEvent<{}>;
        static ModalUnregistered: SimpleEvent<{}>;
        /**
         * Зарегистрировать модальное окно
         * @param modal Модальное окно
         * @param onUpdate Вызывается при перерасчёте zIndex компонента, здесь зарегистрированное модальное окно должно перерисовать себя.
         * @param updateAfterRegister Вызвать ли onUpdate сразу после регистрации или самому по-другому обработать
         * zIndex через вернувшееся значение из функции.
         */
        static register(modal: any, onUpdate: (newZIndex: number) => void, updateAfterRegister?: boolean): number;
        /**
         * Удалить указанное модальное окно
         * @param component Модальное окно
         * @returns Удалось ли удалить модальное окно
         */
        static unregister(modal: any): boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IModalWindowCreatorOptions {
        withoutAnimation?: boolean;
    }
    /** @deprecated Используйте {@link ModalDialog} или {@link MessageBox}. */
    class ModalWindow {
        private traceProvider;
        private params;
        private overlay;
        private modal;
        private modalHeader;
        private modalContent;
        private modalOkButton;
        private modalCancelButton;
        private modalCloseButton;
        private buttonsDiv;
        private content;
        private isOpened;
        events: ModalWindowEvents;
        static lastError: ModalWindow;
        constructor(params: ModalWindowParams);
        readonly IsOpened: boolean;
        readonly ModalElement: HTMLElement;
        readonly ModalContentElement: HTMLElement;
        readonly OkButtonElement: HTMLButtonElement;
        readonly CancelButtonElement: HTMLButtonElement;
        Show(withoutAnimation?: boolean): void;
        Hide(whithCallbacks?: boolean, withoutAnimation?: boolean): void;
        HideOverlay(): void;
        private Initialize();
        private CreateOverlay();
        private CreateModal();
        private CreateModalContent();
        private CreateModalCloseButton();
        private CreateModalHeader();
        private CreateModalButtonsDiv();
        private CreateModalOkButton();
        private CreateModalButton(btn);
        private CreateModalCancelButton();
        private Destroy();
        static ShowErorDialog(message: string, options?: IModalWindowCreatorOptions): ModalWindow;
        static ShowConfirmDialog(message: string, yesButton?: Function, cancelButton?: Function, options?: IModalWindowCreatorOptions): ModalWindow;
        static ShowInformationDialog(message: string, headerText?: string, options?: IModalWindowCreatorOptions): ModalWindow;
        static ShowWarningDialog(message: string, headerText?: string, okButton?: Function, cancelButton?: Function, options?: IModalWindowCreatorOptions): ModalWindow;
    }
}
interface String {
    format: (...codes: any[]) => string;
    contains: (substr: string) => boolean;
}
interface Array<T> {
    equals: (array: any) => boolean;
    containsArrayElement: (element: T) => number;
}
declare function UploadFile(formName: Element, filesContainer: string, onSuccess: Function, onFileAdded: Function, dropZoneId: string, onFileRemoved?: (documentId: string) => void): void;
declare function CreateTaskIntervalManager(): TaskIntervalManager;
declare function CreateTaskInterval(): TaskInterval;
declare function CheckForPlugIn_Async(): Promise<any>;
declare function GetCertsList_Async(): any;
declare function GetCertificateInfoByThumbprint_Async(thumbprint: any): any;
declare function GetCertificateByThumbprint_Async(thumbprint: any): any;
declare function SignData_Async(certThumbprint: any, dataToSign: any, signType?: any, tspService?: any): any;
declare function SignCadesEnhanced_Async(encryptedInfo: any, dataToSign: any, signType: any): any;
declare function Verify_Async(sSignedMessage: any, dataToVerify: any): any;
declare function SetPluginInfo_Async(): void;
declare var cadesplugin: any;
declare var iNoBounce: any;
declare function HackTouch(): any;
declare namespace WebClient {
    /** @internal */
    class NewCardDialog {
        static AddNewItemEventClick(buttonId: string): void;
        private static GetItemKindsEventClick(button, parentModal, onClose);
        private static GetRoute(cardType, href, kindId, folderId, createInFolder, isLayoutAvailable, isTemplate);
    }
}
declare namespace WebClient {
    /** Формирует страницу, информирующую пользователя о том что ресурс не найден. */
    class NotFoundPage {
        private readonly MIN_IMAGE_HEIGHT;
        /** Сформировать html-разметку страницы. */
        render(): HTMLElement;
        /** @internal */
        protected handleImageVisibility($imageWrapper: JQuery, $image: JQuery): void;
    }
}
declare namespace WebClient {
    /** Реализация роутинга в Web-клиенте. */
    class Router {
        private services;
        private sammy;
        private requestData;
        private searchPanel;
        private currentRouteInfo;
        private currentRouteInfoChangedEvent;
        private traceProvider;
        private routeHandlers;
        private pendingRouteTypeMappers;
        private routeTypeMappers;
        static MainContentElementId: string;
        private static MainContentElementDefaultClasses;
        private static NewCardRoutePartName;
        private static CardViewRoutePartName;
        private static CardEditRoutePartName;
        private static ExtendedLayoutRoutePartName;
        private mainContentChangingListeners;
        private runHandlersUpdate;
        private runHandlersWorking;
        private internalLocationUpdate;
        private lastRouteProcessing;
        private lastSetMainContentProcessing;
        private currentRouteProcessingMapper;
        private currentUnmountingRoute;
        /**
         * Please, don't use it. Really.
         */
        private currentUrl;
        private isReplacingUrlWithoutNotification;
        static CurrentRouteStoreKey: string;
        static RouterInitialization: IBasicEvent<void>;
        constructor(services: $SearchPanel & $EnableRouterLogging);
        /** @internal */
        readonly dangerouslyUrl: string;
        /** @internal */
        addHandler<T>(routeType: RouteType, handler: IRouteHandler<T>): void;
        /** @internal */
        removeHandler<T>(routeType: RouteType, handler: IRouteHandler<T>): void;
        /** @internal */
        getHandlers<T>(routeType: RouteType): IRouteHandler<T>[];
        /** @internal */
        addRouteTypeMapper(mapper: IRouteTypeMapper<any>): void;
        /** @internal */
        getCurrentRoute<T>(): IRouteInfo<T>;
        /** @internal */
        setCurrentRoute<T>(info: IRouteInfo<T>): void;
        /** @internal */
        readonly currentRouteInfoChanged: IBasicEvent<IRouteInfo<any>>;
        private onCurrentRouteInfoChanged();
        private runHandlers(routeInfo);
        private runHandlersWith(handlers, method, routeInfo);
        private reportError(err, showError?);
        private shutdownCurrentRoute();
        private processRoute(sammyContext, mapper);
        private processRouteImpl(sammyContext, mapper, prevProcessing);
        private unmountCurrentRoute();
        private getPathFromRouteMapper(routeInfo);
        private updateUrl<T>(routeInfo);
        /**
         * Открыть страницу по указанному адресу в Web-клиенте.
         * @param route Адрес, начинающийся с символа решетки.
         */
        goTo(route: string, refresh?: boolean, callback?: Function): Promise<void>;
        /** Возвращает текущий адрес (без домена). */
        GetLocation(): string;
        /** Возвращает полный адрес на основе значения, возвращенного {@link GetLocation}. */
        getLocationFromRoute(route: string): string;
        /** @deprecated */
        goToRoute(context: any): void;
        /** @deprecated Используйте {@link DashboardRouteHelpers.goToDashboard} */
        goToDashboard(context: any): void;
        /** Перезагружает текущий роут Web-клиента. */
        refresh(callback?: Function): Sammy.Application;
        /** @internal */
        LoadContent(url: string, requestData: any, contentElement: HTMLElement, showOverlay?: boolean, callback?: Function): void;
        /** @internal */
        LoadMainContent(url: string, requestData: any, showOverlay?: boolean, get?: boolean, callback?: (isError?: boolean) => void): void;
        /** @internal */
        private LoadMainContentProcessResponse(url, response, callback?);
        /** @internal */
        LoadContnentFromRoute(cardId: any): JQueryDeferred<any>;
        /** Устанавливает основное содержимое Web-клиента. */
        SetMainContentElement(elem: HTMLElement, doneCallback?: Function, newContentCssClass?: string): JQueryDeferred<void>;
        /** Устанавливает основное содержимое Web-клиента. */
        SetMainContentHtml(html: string, doneCallback?: Function, newContentCssClass?: string): JQueryDeferred<any>;
        /** Уведомляет подписчиков об изменении основного содержимого. */
        PrepareMainContentChange(): JQueryDeferred<any>;
        /** Регистрирует подписчика на событие изменения основного содержимого. */
        AddMainContentChangingListener(listener: () => JQueryDeferred<any>): void;
        /** Отменяет регистрацию подписчика на событие изменения основного содержимого. */
        RemoveMainContentChangingListener(listener: () => JQueryDeferred<any>): void;
        /** Вызывает addEventListener для главного элемента содержимого Web-клиента. */
        AddMainContentEventListener(eventType: string, listener: EventListenerOrEventListenerObject, useCapture?: boolean): void;
        RemoveMainContentEventListener(eventType: string, listener?: EventListenerOrEventListenerObject, useCapture?: boolean): void;
        private CardLayoutsUrlCheck(url);
        private LayoutUrlCheck(url);
        private LoadData(url, requestData, showOverlay, get, callback, customErrorCallback?);
        private SetContent(contentElement, html);
        private OnMainContentChanging();
        private ClearAndGetMainContent();
        private renderMainContentLoader(mainContent);
        /** Скрывает загрузчик приложения. */
        static HideMainLoader(): void;
        /** @internal */
        LoadCardContent(uri: string): void;
        /** Устанавливает общий стиль Web-клиента на основе настроек типа карточки. */
        SetTopPanelCardStyle(cardTypeWeb: GenModels.CardTypeWeb): void;
        private ClearFromFolderView();
        private showNotFound();
        /**
         * Меняет URL без оповещения об этом (т.е. привязанные на адреса обработчики не сработают)
         */
        replaceUrlWithoutNotification(url: string): void;
        /** @internal */
        initialize(): void;
        private log(...args);
    }
    /** Синоним {@link Router}. */
    type SammyHelper = Router;
    /** Синоним {@link Router}. */
    const SammyHelper: typeof Router;
    /** Сервис роутинга в Web-клиенте. */
    type $Router = {
        router: Router;
    };
}
/** @internal */
declare var cardLayoutPreloadingInProgress: boolean;
/** @internal */
declare var cardLayoutPreloadingCompleteCallback: (response?: any) => void;
/** @internal */
declare var preloadedCardLayout: any;
/** @internal */
declare var cardLayoutPreloadingUrl: string;
declare namespace WebClient {
    /** @internal */
    class SelectCertificateDialog {
        private selectedThumbprint;
        private okButtonFunction;
        private dialogParamsContainer;
        private isSimpleSign;
        private defaultPersonalThumbprint;
        private url;
        private traceProvider;
        constructor(url: string, dialogParamsContainer: HTMLElement);
        ShowDialog(requestData?: any, additionalParams?: Partial<ModalWindowParams>): void;
        readonly SelectedThumbprint: string;
        readonly IsSimpleSign: boolean;
        OkDialogButton: Function;
        ShowSelectCertificateDialog(container: HTMLElement): void;
        private readonly DefaultPersonalThumbprint;
        private GetDialogParams();
        private SetSelectedCertificateDisplayName(element, certificate);
        private SetSingInfoMessage(container, message);
        private FillTableRow(certificate);
        private GetSelectCertificateDialogParams(widget);
        private CheckPersonalCertificate();
        private AddRowHandlers(dialog);
    }
}
declare namespace WebClient {
    /** Генерирует страницу, уведомляющую пользователя о том что содержимое не может быть отображено из-за ошибки. */
    class ServerErrorPage {
        errorMessage: string;
        private readonly MIN_IMAGE_HEIGHT;
        constructor(errorMessage?: string);
        /** @internal */
        getFilteredErrorMessage(): string;
        /** Формирует разметку страницы. */
        render(): HTMLElement;
        /** @internal */
        protected handleImageVisibility($imageWrapper: JQuery, $image: JQuery): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class SessionExpiredHandler implements IRouteHandler<IFolderRouteData> {
        static SuspednedMessageType: string;
        static AwokenMessageType: string;
        static DisposedMessageType: string;
        static CreatedMessageType: string;
        static PauseNotificationsMessageType: string;
        static ContinueNotificationsMessageType: string;
        static readonly SessionInactiveMessageHide: boolean;
        protected popupNotification: Noty;
        protected notificationsPaused: boolean;
        name: string;
        constructor();
        unmountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<any>;
        protected onSessionDisposed: () => void;
        protected onSessionCreated: () => void;
        protected onSessionAwoken: () => void;
        protected onSessionSuspended: () => void;
        protected onSessionNotificationsPaused: () => void;
        protected onSessionNotificationsContinued: () => void;
        protected showSessionInactiveMessage: () => void;
        protected restoreSession: () => JQueryDeferred<any>;
    }
}
declare namespace WebClient {
    /** Сервис доступа к идентификатору текущего пользователя. */
    type $CurrentEmployeeId = {
        currentEmployeeId: string;
    };
    /** Сервис доступа к логину текущего пользователя. */
    type $CurrentEmployeeAccountName = {
        currentEmployeeAccountName: string;
    };
    /** Сервис информации о типе устройства, в котором открыт Web-клиент. */
    type $DeviceType = {
        deviceType: GenModels.DeviceType;
        defaultDeviceType: GenModels.DeviceType;
    };
    /** Сервис доступа к временной метке запуска сервера. */
    type $ApplicationTimestamp = {
        applicationTimestamp: number;
    };
    /** Сервис доступа к адресу сайта. */
    type $SiteUrl = {
        siteUrl: string;
    };
    /** Сервис доступа к текущей локали Web-клиента. */
    type $Locale = {
        locale: string;
    };
    /** Сервис доступа к настройке полнотекстового поиска. */
    type $FullTextSearchEnabled = {
        fullTextSearchEnabled: boolean;
    };
    /** Сервис получения информации плагине КриптоПро. */
    type $InstalledCSP = {
        installedCSP: boolean;
    };
    /** Сервис информации об имени базы, с которой работает Web-клиент. */
    type $BaseName = {
        baseName: string;
    };
    /** Настройка из web.config - включено ли логирование клиентского роутинга. */
    type $EnableRouterLogging = {
        enableRouterLogging: boolean;
    };
    /** Стандартные сервисы Web-клиента. */
    type $StandardServices = $Layout & $Router & $CurrentEmployeeId & $CurrentEmployeeAccountName & $DeviceType & $SiteUrl & $Locale & $FullTextSearchEnabled & $RequestManager & $Sidebar & $FolderViews & $SearchPanel & $NavBar & $Folders & $UnreadCounter & $InstalledCSP & $ApplicationTimestamp & $LayoutManager & $RealtimeCommunicationService & $UserMenu & $LayoutControlFactory & $EditOperationStore & $LayoutInfo & $CardInfo & $CardId & $ControlStore & $LocalStorage & $BaseName & $EnableRouterLogging;
}
declare namespace WebClient {
    /** @deprecated */
    class TraceProvider {
        private static GetTraceSetting();
        static Enabled: boolean;
        private static traceObjects;
        private GetLoggableFunction(func, name);
        AddToTrace(namespaceObject: any): void;
        private static GetClassName(obj);
    }
}
declare namespace WebClient {
    /** @internal */
    class TrackCardChanges {
        private traceProvider;
        constructor();
        static OnCardChanged(ownerCardId: any): void;
        static GetLinkedCardIds(): Array<string>;
        static GetMainCardId(): string;
        static RefreshPage(): void;
        static GetCurrentEmployee(): string;
    }
}
declare namespace WebClient {
    /** @internal */
    class UserMenu {
        private services;
        private userMenu;
        private userMenuButton;
        private aboutButtons;
        private exitButtons;
        private traceProvider;
        private hideHandler;
        constructor(services: $RealtimeCommunicationService);
        Show(): void;
        UserModal: ModalWindow;
        private Initialize();
        private CloseMenu();
        private onRouteChanges();
        private AddUserMenuButtonEventClick();
        private AddAboutButtonEventClick();
        private AddExitButtonEventClick();
        private AddSidebarUserMenuEventClick();
    }
    /** @internal */
    type $UserMenu = {
        userMenu: UserMenu;
    };
}
declare namespace WebClient {
    /** @deprecated */
    class CardInfoModel {
        CadId: string;
        Timestamp: string;
    }
}
declare namespace WebClient {
    /** @deprecated */
    enum CardType {
        Document = 0,
        Task = 1,
        GroupTask = 2,
        Unknown = 4,
    }
}
declare namespace WebClient {
    /** @deprecated */
    class DateTimeFormat {
        Date: string;
        Time: string;
        readonly DateTime: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class EncryptedInfo {
        private thumbprint;
        private attirbutes;
        private signedFiles;
        constructor(thumbprint: string);
        readonly Thumbprint: string;
        readonly Attirbutes: Array<EncryptedAttribute>;
        SignedFiles: any;
    }
    /** @internal */
    class EncryptedAttribute {
        private name;
        private value;
        private oid;
        constructor(oid: string, value: string);
        readonly Oid: string;
        readonly Name: string;
        readonly Value: string;
    }
}
declare namespace WebClient {
    /** @internal */
    enum ErrorNotificationType {
        Success = 0,
        Warning = 1,
        Error = 2,
    }
}
declare namespace WebClient {
    /** @deprecated */
    class FolderUnreadRequest {
        Id: string;
        Type: string;
        Count: string;
        SearchId: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class GroupTaskCardUpdateModel {
        AuthorId: string;
        AuthorName: string;
        TaskGroupId: string;
        PerformerId: string;
        Name: string;
        Description: string;
        StartDate: string;
        EndDate: string;
        ControlDate: string;
        Duration: string;
        ExecutionType: string;
        OnControl: boolean;
        ControllerId: string;
        ControlHour: string;
        RequiresAcceptance: boolean;
        IsNew: boolean;
        Timestamp: string;
        KindId: string;
        IsStartTask: boolean;
        ParentCardKey: ParentCardKey;
        DocumentsId: Array<string>;
        PerformerSettingUpdateModels: Array<PerformerSettingUpdateModel>;
    }
    class ParentCardKey {
        CardId: string;
        CardTypeId: string;
    }
    class PerformerSettingUpdateModel {
        PerformerId: string;
        StartDate: string;
        EndDate: string;
        Duration: string;
        Description: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFileSignOldInteractionModel {
        documentId: string;
        getTimestamp: () => number;
        setTimestamp: (timestamp: number) => void;
        getFiles: () => IFileSignInfo[];
        signButton: HTMLElement;
        viewSignButton: HTMLElement;
        beforeSignCallback: () => JQueryDeferred<any>;
        beforeViewSignCallback: () => JQueryDeferred<any>;
        afterSignCallback: Function;
        afterViewSignCallback: Function;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFileSignInfo {
        fileId: string;
        versionId: string;
        fileCardId: string;
    }
}
declare namespace WebClient {
    /** @internal */
    enum ModalWindowType {
        Info = 0,
        Warning = 1,
        Error = 2,
        Default = 3,
    }
}
declare namespace WebClient {
    /** @internal */
    class NavigatorFolderRequest {
        private folderId;
        private folderType;
        constructor(id: string, folderType: NavigatorFolderType);
        readonly FolderId: string;
        readonly FolderType: NavigatorFolderType;
    }
}
declare namespace WebClient {
    /** @internal */
    enum NavigatorFolderType {
        UserFolder = 0,
        ServiceFolder = 1,
    }
}
declare namespace WebClient {
    /** @internal */
    enum RequestReadyStateType {
        Unitialized = 0,
        Loading = 1,
        Loaded = 2,
        Interactive = 3,
        Complete = 4,
    }
}
declare namespace WebClient {
    /** @internal */
    class StorageSetting {
        Name: string;
        Value: any;
    }
}
declare namespace WebClient {
    /** @internal */
    class ViewFilterSetting {
        private id;
        currentPage: number;
        sortingColumn: string;
        sortIsDesc: boolean;
        constructor();
    }
}
declare namespace WebClient {
    /** @internal */
    class DefaultRouteHandlers {
        static registerAll(sammy: Router): void;
    }
}
declare namespace WebClient {
    /** Тип роута - это строка. */
    type RouteType = keyof StandardRoutes | string;
}
declare namespace WebClient {
    /** Стандартные роуты Web-клиента. */
    class StandardRoutes {
        /** Специальный системный ключ, соответствующий всем роутам. */
        static AllRoutes: string;
        /** Роут папки  Docsvision. */
        static Folder: string;
        /** Пользовательская страница. */
        static CustomPage: string;
        /** Пользовательская страница на основе разметок. */
        static LayoutPage: string;
        /** Страница полнотекстового поиска. */
        static SearchResult: string;
        /** Домашняя страница. */
        static Dashboard: string;
        /** Страница последних карточек. */
        static RecentCards: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class ServerController {
        protected services: $RequestManager;
        constructor(services?: $RequestManager);
        /** @notest */
        protected getServices(): $RequestManager;
        protected postAction(args: IArguments): JQueryDeferred<any>;
        protected getAction(args: IArguments): JQueryDeferred<any>;
        protected prepareRequest(args: IArguments, method: RequestMethods): IRequestInfo;
        protected sendRequest(requestInfo: IRequestInfo): JQueryDeferred<any>;
        private findMetadataObject(args);
        private isMetadataObject(x);
    }
    function controllerFactory<T>(ctor: {
        new (services: $RequestManager): T;
    }): (services: any) => T;
}
declare namespace WebClient {
    class DocumentCardController extends ServerController {
        GetSignature(documentId: string): JQueryDeferred<ISignatureDataModel>;
        GetSignatures(documentId: string): JQueryDeferred<ISignatureListDataModel>;
        protected sendRequest(requestInfo: IRequestInfo): JQueryDeferred<any>;
    }
    type $DocumentCardController = {
        documentCardController: DocumentCardController;
    };
}
declare namespace WebClient {
    /** @deprecated */
    class EmployeesController extends ServerController {
        /** @deprecated */
        Find(term: string, kindId: string, count?: number, unitId?: string): JQueryDeferred<IFindEmployeeResult>;
    }
    type $EmployeesController = {
        employeesController: EmployeesController;
    };
}
declare namespace WebClient {
    class FileController extends ServerController {
        GetFilePreviewModel(model: IGetFilePreviewModelParams): JQueryDeferred<IFilePreviewModel>;
        GetDownloadUrl(fileId: string, fileName: string): string;
        GetUploadFilesUrl(): string;
    }
    type $FileController = {
        fileController: FileController;
    };
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Panel]{@link Panel}.
     */
    class PanelParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Ширина панели в процентах */
        width?: number;
        /** Минимальная ширина панели в пикселях */
        minWidth?: number;
        /** Порядок панели */
        order?: number;
        /** Дочерние контролы */
        childControls?: LayoutControl[];
    }
    /**
     * Базовый  класс для элементов управления, содержащих дочерние элементы управления.
     */
    abstract class Panel<P extends PanelParams, S extends PanelState> extends BaseControl<P, S> {
        constructor(props: P);
        /**
         * Позволяет проверить, является ли контрол панелью
         */
        isPanel(): boolean;
        /** @internal */
        protected childrenHandler: any;
        private readonly childControls;
        /** Регистрирует контрол, так что он становится доступен в {@link PanelParams.childControls}.
         *  Автоматически вызывается дочерними контролами. */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** Выполняет операцию, обратную {@link registerChild}. */
        protected unregisterChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        init(): void;
        /**
         * Подготавливает собственные значения и значения всех дочерних контролов для отправки на сервер.
         * Метод вызывает {@link getBindings} для получения значений.
         * @param withChildren Включать в результат значения дочерних контролов или нет.
         */
        getBindingsWriteRequests(withChildren?: boolean): IBindingsWriteRequest[];
        /**
         * Проверяет корректность значения элемента управления.
         *
         * К примеру, если у элемента управления с флагом "обязательный" отсутствует значение,
         * валидация не будет пройдена (см. {@link InputBasedControl}). При этом можно показать предупреждающее сообщение.
         * @param params Параметры выполнения валидации. Например, показывать ли сообщение о неудаче в UI или нет.
         */
        validate(params: any): IValidationResult[];
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Отправка на ознакомление]{@link AcquaintanceManagement}.
     */
    class AcquaintanceManagementParams extends PanelParams {
        /** Текст кнопки отправки на ознакомление */
        sendAcquaintanceButtonText?: string;
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Флаг доступности отправки на ознакомление */
        canSend?: boolean;
        /** Событие возникает при открытии панели отправки на ознакомление. */
        opening?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после открытия панели отправки на ознакомление. */
        opened?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при закрытии панели отправки на ознакомление. */
        closing?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после закрытия панели отправки на ознакомление. */
        closed?: BasicApiEvent<IEventArgs>;
        /** Сервисы. */
        services?: $LayoutDocumentController & $CardId & $EditOperationStore;
    }
    /**
     * Класс элемента управления Отправка на ознакомление.
     */
    class AcquaintanceManagement extends Panel<AcquaintanceManagementParams, AcquaintanceManagementState> {
        constructor(props: AcquaintanceManagementParams);
        protected createParams(): AcquaintanceManagementParams;
        /** @internal */
        protected binding: IBindingResult<boolean>;
        protected createImpl(): AcquaintanceManagementImpl;
    }
}
declare namespace WebClient {
    /** Базовый интерфейс, для описания состояния контролов, наследующихся от {@link BaseControlImpl} */
    type BaseControlImplState = BaseControlState;
    /**
     * Базовый класс для реализации контролов Web-клиента.
     * Реализация контрола содержит логику, без привязки к окружению (взаимодействие с сервером, с разметкой и т.д.).
     * Реализация используется основным, 'интерфейсным' классом контрола, наследующимся от {@link BaseControl}, который обеспечивает связь
     * контрола с внешним миром.
     *
     * @param P Класс или интерфейс, наследующийся от {@link BaseControlParams} и описывающий параметры компонента реализации.
     * @param S Интерфейс, расширяющий {@link BaseControlImplState} и описывающий внутренние переменные компонента реализации.
     */
    abstract class BaseControlImpl<P extends BaseControlParams, S extends BaseControlImplState> extends React.Component<P, S> {
        /** @internal */
        protected componentDOMNode: Element;
        private propertyHandlers;
        private changedParams;
        private newStyleControlImpl;
        /**
         * Инициализирует объект.
         *
         * В конструкторе необходимо создать объекты событий. Например:
         *
         *     this.state.inPlaceEditOpeninig = CancelableEvent.Create(this.state.wrapper);
         *     this.state.inPlaceEditOpened = SimpleEvent.Create(this.state.wrapper);
         *
         * **Внимание!** Значения свойств контрола (`props`) автоматически копируются в `state` в методе `componentDidMount`
         * (при помощи {@link setParamValue}), который вызывается после того, как конструктор завершил выполнение.
         * Соответственно, в теле конструктора значения в `state` еще недоступны, и нужно обращаться к `props`.
         *
         * ** Внимание!** При вызове конструктора объект `this.props` еще недоступен, необходимо обращаться к параметру `props`.
         *
         * @param props Параметры, переданные компоненту.
         */
        constructor(props: P, state?: S);
        protected onFocusedKeyDown(event: React.KeyboardEvent<any>, handler: () => void): void;
        /**
         * Производится обнаружение и регистрация всех свойств, объявленных с декоратором {@link handler}.
         */
        protected registerPropHandlers(): void;
        /**
         * При переопределении в дочерних классах, должен содержать логику отрисовки контрола. Например:
         *
         *     renderControl() {
         *          return <span> {this.state.text} </span>
         *     }
         */
        protected abstract renderControl(): any;
        setState<K extends keyof S>(state: ((prevState: Readonly<S>, props: P) => (Pick<S, K> | S)) | (Pick<S, K> | S), callback?: () => void): void;
        forceUpdate(callback?: () => void): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentDidMount(): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentWillUnmount(): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentWillMount(): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentWillReceiveProps(nextProps: P, nextContext: any): void;
        /**
         * Данный метод вызывается из {@link BaseControl.getParamValue}.
         *
         * По умолчанию реализуется следующая логика:
         * 1. Если объявлено get-свойство с декоратором {@link handler}, то возвращается значение данного свойства;
         * 2. Иначе возвращается значение из `state`.
         * @param paramName Имя параметра, значение которого необходимо получить
         */
        getParamValue(paramName: string): any;
        prepareSetParamValue(propName: string): void;
        /**
         * Обработчик, вызываемый всякий раз, когда установливается значение параметра.
         * Происходить это может в следующих случаях:
         * 1. При инициализации компонента (из метода `componentWillMount`).
         * 2. При получении новых props компонента (из метода `componentWillReceiveProps`). Как правило, новые свойства
         *    передаются интерфейсным компонентом при вызове {@link BaseControl.setParamValue}.
         *
         * Метод Реализует следующую логику:
         * 1. Если объявлено set-свойство с декоратором {@link handler}, то возвращается значение данного свойства;
         * 2. Иначе устаналивается значение в `state`.
         * @param paramName Имя параметра, значение которого нужно установить.
         * @param value Значение параметра
         * @param initial Значение истино, если метод вызывается при инициализации компонента (из componentWillMount).
         */
        setParamValue(propName: string, newVal: any, initial: boolean): void;
        /** Обработчик события `click` по области контрола. Генерирует событие {@link BaseControlParams.click}. */
        protected handleClick(event: React.MouseEvent<any>): void;
        /** Обработчик события `mouseover` в области контрола. Генерирует событие {@link BaseControlParams.mouseOver}. */
        protected handleMouseOver(event: React.MouseEvent<any>): void;
        /** Обработчик события `mouseout` в области контрола. Генерирует событие {@link BaseControlParams.mouseOut}. */
        protected handleMouseOut(event: React.MouseEvent<any>): void;
        /** Обработчик события `focus`. Генерирует событие {@link BaseControlParams.focus}. */
        protected handleFocus(event: React.FocusEvent<any>): void;
        /** Обработчик события `blur`. Генерирует событие {@link BaseControlParams.blur}. */
        protected handleBlur(event: React.FocusEvent<any>): void;
        /** Формирует список классов для основного html-тэга контрола. */
        protected getCssClass(): string;
        /**
         * Формирует словарь стилей для основного html-тэга контрола
         * см. [документацию React](https://facebook.github.io/react/docs/dom-elements.html#style)
         */
        protected getCssStyle(): React.CSSProperties;
        /**
         * Возвращает 0 если {@link BaseControlParams.tabStop} == true, и -1 в противном случае. По умолчанию данный метод не используется,
         * он может быть использован производным классом при отрисовке интерактивных элементов.
         */
        getTabIndex(): 0 | -1;
        /**
         * Возвращает полное наименование внутреннего контрола, которое следует передать
         * при его отрисовке в функции Render.
         * @param innerControlName наименование внутреннего контрола
         */
        protected getInnerControlFullName(innerControlName: string): string;
        /**
         * Выполняет отрисовку главного html-тега контрола, внутрь которого помещается содержимое параметра.
         * @param controlContent Обычно результат вызова {@link renderControl}
         */
        renderControlRoot(controlContent: any): JSX.Element;
        /**
         * Основной метод, выполняющий отрисовку контрола.
         * Возвращает результат вызова {@link renderControlRoot}, передавая ему параметром результат вызова {@link renderControl}.
         */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Класс состояния {@link Panel}. */
    interface PanelState extends BaseControlState, PanelParams {
        /** @internal */
        mountedChildren: BaseControl<any, any>[];
        /** @internal */
        childControlsModels: GenModels.ControlModel[];
    }
    /** @deprecated */
    type PanelImplState = PanelState;
    /** Класс реализации {@link Panel}. */
    abstract class PanelImpl<P extends PanelParams, S extends PanelState> extends BaseControlImpl<P, S> {
        constructor(props: P, state?: S);
        /** Метод, который производные классы должны вызывать для отрисовки дочерних компонентов. */
        protected renderChildren(children?: GenModels.ControlModel[]): React.ReactNode[];
        /** Инициализирует служебные свойства (такие как parent и services). Вызывается автоматически при присвоении значения параметру  */
        protected prepareChildren(children?: GenModels.ControlModel[]): void;
        /** Инициализирует служебные свойства (такие как parent и services). */
        preparePanelChildren(children?: GenModels.ControlModel[]): void;
        /** Добавляет реализацию параметров width и minWidth. */
        protected getCssStyle(): React.CSSProperties;
        /** Добавляет класс `system-panel`. */
        protected getCssClass(): string;
        /** @deprecated */
        children: any[];
    }
}
declare namespace WebClient {
    interface AcquaintanceManagementState extends AcquaintanceManagementParams, PanelState {
        cardId: string;
        children: GenModels.ControlModel[];
        lastLoading: JQueryDeferred<GenModels.ControlModel[]>;
        isOpened: boolean;
        receivers: MultipleEmployees;
        considerationDate: DateTimePicker;
        loading: boolean;
    }
    /** @internal */
    type AcquaintanceManagementImplState = AcquaintanceManagementState;
    type AcquaintanceManagementImplProps = AcquaintanceManagementState;
    /** @internal */
    class AcquaintanceManagementImpl extends PanelImpl<AcquaintanceManagementParams, AcquaintanceManagementState> {
        constructor(props: AcquaintanceManagementParams, state: AcquaintanceManagementState);
        open(): void;
        close(): void;
        readonly isOpened: boolean;
        attachReceivers(control: any): void;
        attachConsiderationDate(control: any): void;
        onMainButtonClick(): void;
        onSendClick(): void;
        onCancelClick(): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Ход согласования]{@link AgreementHistory}.
     */
    class AgreementHistoryParams extends BaseControlParams {
        /** Текст, отображаемый на кнопке открытия хода согласования.*/
        buttonText: string;
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Возвращает состояние окна хода согласования: `true` - окно с ходом согласования открыто, `false` - закрыто. */
        isReportShown?: boolean;
        /**
         * Определяет, возможно ли показать ход согласования:
         * `true` - возможно (элемент управления связан с данными и разрешена настроенная операция редактирования),
         * `false` - невозможно.
         */
        showReportAllowed?: boolean;
        /** @review Режим контрола */
        agreementHistoryMode?: GenModels.AgreementHistoryMode;
        /** @review Всплывающая подсказка для кнопки */
        tip?: string;
        /** Событие возникает при открытии окна хода согласования. */
        approvingReportOpening?: CancelableApiEvent<IApprovingReportOpeningEventArgs>;
        /** Событие возникает при закрытии окна хода согласования. */
        approvingReportClosing?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает при обновлении данных хода согласования. */
        approvingReportRefreshing?: CancelableApiEvent<IApprovingReportRefreshingEventArgs>;
        /** Событие возникает после открытия окна хода согласования. */
        approvingReportOpened?: BasicApiEvent<IApprovingReportOpenedEventArgs>;
        /** Событие возникает после закрытия окна хода согласования. */
        approvingReportClosed?: BasicApiEvent<IEventArgs>;
        /** Событие возникает после обновления данных хода согласования. */
        approvingReportRefreshed?: BasicApiEvent<IApprovingReportRefreshedEventArgs>;
        /** Сервисы. */
        services?: $FileController & $LayoutAgreementController & $EditOperationStore;
    }
    /**
     * Класс элемента управления Ход согласования.
     *
     * Добавляет в web-разметку кнопку, при нажатии которой открывается окно просмотра хода согласования.
     */
    class AgreementHistory extends BaseControl<AgreementHistoryParams, AgreementHistoryState> {
        protected createParams(): AgreementHistoryParams;
        private readonly myControlImpl;
        private agreementHistoryData;
        private agreementHistoryRows;
        private binding;
        /** Открывает окно просмотра хода согласования */
        showReport(): void;
        /** Закрывает окно просмотра хода согласования. */
        hideReport(): void;
        /**
         * Проверяет возможность показа окна хода согласования.
         *
         * @return true - возможно (если данные для отображения доступны и операция разрешена), false - невозможно.
         */
        canShowReport(): void;
        /** Загружает с сервера новые данные по ходу согласования и обновляет содержимое окна просмотра хода согласования. */
        refreshReport(): void;
        /** Показан ли отчёт. */
        readonly isReportShown: boolean;
        /** @internal */
        protected createImpl(): AgreementHistoryImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface AgreementHistoryState extends BaseControlState, AgreementHistoryParams {
        model: GenModels.AgreementHistoryDataModel;
        rows?: GenModels.ApprovalHistoryViewModel;
        dialog: ModalWindow;
        isHistoryDataReceived: boolean;
        loading: boolean;
        lastLoadedData: GenModels.ApprovalHistoryViewModel;
    }
    /** @internal */
    type AgreementHistoryImplState = AgreementHistoryState;
    /** @internal */
    type AgreementHistoryImplProps = AgreementHistoryState;
    /** @internal */
    class AgreementHistoryImpl extends BaseControlImpl<AgreementHistoryParams, AgreementHistoryImplState> {
        /** @internal */
        constructor(props: AgreementHistoryParams, state: AgreementHistoryState);
        /** �������� �����. */
        showReport(): void;
        /** �������� �����. */
        hideReport(): void;
        /** ����� �� ���������� �����. */
        canShowReport(): boolean;
        /** �������� ������ �� ������� ������������. */
        loadData(): JQueryDeferred<GenModels.ApprovalHistoryViewModel>;
        /**
         * ��������� ����������� �������.
         * @param dialog ���������� ����
         * @param data ������ �� ������� ������������
         */
        renderDialogContent(dialog: ModalWindow, data: GenModels.ApprovalHistoryViewModel): void;
        /** ���������� ������. */
        refreshReport(): void;
        /** ������� �� �����. */
        readonly isReportShown: boolean;
        /** ��������� �������� */
        renderControl(): JSX.Element;
        /** ��������� ������ �������� ���� ������������. */
        renderButton(): JSX.Element;
        /** ��������� ������� � ����� ������������. */
        renderInlineTable(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Лист согласования]{@link AgreementList}.
     */
    class AgreementListParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Данные листа согласования. */
        data?: GenModels.AgreementListModel;
        /** Текст, отображаемый на кнопке открытия листа согласования. */
        buttonText?: string;
        /**
         * Флаг, определяющий возможность отображения листа согласования:
         * true - возможно (если данные для отображения доступны и разрешена настроенная операция редактирования),
         * false - невозможно.
         */
        canShowReport?: boolean;
        /** Идентификатор текущей карточки. */
        cardId?: string;
        /** Текст всплывающей подсказки */
        tip?: string;
        /** События возникает при открытии окна листа согласования. */
        agreementReportOpening?: CancelableApiEvent<IAgreementListReportOpeningEventArgs>;
        /** События возникает при закрытии окна листа согласования. */
        agreementReportClosing?: CancelableApiEvent<IEventArgs>;
        /** События возникает после открытия окна листа согласования. */
        agreementReportOpened?: BasicApiEvent<IAgreementListReportOpenedEventArgs>;
        /** События возникает после закрытия окна листа согласования. */
        agreementReportClosed?: BasicApiEvent<IEventArgs>;
        /** Сервисы */
        services?: $LayoutAgreementController & $EditOperationStore & Optional<$CardId> & Optional<$SiteUrl>;
    }
    /**
     * Класс элемента управления Лист согласования.
     *
     * Добавляет в web-разметку кнопку, при нажатии которой открывается окно просмотра листа согласования.
     */
    class AgreementList extends BaseControl<AgreementListParams, AgreementListState> {
        /** @internal */
        constructor(props: AgreementListParams);
        /** @inheritDoc */
        protected createParams(): AgreementListParams;
        /** @internal */
        protected readonly myControlImpl: AgreementListImpl;
        /**
         * Проверяет, что лист согласования открыт для просмотра.
         * @return true - открыт, false - закрыт.
         */
        readonly isReportShown: boolean;
        /**
         * Закрывает лист согласования.
         */
        hideReport(): void;
        /**
         * Открывает лист согласования.
         */
        showReport(): void;
        /** @internal */
        private bindingEditOperation;
        /** @internal */
        protected getAgreementList(): JQueryDeferred<GenModels.AgreementListModel>;
        /** @internal */
        protected createImpl(): AgreementListImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface AgreementListState extends AgreementListParams, BaseControlState {
        getAgreementList: () => JQueryDeferred<GenModels.AgreementListModel>;
        loading: boolean;
        dialog: ModalWindow;
        lastLoadedData: GenModels.AgreementListModel;
    }
    /** @internal */
    type AgreementListImplState = AgreementListState;
    type AgreementListImplProps = AgreementListState;
    /** @internal */
    class AgreementListImpl extends BaseControlImpl<AgreementListParams, AgreementListState> {
        constructor(props: AgreementListParams, state: AgreementListState);
        getCssClass(): string;
        showReport(): void;
        hideReport(): void;
        showModalWindow(data: GenModels.AgreementListModel): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Управление согласованием]{@link AgreementManagement}.
     */
    class AgreementManagementParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /**
         * Флаг, определяющий, что запуск согласования разрешен:
         * true - разрешен (элемент управления связан с данными и разрешена настроенная операция старта согласования),
         * false - не разрешен.
         */
        startAllowed?: boolean;
        /**
         * Флаг, определяющий, что управление согласованием разрешено: true - разрешено
         * (элемент управления связан с данными и разрешена настроенная операция управления согласованием), false - не разрешено.
         */
        manageAllowed?: boolean;
        /**
         * Флаг, определяющий, что запуск согласования разрешен:
         * true - разрешен (карточка является новой и {@link startAllowed} в true),
         * false - не разрешен.
         */
        canStart?: boolean;
        /**
         * Флаг, определяющий, что управление согласованием разрешено:
         * true - разрешен (карточка является новой и {@link manageAllowed} в true),
         * false - не разрешен.
         */
        canManage?: boolean;
        /** Флаг доступности прекращения этапа согласования */
        abortStageAllowed: boolean;
        /** Флаг запроса диалога подтверждения запуска согласования */
        confirmationRequestOnStart?: boolean;
        /** Массив моделей кнопок управления согласованием */
        buttonNames: GenModels.AgreementManagementButtonModel[];
        /** Режим отображения согласующего */
        approverViewType?: GenModels.ApproverViewType;
        /** Режим отображения элемента управления */
        agreementMode?: GenModels.AgreementMode;
        /** При открытой панели старта согласования, возвращает информацию о доступных шаблонах согласования.  */
        templates?: GenModels.AgreementTemplateModel[];
        /** Возвращает выбранный в данный момент шаблон согласования из списка {@link templates} в панели старта согласования. */
        selectedTemplate?: GenModels.AgreementTemplateModel;
        /** Информация об этапах согласования, отображаемых в данный момент в панели упрвления или старта согласования. */
        stages?: GenModels.StageModel[];
        /** Открыта ли в данный момент панель старта или управления согласованием. */
        sidebarIsOpen?: boolean;
        /** В каком режиме находится контрол - в режиме создания согласования (false) или в режиме управления существующим согласованием (true). */
        agreementExists?: boolean;
        /** Событие возникает при изменении маршрута согласования. */
        approvingPathChanging?: CancelableApiEvent<IApprovingPathEventArgs>;
        /** Событие возникает после изменения маршрута согласования. */
        approvingPathChanged?: BasicApiEvent<IApprovingPathEventArgs>;
        /** Событие возникает при открытии панели отправки согласования. */
        approvingPanelOpening?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после открытия панели отправки согласования. */
        approvingPanelOpened?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при нажатии кнопки Start the approval на панели отправки согласования. */
        approvingStarting?: CancelableApiEvent<IAgreementEventArgs>;
        /** Событие возникает при вызове команды остановки согласования. */
        approvingPausing?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает при вызове команды отмены согласования. */
        approvingCancelling?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает при вызове команды завершения согласования. */
        approvingCompleting?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает при вызове команды продолжения остановленного согласования. */
        approvingResuming?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает при добавлении нового согласующего. */
        approverAdding?: CancelableApiEvent<IApproverEventArgs>;
        /** Событие возникает после добавления нового согласующего. */
        approverAdded?: BasicApiEvent<IApproverEventArgs>;
        /** Событие возникает при удалении согласующего. */
        approverDeleting?: CancelableApiEvent<IApproverDeletionEventArgs>;
        /** Событие возникает после удаления согласующего. */
        approverDeleted?: BasicApiEvent<IApproverDeletionEventArgs>;
        /** Событие возникает при нажатии кнопки Отмена на панели отправки согласования. */
        approvingStartCancelling?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после нажатия кнопки Отмена на панели отправки согласования. */
        approvingStartCancelled?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при прекращении этапа согласования */
        approvingStageAborting?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после прекращении этапа согласования */
        approvingStageAborted?: BasicApiEvent<IEventArgs>;
        /** Сервисы. */
        services?: $LayoutAgreementController & $LayoutStaffController & $EditOperationStore & $LayoutInfo & $LocalStorage;
    }
    /**
     * Класс элемента управления Управление согласованием.
     *
     * Добавляет в web-разметку набор кнопок для управления согласования.
     */
    class AgreementManagement extends BaseControl<AgreementManagementParams, AgreementManagementState> {
        /** @internal */
        constructor(props: AgreementManagementParams);
        /** @inheritDoc */
        protected createParams(): AgreementManagementParams;
        /** Возвращает экземпляр AgreementManagementImpl. */
        private readonly myControlImpl;
        private readonly stages;
        private readonly agreementExists;
        private readonly sidbarShown;
        private agreementManagementData;
        private agreementManagementOperationBinding;
        private agreementStartOperationBinding;
        private abortStageOperationBinding;
        private agreementManagementButtonNames;
        private availableButtons;
        readonly canStart: boolean;
        readonly canManage: boolean;
        /**
         * Загружает данные карточки с сервера и обновляет отображаемое содержимое.
         */
        refresh(): void;
        /**
         * Возвращает массив команд управления согласованием, которые применимы для текущего согласования.
         * @return Команды управления.
         */
        getAvailableOperations(): GenModels.ApprovalOperationKind[];
        /**
         * Запускает остановленное согласование.
         */
        resume(): void;
        /**
         * Останавливает запущенное согласование.
         */
        pause(): void;
        /**
         * Завершает запущенное согласование.
         */
        complete(): void;
        /**
         * Отменяет запущенное согласование.
         */
        cancel(): void;
        /**
         * Запускает согласование или открывает панель запуска согласования (если необходим ввод дополнительных данных).
         */
        start(): JQueryDeferred<{}>;
        /** @deprecated Используйте {@link hideSidebar} */
        hideStartSidebar(): void;
        /** Закрывает панель запуска или управления согласованием без сохранения правок. */
        hideSidebar(): void;
        /** При открытой панели старта согласования имитирует клик по кнопке "Отправить". */
        send(): JQueryDeferred<void>;
        /** Открывает панель управления согласованием */
        edit(): JQueryDeferred<{}>;
        /** @internal */
        protected createImpl(): AgreementManagementImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface AgreementManagementState extends AgreementManagementParams, BaseControlState {
        agreementManagementModel: GenModels.AgreementManagementModel;
        refresh: Function;
        IsTemplateDataReceived: boolean;
        startLoading: boolean;
        startDisabled: boolean;
        startSidebarShown: boolean;
        managementLoaging: boolean;
        managementSidebarShown: boolean;
        agreementManagementStartModel: GenModels.AgreementManagementStartModel;
        editModel: GenModels.AgreementManagementEditModel;
        stageLoading: LoadingState;
        showInterruptBtn: boolean;
        currentStageId: string;
        availableButtons: number;
    }
    /** @internal */
    type AgreementManagementImplState = AgreementManagementState;
    /** @internal */
    class AgreementManagementImpl extends BaseControlImpl<AgreementManagementParams, AgreementManagementState> {
        approvalOperationButtonNames: any;
        constructor(props: AgreementManagementParams, state: AgreementManagementState);
        componentWillReceiveProps(nextProps: any, nextContext: any): void;
        readonly ApprovalOperationButtonNames: any;
        protected onTemplateSelect(val: IComboBoxElement): Promise<void>;
        protected onCancelClick(start: boolean): void;
        onSendClick(): Promise<void>;
        protected onSaveClick(): void;
        protected onInterruptClick(): Promise<void>;
        protected onOperationButtonClick(operation: GenModels.ApprovalOperationKind): Promise<void>;
        start(): JQueryDeferred<{}>;
        protected handleLoadingErrorOnSidebarOpen(loadingTimer: any): void;
        hideStartSidebar(cancel?: boolean): Promise<void>;
        edit(): JQueryDeferred<{}>;
        hideManagementSidebar(): void;
        protected handleClick(event: React.MouseEvent<any>): void;
        protected handleMouseOver(event: React.MouseEvent<any>): void;
        protected handleMouseOut(event: React.MouseEvent<any>): void;
        protected handleStartAgreement: (e: React.MouseEvent<any>) => void;
        protected handleEditAgreement: (e: Event) => void;
        getAvailableOperations(): GenModels.ApprovalOperationKind[];
        onManageButtonClick(buttonKind: GenModels.ApprovalOperationKind): void;
        protected getCssClass(): string;
        protected getButtonName: (operationKind: GenModels.AgreementManagementOperations) => string;
        protected getTemplateComboBoxProps(): any;
        protected getTemplateComboBoxElements(): any;
        readonly canStart: boolean;
        readonly canManage: boolean;
        renderControl(): JSX.Element;
        protected renderCreateView(): JSX.Element;
        protected renderCreateSidebar(): JSX.Element;
        protected renderManageView(): JSX.Element;
        protected renderManagementSidebarButtons(): JSX.Element[];
        protected renderManagementSidebar(): JSX.Element;
    }
}
declare namespace WebClient {
    class ControlImpl extends BaseControlImpl<BaseControlParams, BaseControlImplState> {
        private renderControlFunction;
        constructor(props: BaseControlParams, state?: BaseControlImplState, renderControlFunction?: () => React.ReactNode);
        readonly isControlImpl: boolean;
        renderControl(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Блок]{@link Block}.
     */
    class BlockParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Заголовок, отображаемый над элементом управления. */
        header?: string;
        /**
         * Флаг, определяющий, возможность сворачивания Блока:
         * true - Блок может быть свернут (отображается кнопка сворачивания),
         * false - Блок не может быть свернут.
         */
        collapsible?: boolean;
        /** Флаг, указывающий, что содержимое Блока должно быть выровнено по левой стороне: true - выравнивание влево, false - выравнивание вправо.*/
        alignment?: boolean;
        /** флаг, указывающий, что Блок должен отделяться от других элементов управления дополнительными отступами: true - с отступами, false - без отступов. */
        paddings?: boolean;
        /** Флаг, определяющий текущее состояние блока: true - Блок свернут (содержимое не отображается), false - Блок раскрыт. */
        isCollapsed?: boolean;
        /** Событие возникает при сворачивании Блока. */
        collapsing?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после сворачивания Блока. */
        collapsed?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при раскрытии Блока. */
        expanding?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после раскрытия Блока. */
        expanded?: BasicApiEvent<IEventArgs>;
    }
    /**
     * Класс элемента управления Блок.
     *
     * Добавляет в web-разметку сворачиваемый элемент управления с заголовком, предназначенный для встраивания других элементов управления.
     */
    class Block extends Panel<BlockParams, BlockState> {
        protected createParams(): BlockParams;
        protected createImpl(): BlockImpl;
        isCollapsed: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface BlockState extends PanelState, BlockParams {
    }
    /** @internal */
    class BlockImpl extends PanelImpl<BlockParams, BlockState> {
        constructor(props: BlockParams, state: BlockState);
        protected handleHeaderClick(event: React.MouseEvent<any>): void;
        toggleCollapsed(): CancelableEventArgs<IEventArgs>;
        protected getCssClass(): string;
        protected onCollapsed(): void;
        protected onExpanded(): void;
        protected getItemsStyle(): {
            textAlign: string;
        };
        isCollapsed: boolean;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Класс параметров для базового класса {@link InputBasedControl}. */
    class InputBasedControlParams<ModelT> extends BaseControlParams {
        /** Значение элемента управления. */
        value?: ModelT;
        /** Флаг, определяющий возможность изменения значения элемента управления:
         * true - разрешено (разрешена настроенная операция редактирования),
         * false - не разрешено.
         */
        canEdit?: boolean;
        /**
         * Флаг, определяющий, что элемент управления находится в
         * модальном окне редактирования значения элемента управления в режиме редактирования.
         * {@link EditMode.EditInPlace}
         *
         * Элемент управления, расположеный в модальном окне редактирования, доступен по названию: `названиеЭУ**_modal_control**`
         */
        modalMode?: boolean;
        /** Возвращает значение по умолчанию */
        default?: any;
        /** Возвращает режим редактирования. */
        editMode?: EditMode;
        /** Текст всплывающей подсказки */
        tip?: string;
        /**
        * Текст заполнителя.
        *
        * Заполнитель отображается в элементе управления, когда его (элемента управления) значение не задано.
        */
        placeHolder?: string;
        /**
        * Текст метки.
        *
        * Метка - текст отображаемый рядом (слева или вверху) с элементом управления.
        */
        labelText?: string;
        /** Флаг, определяющий, что метка должна отображаться, когда значение элемента управления не задано: true - отображать, false - не отображать. */
        showEmptyLabel?: boolean;
        /** Флаг, указывающий, обязательно ли должно быть задано значение элемента управления: true - обязательно, false - не обязательно. */
        required?: boolean;
        /**
         * Флаг, определяющий, должно ли переноситься на следующую строку тектовое содержимое, когда оно не помещается в одну строку:
         * true - переносить,
         * false - не переносить.
         */
        wrapLongValueUnderLabel?: boolean;
        /** Флаг, определяющий, что модальное окно редактирования значения открыто: true - открыто, false - не открыто.  */
        isEditDialogShown?: boolean;
        /** Событие возникает при изменении значения элемента управления. */
        dataChanged?: BasicApiEvent<IDataChangedEventArgsEx<ModelT>>;
        /** Событие возникает при открытии модального окна редактирования. */
        inPlaceEditOpeninig?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после открытия модального окна редактирования. */
        inPlaceEditOpened?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при закрытии диалогового окна редактирования. */
        inPlaceEditClosinig?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после закрытия диалогового окна редактирования. */
        inPlaceEditClosed?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при сохранении изменения значения в модальном окна редактирования. */
        editPopoverAccepting?: CancelableApiEvent<any>;
        /** @internal Specifies control name, that should be placed into binding. Used in edit-in-place scenario. */
        editInPlaceCreatorControlName?: string;
    }
    /**
     * Базовый класс элементов управления, поддерживающих ввод данных.
     *
     * @param P Класс, наследующийся от {@link InputBasedControlParams} и описывающий публичные свойства компонента.
     * @param S Интерфейс, расширяющий {@link InputBasedControlState} и описывающий внутренние переменные инетрфейсного компонента.
     */
    abstract class InputBasedControl<ModelT, P extends InputBasedControlParams<ModelT>, S extends InputBasedControlState<ModelT>> extends BaseControl<P, S> {
        protected isAccepting: boolean;
        constructor(props: P);
        /** При переопределении в производных классах должен возвращать объект, содержащий соответствующие сервисы. */
        protected abstract getServices(): $LayoutInfo;
        /** @internal */
        protected defaultValue: ModelT;
        private readonly myControlImpl;
        /**
         * Проверяет возможность отображения диалогового окна редактирования.
         * @returns true - если операция редактирования доступна и элемент управления находится в режиме редактирования "По месту"; иначе - false.
         */
        canShowEditDialog(): boolean;
        /**
         * Открывает диалоговое окно редактирования значения.
         *
         * Внимание, в связи с изменениями в React 16, в Web-клиент начиная с версии 10 данный метод асинхронный.
         */
        showEditDialog(): JQueryDeferred<InputBasedControl<ModelT, P, S>>;
        /**
         * Закрывает диалоговое окно редактирования значения.
         */
        hideEditDialog(): void;
        /**
         * Проверяет наличие значения у элемента управления.
         * @returns true - если значение элемента управления установлено, иначе - false.
         */
        hasValue(): boolean;
        private readonly isEditDialogShown;
        /** Тоже что и {@link InputBasedControlParams.value} */
        value: ModelT;
        /** Запускает валидацию элемента управления. */
        validate(params: IValidationParams): IValidationResult[];
        /** @internal */
        componentDidMount(): void;
        private readonly myGenericControlImpl;
        /** @internal */
        onEditPopoverAccepting(sender: any, event: ICancelableEventArgs<IEventArgs>): void;
        /** При переопределении в дочерних классах возвращает объект,
         * в котором перечислены параметры, значения которых необходимо
         * перенести из edit-in-place окна в основной контрол. В объекте в качестве ключей имена параметров,
         * а в качестве значений соответствующие значения из аргумента params. */
        protected getParamsToKeep(params: P): {
            value: ModelT;
        };
        /** Возвращает модель данных, которая будет передана на сервер при сохранении значения контрола.
         * Сами данные получаются путем вызова {@link getBindings}. */
        getBindingsWriteRequests(): IBindingsWriteRequest[];
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Вид карточки]{@link CardKind}.
     */
    class CardKindParams extends InputBasedControlParams<GenModels.CardKindModel> {
        /** Возвращает режим редактирования. */
        editMode?: EditMode;
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Список типов видов карточек, доступных для выбора (по умолчанию все типы доступны). */
        availableTypes?: string[];
        /** Список видов карточек, доступных для выбора (по умолчанию все виды доступны). */
        availableKinds?: string[];
        /** Сервисы. */
        services?: $LayoutCardKindController & $LayoutInfo & $EditOperationStore;
    }
    /**
     * Класс элемента управления Вид карточки.
     *
     * Добавляет в web-разметку текстовый блок с меткой, в котором отображается название текущего вида карточки.
     */
    class CardKind extends InputBasedControl<GenModels.CardKindModel, CardKindParams, CardKindState> {
        protected createParams(): CardKindParams;
        protected getServices(): $LayoutCardKindController & $LayoutInfo & $EditOperationStore;
        protected createImpl(): CardKindImpl;
        protected getBindings(): IBindingResult<any>[];
        private cardKindData;
    }
}
declare namespace WebClient {
    /** Базовый класс состояния {@link InputBasedControl}. */
    interface InputBasedControlState<ModelT> extends BaseControlState, InputBasedControlParams<ModelT> {
        currentValue: ModelT;
        inputText: string;
        inputFocused: boolean;
        validationMessage: string;
        hadValue: boolean;
    }
    /** @deprecated */
    type InputBasedControlImplState<ModelT> = InputBasedControlState<ModelT>;
    /** Базовый класс реализации {@link InputBasedControl}. */
    abstract class InputBasedControlImpl<ModelT, PropsT extends InputBasedControlParams<ModelT>, StateT extends InputBasedControlImplState<ModelT>> extends BaseControlImpl<PropsT, StateT> {
        editPopoverControl: InputBasedControl<ModelT, any, any>;
        text: HTMLElement;
        /** Edit popover, that showed copy of control in edit-in-place mode */
        editPopover: EditPopover;
        /** Edit popover, where control currently located */
        containingEditPopover: EditPopover;
        input: HTMLElement;
        constructor(props: PropsT, state?: StateT);
        canShowEditDialog(): boolean;
        /**
         * Показывает диалог редактирования по месту.
         *
         * Внимание, в связи с изменениями в React 16, в Web-клиент начиная с версии 10 данный метод асинхронный.
         */
        showEditDialog(): JQueryDeferred<InputBasedControl<ModelT, PropsT, StateT>>;
        hideEditDialog(): void;
        hasValue(): boolean;
        protected onDataChanged(eventArgs: IDataChangedEventArgs): void;
        protected onInPlaceEditOpening(callback?: () => void): JQueryDeferred<any>;
        protected onInPlaceEditOpened(): void;
        protected onInPlaceEditClosinig(sender: any, args: ICancelableEventArgs<any>): void;
        protected onInPlaceEditClosed(): void;
        validate(params: any): IValidationResult;
        protected readonly editAvailable: boolean;
        getTabIndex(): 0 | -1;
        protected attachInput(elem: HTMLElement): void;
        protected getInputElem(): HTMLElement;
        protected attachText(textElem: any): void;
        /**
         * Создает и рендерит диалог редактирования по месту.
         *
         * Внимание, в связи с изменениями в React 16, в Web-клиент начиная с версии 10 данный метод асинхронный.
         */
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<ModelT, PropsT, StateT>>;
        protected onEditPopoverShowed(control: InputBasedControlImpl<any, PropsT, StateT>): void;
        componentWillUnmount(): void;
        componentWillMount(): void;
        protected getCssClass(): string;
        protected onInputFocus(event: React.FocusEvent<any>): void;
        protected onInputBlur(event: React.FocusEvent<any>): void;
        protected onPlaceholderClick(event: any): void;
        protected onValueClick(event: any): void;
        protected renderValidationMessage(): JSX.Element;
        protected getInputTitle(): string;
        protected renderInputWithPlaceholder(): React.ReactNode;
        protected updateValidationMessage(): void;
        protected editModeRender(): JSX.Element;
        protected getValueTitle(): string;
        protected renderWithText(): JSX.Element;
        protected editInPlaceModeRender(): JSX.Element;
        protected viewModeRender(): JSX.Element;
        renderControl(): JSX.Element;
        protected abstract getTextValue(): string;
        /**
         * При переопределении в производных классах должен рендерить контрол в соответствующий элемент.
         *
         * Например:
         *
         *      protected renderInto(props: NumberParams, container: HTMLElement): void {
         *          ReactDOM.render(<NumberControl {...props } key={props.name} />, container);
         *      }
         *
         * Внимание! В Web-клиенте версии 9 данный метод возвращал экземпляр контрола.
         * В версии 10 он не возвращает значение, т.к. в React 16 изменилась логик метода ReactDOM.render.
         *
         * @param props Параметры контрола
         * @param container DOM-элемент, куда следует отрендерить контрол.
         */
        protected abstract renderInto(props: PropsT, container: HTMLElement): void;
        protected getDefaultValue(): ModelT;
        protected onInputChange(event: any): void;
        protected readonly editPopoverControlImpl: InputBasedControlImpl<ModelT, any, any>;
        setValue(value: ModelT, redraw: boolean): void;
        protected setValueInternal(value: ModelT): void;
        getValue(): ModelT;
        value: ModelT;
        protected getEditAvailable(): boolean;
        protected initEditPopover(popover: EditPopover): void;
        protected renderEditPopover(popover: EditPopover): JQueryDeferred<InputBasedControl<ModelT, PropsT, StateT>>;
        protected renderPlaceholder(): JSX.Element;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected renderInput(): React.ReactNode;
        protected readonly editInPlaceAvailable: boolean;
        private readonly defaultValue;
    }
}
declare namespace WebClient {
    /** @internal */
    const CardKindTreeContent: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLUListElement>, HTMLUListElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLUListElement>, HTMLUListElement>>;
    /** @internal */
    interface ICardKindTreeProps {
        kinds: CardKindTreeNodeModel[];
        activeKindId?: string;
        emptyMessage?: string;
        onCardKindSelected?: (kind: CardKindTreeNodeModel) => void;
        isCardKindAvailable?: (kind: CardKindTreeNodeModel) => boolean;
        notAvailableProperty: "notSelectable" | "notAvailable";
    }
    /**
     * @internal
     * Дерево видов карточек
     */
    class CardKindTree extends React.Component<ICardKindTreeProps, {}> {
        /**
         * При выборе вида карточи
         * @param cardKind Выбранный вид карточки
         */
        protected onCardKindSelected: (cardKind: CardKindTreeNodeModel) => void;
        /** При клике по ветке дерева */
        protected onBranchToggle: (cardKind: CardKindTreeNodeModel, e?: React.MouseEvent<HTMLElement>) => void;
        /**
         * Рекурсивно строим дерево видов
         * @param cardKinds Список видов карточек
         */
        protected getCardKindsTree: (cardKinds: CardKindTreeNodeModel[]) => React.ReactNode[];
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    const CardKindTreeNodeWrapper: styled.StyledComponentClass<React.DetailedHTMLProps<React.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement>, any, React.DetailedHTMLProps<React.LiHTMLAttributes<HTMLLIElement>, HTMLLIElement>>;
}
declare namespace WebClient {
    /** @internal */
    interface ICardKindTreeNodeProps {
        available: boolean;
    }
    /** @internal */
    const CardKindTreeNode: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICardKindTreeNodeProps, any, React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICardKindTreeNodeProps>;
}
declare namespace WebClient {
    /** @internal */
    interface ICardKindTreeNodeTitleProps {
        active?: boolean;
        disabled?: boolean;
    }
    /** @internal */
    const CardKindTreeNodeTitle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICardKindTreeNodeTitleProps, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICardKindTreeNodeTitleProps>;
}
declare namespace WebClient {
    /** @internal */
    interface ICardKindTreeNodeBranchIconProps {
        opened?: boolean;
    }
    /** @internal */
    const CardKindTreeNodeBranchIcon: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICardKindTreeNodeBranchIconProps, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICardKindTreeNodeBranchIconProps>;
}
declare namespace WebClient {
    /** @internal */
    const CardKindTreeNodeLeafIcon: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    /** @internal */
    const CardKindTreeNodeChildren: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLUListElement>, HTMLUListElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLUListElement>, HTMLUListElement>>;
}
declare namespace WebClient {
    /** @internal */
    interface CardKindState extends CardKindParams, InputBasedControlState<GenModels.CardKindModel> {
        requestHelper: RequestHelper;
        isLoading: boolean;
        /** cardKindsTree и cardKindsList это всегда одна и та же модель, но в одном случае она древовидна, а в другом сплющенная */
        cardKindsTree: CardKindTreeNodeModel[];
        /** cardKindsTree и cardKindsList это всегда одна и та же модель, но в одном случае она древовидна, а в другом сплющенная */
        cardKindsList: CardKindTreeNodeModel[];
        selectKindModalOpen: boolean;
        inputKeyDown: SimpleEvent<React.KeyboardEvent<any>>;
    }
    /** @internal */
    class CardKindImpl extends InputBasedControlImpl<GenModels.CardKindModel, CardKindParams, CardKindState> {
        protected onLoadEvent: SimpleEvent<any>;
        constructor(props: CardKindParams, state: CardKindState);
        /**
         * Загружаем дерево с видами
         */
        protected loadCardKindsTree(): JQueryDeferred<CardKindTreeNodeModel[]>;
        /**
         * Загружаем дерево с видами и сохраняем его в контроле
         */
        protected loadAndApplyCardKindsTree: () => void;
        /**
         * Текстовое значение выбранного вида
         */
        protected getTextValue(): string;
        /**
         * Заголовок выбранного вида
         */
        protected getValueTitle(): string;
        /**
         * Список элементов для выпадающего списка с автодополнением
         */
        protected findItems: (typeaheadQuery: ITypeaheadSearchQuery) => JQueryDeferred<ITypeaheadSearchResult>;
        /**
         * Доступен ли вид карточки
         */
        protected isCardKindAvailable: (cardKind: CardKindTreeNodeModel) => boolean;
        /**
         * При выборе вида в списке с автодополнением
         */
        protected onSelected: (variant: ITypeaheadVariant) => void;
        /**
         * Показать модальное окно с выбором вида
         */
        protected showSelectKindModal: () => void;
        /**
         * Скрыть модальное окно с выбором вида
         */
        protected hideSelectKindModal: () => void;
        /**
         * Конвертирует узел из дерева видов в модель контрола (например, для установки значения при выборе в дереве)
         */
        protected convertCardKindTreeNodeToModel: (node: CardKindTreeNodeModel) => GenModels.CardKindModel;
        /**
         * При выборе узла в дереве видов
         */
        protected onCardKindTreeNodeSelect: (cardKind: CardKindTreeNodeModel) => void;
        /**
         * При вводе в инпут с автодополнением
         * @param ev Событие клавиатуры
         */
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        /**
         * Куда рендерим контрол
         * @param props Свойства
         * @param container Контейнер
         */
        protected renderInto(props: CardKindParams, container: HTMLElement): void;
        /**
         *  Отрисовывание контрола
         */
        renderControl(): JSX.Element;
        /**
         * Отрисовывание контрола в режиме просмотра
         */
        protected renderWithText(): JSX.Element;
        /**
         * Отрисовывание контрола в режиме редактирования
         */
        protected renderInputWithPlaceholder(): React.ReactNode;
        /**
         * Отрисовываем дерево видов
         */
        protected renderCardKindsTree(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Публичные свойства для контрола {@link CardLink}.
     */
    class CardLinkParams extends BaseControlParams {
        standardCssClass?: string;
        /** Информация о текущей выбранной карточке. */
        value?: GenModels.CardLinkDataModel;
        /** Доступно редактирование значения или нет (согласно операции редактирования). */
        canEdit?: boolean;
        /** Текст метки */
        labelText?: string;
        /** Флаг, определяющий, что метка должна отображаться, когда значение элемента управления не задано: true - отображать, false - не отображать. */
        showEmptyLabel?: boolean;
        /** Определяет какой текст будет отображаться для выбора ссылки, когда ссылка не указана.  */
        emptyText?: string;
        /** Всплывающая подсказка */
        tip?: string;
        /** Возвращает режим редактирования. */
        editMode?: EditMode;
        /** Типы карточек, которые пользователь может выбрать при добавлении ссылки. */
        cardTypes?: GenModels.CardNodeInfo[];
        /** Идентификатор карточки. Параметр необходим только для случая, когда контрол находится вне разметки. */
        cardId?: string;
        /** Отрыто ли меню карточки. */
        menuExpanded?: boolean;
        /** обязательно ли для заполнения */
        required?: boolean;
        /** Событие, возникающее перед очисткой значения. */
        linkDeleting?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после очистки значения. */
        linkDeleted?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед открытием окна выбора карточки. */
        windowOpening?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после открытия окна выбора карточки. */
        windowOpened?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед закрытием окна выбора карточки. */
        windowClosing?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после закрытия окна выбора карточки. */
        windowClosed?: BasicApiEvent<IEventArgs>;
        /** Событие возникающее при изменении значения элемента управления. */
        dataChanged?: BasicApiEvent<IDataChangedEventArgsEx<GenModels.CardLinkDataModel>>;
        /** Событие, возникающее перед открытием предпросмотра файла связанной карточки. */
        linkFilePreviewing?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после открытия предпросмотра файла связанной карточки. */
        linkFilePreviewed?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед открытием связанной карточки. */
        linkCardOpening?: CancelableApiEvent<IEventArgs>;
        /** Сервисы. */
        services?: $FileController & $LayoutFileController & $LayoutLinksController & Optional<$CardId> & $EditOperationStore;
    }
    /**
     * Представляет элемент управления для редактирования связанной карточки.
     */
    class CardLink extends BaseControl<CardLinkParams, CardLinkState> {
        constructor(props: CardLinkParams);
        componentDidMount(): void;
        protected createParams(): CardLinkParams;
        protected createImpl(): CardLinkImpl;
        private binding;
        private cardTypes;
        value: GenModels.CardLinkDataModel;
        protected getBindings(): IBindingResult<any>[];
        private onDataChanged;
        private readonly cardLinkImpl;
        /** @inheritDoc */
        validate(params: any): IValidationResult[];
        /**
         * Открывает привязанную карточку
         */
        openLinkedCard: () => void;
        /**
         * Открывает предпросмотр файла привязанной карточки
         */
        openFilePreview: () => void;
        /**
         * Открывает модальное окно для выбора карточки, которую мы хотим привязать
         */
        openSelectCardDialog: () => void;
        /**
         * Удаляет привязанную карточку
         */
        deleteLinkedCard: () => void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface CardLinkState extends BaseControlState, CardLinkParams {
        addExistingCardLinkDialog: ExistingCardLinkDialog;
        saveHelper: RequestHelper;
        validationMessage: string;
        bindingInfo: IBindingResult<GenModels.CardLinkDataModel>;
    }
    /** @deprecated */
    type CardLinkImplState = CardLinkState;
    /** @deprecated */
    type ControlImplProps = CardLinkState;
    /** @internal */
    class CardLinkImpl extends BaseControlImpl<CardLinkParams, CardLinkState> {
        constructor(props: CardLinkParams, state: CardLinkState);
        setValue(value: GenModels.CardLinkDataModel, forceUpdate?: boolean): JQueryDeferred<any>;
        value: GenModels.CardLinkDataModel;
        componentDidMount(): void;
        componentWillUnmount(): void;
        protected onDocumentClick: (e: MouseEvent) => void;
        getLinkUrl(cardId: string): string;
        openMenu: () => void;
        closeMenu: () => void;
        toggleMenu: () => void;
        openLinkedCard: () => void;
        openFilePreview: () => void;
        openSelectCardDialog: () => void;
        deleteLinkedCard: () => void;
        onOpenLinkedCardMenuClick: () => void;
        onViewFileMenuClick: () => void;
        onOpenSelectCardDialogMenuClick: () => void;
        onDeleteLinkedCardMenuClick: () => void;
        onTextClick: () => void;
        onMenuClick: () => void;
        readonly hasValue: boolean;
        readonly isLoading: boolean;
        readonly isMenuAvailable: boolean;
        readonly cardViewAllowed: boolean;
        readonly mainFileReadAllowed: boolean;
        readonly isTextClickable: boolean;
        validate(params: any): IValidationResult;
        protected renderValidationMessage(): JSX.Element;
        protected getCssClass(): string;
        protected getTextTabIndex(): 0 | -1;
        protected onTextKeyDown: (event: React.KeyboardEvent<any>) => void;
        protected onMenuKeyDown: (event: React.KeyboardEvent<any>) => void;
        protected renderLabel(): JSX.Element;
        /**
         * Renders settings menu and its icon to open menu
         */
        protected renderSettingsMenu(): JSX.Element;
        /**
         * Renders label value
         */
        protected renderValue(): JSX.Element;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Управление карточкой]{@link CardManagement}.
     */
    class CardManagementParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /**
         * Флаг, указывающий на возможность изменения карточки:
         * true - изменение разрешено (разрешена настроенная операция редактирования),
         * false - изменение не разрешено.
         */
        canEdit?: boolean;
        /**
         * Флаг, указывающий на возможность удаления карточки:
         * true - удаление разрешено (разрешена операция удаления карточки),
         * false - удаление не разрешено.
         */
        canDelete?: boolean;
        /** Сервисы. */
        services?: $LayoutCardController & $EditOperationStore & $CardId & $Router;
    }
    /**
     * Класс элемента управления Управление карточкой.
     *
     * Добавляет в web-разметку автоматически скрываемые кнопки удаления, изменения и обновления карточки.
     */
    class CardManagement extends BaseControl<CardManagementParams, CardManagementState> {
        constructor(props: CardManagementParams);
        protected createParams(): CardManagementParams;
        /**
         * Загружает данные карточки с сервере и обновляет отображаемое содержимое.
         */
        refresh(): void;
        /**
         * Удаляет текущую карточку.
         */
        delete(): Promise<void>;
        /**
         * Переоткрывает текущую карточку в режиме редактирования.
         */
        edit(): void;
        private bindingEditOperation;
        /** @internal */
        createImpl(): CardManagementImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface CardManagementState extends CardManagementParams, BaseControlState {
        refresh: Function;
        deleteAndRedirect: Function;
        goToEdit: Function;
        deleting: boolean;
    }
    /** @internal */
    type CardManagementImplState = CardManagementState;
    /** @internal */
    class CardManagementImpl extends BaseControlImpl<CardManagementParams, CardManagementState> {
        constructor(props: CardManagementParams, state: CardManagementState);
        onEdit(): void;
        onDelete(): void;
        onRefresh(): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Флажок]{@link CheckBox}.
     */
    class CheckBoxParams extends InputBasedControlParams<boolean> {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Текст, отображаемый в элементе управления в режиме "Без редактирования", если значение равно `true`. */
        yesText?: string;
        /** Текст, отображаемый в элементе управления в режиме "Без редактирования", если значение равно `false`. */
        noText?: string;
        /** Картинка в base64, отображаемая в элементе управления для значения `true`. */
        yesImage?: ImageModel;
        /** Картинка в base64, отображаемая в элементе управления для значения `false`. */
        noImage?: ImageModel;
        /** Режим отображения элемента управления */
        hideMode?: CheckboxHideMode;
        /** Сервисы. */
        services?: $LayoutInfo & $EditOperationStore;
    }
    /**
     * Класс элемента управления Флажок.
     *
     * Добавляет в web-разметку элемент управления для изменения значение булевого типа.
     */
    class CheckBox extends InputBasedControl<boolean, CheckBoxParams, CheckBoxState> {
        constructor(props: CheckBoxParams);
        protected createParams(): CheckBoxParams;
        protected getServices(): $LayoutInfo & $EditOperationStore;
        /** @internal */
        componentDidMount(): void;
        protected onDataChanged(): void;
        private readonly checkBoxImpl;
        private CheckBoxBinding;
        private checkboxDefault;
        protected getBindings(): IBindingResult<any>[];
        /** @inheritDoc */
        canShowEditDialog(): boolean;
        /** @inheritDoc */
        showEditDialog(): JQueryDeferred<any>;
        /** @inheritDoc */
        hideEditDialog(): void;
        /** @internal */
        protected createImpl(): CheckBoxImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface CheckBoxState extends CheckBoxParams, InputBasedControlState<boolean> {
        binding: IBindingResult<boolean>;
        saveHelper: RequestHelper;
        yesText: string;
        noText: string;
    }
    /** @internal */
    type CheckBoxImplState = CheckBoxState;
    /** @internal */
    class CheckBoxImpl extends InputBasedControlImpl<boolean, CheckBoxParams, CheckBoxState> {
        constructor(props: CheckBoxParams, state: CheckBoxState);
        protected getTextValue(): string;
        protected getImageValue(): string;
        protected getImageSrcString(imageItem: ImageModel): string;
        protected renderInto(props: CheckBoxParams, container: HTMLElement): void;
        protected onInputChange(event: any): void;
        protected editInPlaceModeRender(): JSX.Element;
        protected renderWithText(): JSX.Element;
        protected renderInput(): React.ReactNode;
    }
}
declare namespace WebClient {
    /** @deprecated @internal */
    class ComboBoxParams extends InputBasedControlParams<IComboBoxVariant> {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Выбранное значение. */
        selectedValue?: IComboBoxVariant;
        /** Список вариантов значений. */
        variants: IComboBoxVariant[];
        /** Раскрыт ли выпадающий список. */
        expanded?: boolean;
        /** При выборе нового значения. */
        onSelect?: (variant: IComboBoxVariant) => void;
        /** Название класса. */
        className?: string;
        /** Сервисы. */
        services?: $LayoutInfo & $EditOperationStore;
    }
    /** @deprecated @internal */
    class ComboBox extends InputBasedControl<IComboBoxVariant, ComboBoxParams, ComboBoxState> {
        protected createParams(): ComboBoxParams;
        protected getServices(): $LayoutInfo & $EditOperationStore;
        protected createImpl(): ComboBoxImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ComboBoxState extends ComboBoxParams, InputBasedControlState<IComboBoxVariant> {
        items: IComboBoxItem[];
    }
    /** @internal */
    type ComboBoxImplState = ComboBoxState;
    /** @internal
     * Control is not completed.
     */
    class ComboBoxImpl extends InputBasedControlImpl<IComboBoxVariant, ComboBoxParams, ComboBoxState> {
        constructor(props: ComboBoxParams, state: ComboBoxState);
        protected loadItems(variants: IComboBoxVariant[]): void;
        variants: IComboBoxVariant[];
        protected getCssClass(): string;
        protected initEditPopover(popover: EditPopover): void;
        protected onValueBoxClick(): void;
        protected renderEditPopover(popover: EditPopover): any;
        protected onItemClick(item: IComboBoxItem): void;
        protected renderInputWithPlaceholder(): JSX.Element;
        protected getTextValue(): string;
        protected renderInto(props: any, container: HTMLElement): void;
    }
}
declare namespace WebClient {
    /**
     * Публичные свойства для контрола {@link CommentFile}.
     */
    class CommentFileParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Информация о текущей выбранной карточке. */
        value?: GenModels.CommonFileModel;
        /** Доступно редактирование значения или нет (согласно операции редактирования). */
        canEdit?: boolean;
        /** Обязатально ли необходимо ввести значение данного контрола. */
        required?: boolean;
        /** Текст метки */
        labelText?: string;
        /** Флаг, определяющий, что метка должна отображаться, когда значение элемента управления не задано: true - отображать, false - не отображать. */
        showEmptyLabel?: boolean;
        /** Всплывающая подсказка */
        tip?: string;
        /** Текст, которые будет показываться при отсутсвии файла. */
        placeHolder?: string;
        /** Проверка, доступно ли редактирование файла через WebDav. */
        webDavSupported?: boolean;
        /** Режим редактирования контрола - просмотр или просмотр и редактирование значения. */
        editMode?: EditMode;
        /** Событие, возникающее перед очисткой значения. */
        fileDeleting?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после очистки значения. */
        fileDeleted?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед открытием окна выбора файла */
        fileSelecting?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после открытия окна выбора файла, но до загрузки файла на сервер и установления значения контрола. */
        fileSelected?: CancelableApiEvent<File>;
        /** Событие, возникающее перед открытием файла через WebDav. */
        webDavOpening?: CancelableApiEvent<IEventArgs>;
        /** Событие возникающее при изменении значения элемента управления. */
        dataChanged?: BasicApiEvent<IDataChangedEventArgsEx<GenModels.CommonFileModel>>;
        /** Событие, возникающее перед открытием предпросмотра файла. */
        filePreviewOpening?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после открытия предпросмотра файла. */
        filePreviewOpened?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед скачиванием файла. */
        fileDownloading?: CancelableApiEvent<IEventArgs>;
        /** Сервисы. */
        services?: $FileController & $LayoutFileController & $LayoutFileApiController & $LayoutLinksController & $CardInfo & $EditOperationStore & $LayoutInfo;
    }
    /**
     * Представляет элемент управления для редактирования файла замечаний.
     */
    class CommentFile extends BaseControl<CommentFileParams, CommentFileState> {
        constructor(props: CommentFileParams);
        /** Возвращает URL для скачивания файла. */
        getDownloadLink: () => void;
        /** Открывает предпросмотр файла */
        openFilePreview(): void;
        /** Удаляет файл и очищает значение контрола */
        removeFile(): void;
        /** Открывает системный диалог выбора файла. */
        openSelectFileDialog(): void;
        /** @internal */
        protected readonly checkWebDavSupported: boolean;
        /** @internal */
        protected createParams(): CommentFileParams;
        /** @internal */
        protected createImpl(): CommentFileImpl;
        /** @inheritDoc */
        validate(params: any): IValidationResult[];
        /** @internal */
        private binding;
        /** @internal */
        protected value: GenModels.CommonFileModel;
        /** @internal */
        protected getBindings(): IBindingResult<any>[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface CommentFileState extends BaseControlState, CommentFileParams {
        menuExpanded: boolean;
        saveHelper: RequestHelper;
        validationMessage: string;
        bindingInfo: IBindingResult<GenModels.CommonFileModel>;
        lastSelectedFile: File;
    }
    /** @internal */
    class CommentFileImpl extends BaseControlImpl<CommentFileParams, CommentFileState> {
        fileUploadAttach: FileListAttachedElements;
        constructor(props: CommentFileParams, state: CommentFileState);
        setValue(value: GenModels.CommonFileModel, forceUpdate?: boolean): JQueryDeferred<any>;
        protected setValueInternal(value: GenModels.CommonFileModel): JQueryDeferred<any>;
        value: GenModels.CommonFileModel;
        componentDidMount(): void;
        componentWillUnmount(): void;
        protected onDocumentClick: (e: MouseEvent) => void;
        getLinkUrl(cardId: string): string;
        openMenu: () => void;
        closeMenu: () => void;
        toggleMenu: () => void;
        openFilePreview: () => void;
        removeFile: () => void;
        onOpenMenuClick: () => Promise<void>;
        onDownloadMenuClick: () => Promise<void>;
        getDownloadLink(): string;
        onUploadMenuClick: () => void;
        onDeleteMenuClick: () => void;
        onTextClick: () => void;
        openFileSelectDialog(): Promise<void>;
        validate(params: IValidationParams): IValidationResult;
        onMenuClick: () => void;
        readonly hasValue: boolean;
        readonly isLoading: boolean;
        readonly isMenuAvailable: boolean;
        readonly isTextClickable: boolean;
        protected renderValidationMessage(): JSX.Element;
        protected readonly editAvailable: boolean;
        protected getCssClass(): string;
        protected getTextTabIndex(): 0 | -1;
        protected onTextKeyDown: (event: React.KeyboardEvent<any>) => void;
        protected onMenuKeyDown: (event: React.KeyboardEvent<any>) => void;
        protected initFileUpload(attach: FileListAttachedElements): void;
        protected onFilesAdded(attach: FileListAttachedElements, e: any, data: any): Promise<void>;
        setFile(file: File): Promise<void>;
        protected renderUploadForm(attach: FileListAttachedElements): JSX.Element;
        protected renderLabel(): JSX.Element;
        /**
         * Renders settings menu and its icon to open menu
         */
        protected renderSettingsMenu(): JSX.Element;
        /**
         * Renders label value
         */
        protected renderValue(): JSX.Element;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    interface CommentsImplState extends BaseControlImplState, CommentsState {
        currentComment: GenModels.Comment;
        textArea: HTMLElement;
    }
    class CommentsImpl extends BaseControlImpl<CommentsParams, CommentsImplState> {
        constructor(props: CommentsParams);
        refresh(): JQueryDeferred<any>;
        addComment(text: string): JQueryDeferred<any>;
        updateComment(commentId: string, text: string): JQueryDeferred<any>;
        deleteComment(commentId: string): JQueryDeferred<any>;
        private onAddComment();
        private onCancelAddComment();
        private onEditComment(comment);
        private onDeleteComment(comment);
        private onCommentTextChange(text);
        private onShowAllCommentsButtonClick();
        protected onDataChanged(eventArgs: IDataChangedEventArgsEx<GenModels.Comment[]>): void;
        private refreshTextAreaSize();
        componentDidMount(): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Публичные свойства для контрола {@link Comments}.
     */
    class CommentsParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Список комментариев. */
        comments: GenModels.Comment[];
        /** Источник данных. */
        commentsDataSource: GenModels.CommentsDataSourceModel;
        /** Количество комментариев. */
        allCommentsCount: number;
        /** Максимальное количество отображаемых комментариев. */
        maxVisibleComments: number;
        /** Плейсхолдер */
        placeHolder: string;
        /** Событие, возникающее после добавления комментария. */
        commentAdded?: BasicApiEvent<ICommentEventArgs>;
        /** Событие, возникающее перед добавлением комментария. */
        commentAdding?: CancelableApiEvent<ICommentEventArgs>;
        /** Событие, возникающее после удаления комментария. */
        commentDeleted?: BasicApiEvent<ICommentEventArgs>;
        /** Событие, возникающее перед удалением комментария. */
        commentDeleting?: CancelableApiEvent<ICommentEventArgs>;
        /** Событие, возникающее после изменения комментария. */
        commentEdited?: BasicApiEvent<ICommentEventArgs>;
        /** Событие, возникающее перед изменением комментария. */
        commentEditing?: CancelableApiEvent<ICommentEventArgs>;
        /** Событие, возникающее после изменения списка комментариев. */
        dataChanged?: BasicApiEvent<IDataChangedEventArgsEx<GenModels.Comment[]>>;
        /** Можно ли добавлять новые комментарии. */
        canComment: boolean;
        /** Можно ли изменять собственные комментарии. */
        canEditSelf: boolean;
        /** Можно ли изменять все комментарии. */
        canEditAll: boolean;
        /** Сервисы. */
        services?: $CommentsController & $CurrentEmployeeId & $CardInfo & $LayoutInfo & $EditOperationStore;
    }
    /** @internal */
    interface CommentsState extends CommentsParams, BaseControlState {
    }
    /**
     * Представляет элемент управления для отображения списка комментариев.
     */
    class Comments extends BaseControl<CommentsParams, CommentsState> {
        protected createParams(): CommentsParams;
        private readonly CommentsImpl;
        protected canComment: IBindingResult<{}>;
        protected canEditSelf: IBindingResult<{}>;
        protected canEditAll: IBindingResult<{}>;
        protected comments: IBindingResult<GenModels.CommentsModel>;
        /** Обновление комментариев. */
        refresh(): void;
        /**
         * Добавление комментария.
         * @param text Текст нового комментария
         */
        addComment(text: string): JQueryDeferred<{}>;
        /**
         * Изменение комментария
         * @param commentId Идентификатор комментария
         * @param text Текст комментария
         */
        updateComment(commentId: string, text: string): JQueryDeferred<{}>;
        /**
         * Удаление комментария
         * @param commentId Идентификатор комментария
         */
        deleteComment(commentId: string): JQueryDeferred<{}>;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Кнопка]{@link CustomButton}.
     */
    class CustomButtonParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Текст, отображаемый в Кнопке. */
        text?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /** Имя CSS класса, в котором определен путь к иконке, отображаемой в Кнопке. */
        iconClass?: string;
        /** Флаг, определяющий, что Кнопка может быть нажата: true - разрешено (разрешена настроенная операция редактирования), false - не разрешено. */
        canClick?: boolean;
        /**
         * Флаг, указывающий, что для Кнопки должен применяться основной стиль карточки:
         * true - использовать основной стиль,
         * false - использовать стандартный стиль.
         *
         * Если свойство primary в значении true, то при открытии карточки определенного типа,
         * к кнопке будет применен стиль с названием `.ИМЯ_СТИЛЯ_КАРТОЧКИ button.button-helper.primary-button`.
         * Данный стиль предопределен для типов карточек: Документ, Задание и Группа заданий.
         * Чтобы создать основной стиль Кнопки для собственного типа, добавьте CSS класс:
         *
         *    `.document button.button-helper.primary-button {
         *    color: white;
         *    background: rgba(0, 149, 218, 0.8);
         *    }
         *    .document button.button-helper.primary-button.disabled { color: lightgray; }`
         *
         */
        primary?: boolean;
        /**
         * Флаг, указывающий, должна ли Кнопка "растягиваться" на всю доступную ширину:
         * true - кнопка будет занимать всю доступную ширину,
         * false - ширина кнопки определяется содержимым.
         */
        stretchWidth?: boolean;
        /** Сервисы. */
        services?: $EditOperationStore;
    }
    /**
     * Класс элемента управления Кнопка.
     *
     * Добавляет в web-разметку кнопку для вызова произвольной функции из скрипта карточки.
     */
    class CustomButton extends BaseControl<CustomButtonParams, CustomButtonState> {
        constructor(props: CustomButtonParams);
        protected createParams(): CustomButtonParams;
        private readonly myControlImpl;
        private bindingEditOperation;
        /**
         * Вызывает настроенный обработчик нажатия Кнопки.
         */
        performClick(): void;
        /** @internal */
        protected createImpl(): CustomButtonImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface CustomButtonState extends CustomButtonParams, BaseControlState {
        loading: boolean;
    }
    /** @internal */
    type CustomButtonImplState = CustomButtonState;
    /** @internal */
    class CustomButtonImpl extends BaseControlImpl<CustomButtonParams, CustomButtonState> {
        constructor(props: CustomButtonParams, state: CustomButtonState);
        /** @notest */
        /** @notest */
        loading: boolean;
        performClick(event?: React.MouseEvent<any>): void;
        protected getCssClass(): string;
        /** Переопределяет базовый метод, отменяя его логику (для данного контрола она отлична от базовой версии). */
        protected handleClick(event: React.MouseEvent<any>): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Дата/время]{@link DateTimePicker}.
     */
    class DateTimePickerParams extends InputBasedControlParams<Date> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Режим представления данных в элементе управления. */
        dateTimePickerMode?: GenModels.DateTimePickerType;
        /** @deprecated Синоним defaultCurrentDate. Начиная с WebClient 11 выбором времени управляет параметр {link defaultTime}. */
        defaultCurrentDateTime?: boolean;
        /**
         * Флаг, указывающий, что для значения по умолчанию должны использоваться текущая дата: true - использовать текущие дату,
         * false - использовать предустановленное {@link defaultDateTime} в значение.
         */
        defaultCurrentDate?: boolean;
        /** Возвращает строку с датой и временем, которые по умолчанию устанавливаются в значение.*/
        defaultDateTime?: string;
        /** Возвращает смещение времени (в часах) для значения времени по умолчанию.
         *
         * Значение *defaultDateTimeShift* прибавляется к часам в значении {@link defaultDateTime}.
         * В элементе управления отображается итоговое значение.
         */
        defaultDateTimeShift?: number;
        /** Возвращает максимальная дату, которая может быть выбрана. */
        minDate?: Date;
        /** Возвращает минимальную дату, которая может быть выбрана. */
        maxDate?: Date;
        /** Время, которое будет установлено по умолчанию при выборе даты. */
        defaultTime?: GenModels.DateTimeDefaultTimeModes;
        /** Настройка рабочего времени по умолчанию. */
        defaultWorkTimeSettings?: GenModels.CalendarWorkTime;
        /**
         * Выделять значение особым образом, если оно меньше чем текущая дата.
         * Для задания собственного выделения используйте класс 'overdue', добавляемый к контролу. Например:
         *
         *      .system-datetimepicker.highlight-overdue.overdue:not(.edit-mode) .labeled-text-helper .text-cell .labeled-text {
         *          font-weight: bold;
         *          color: red;
         *      }
         *
         */
        highlightOverdue?: boolean;
        /** Сервисы. */
        services?: $LayoutInfo & $BusinessCalendarController & $EditOperationStore & $Router;
    }
    /**
     * Класс элемента управления Дата/время.
     *
     * Добавляет в web-разметку элемент управления для изменения значения даты и времени.
     */
    class DateTimePicker extends InputBasedControl<Date, DateTimePickerParams, DateTimePickerState> {
        protected createParams(): DateTimePickerParams;
        protected getServices(): $LayoutInfo & $BusinessCalendarController & $EditOperationStore & $Router;
        private readonly dateTimePickerImpl;
        private dateTimePickerBinding;
        private defaultDateTimeBinding;
        protected defaultValue: Date;
        private defaultWorkTimeBinding;
        private dateTimePickerMode;
        private readonly defaultCurrentDateTime;
        /**
         * Проверяет возможность очистки значения элемента управления.
         * @return true - значение может быть очищено (если оно установлено и его можно изменять), false - если значение не может быть очищено.
         */
        canClear(): boolean;
        /**
         * Очищает значение (выбранную дату).
         */
        clear(): void;
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected createImpl(): DateTimePickerImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface DateTimePickerState extends DateTimePickerParams, InputBasedControlState<Date> {
        binding: IBindingResult<Date>;
        showClearButton: boolean;
        timeInput: HTMLInputElement;
        dateTimeFormat: DateTimeFormat;
        timeInputText: string;
        clearButton: HTMLElement;
        loadingCalendarSettings: RequestHelper;
        worktimeSettings: GenModels.CalendarYearSettings[];
        currentValueDefaultTime: Date;
        services?: $LayoutInfo & $BusinessCalendarController & $EditOperationStore & $Router;
    }
    /** @internal */
    type DateTimePickerImplState = DateTimePickerState;
    /** @internal */
    class DateTimePickerImpl extends InputBasedControlImpl<Date, DateTimePickerParams, DateTimePickerState> {
        constructor(props: DateTimePickerParams, state: DateTimePickerState);
        componentDidMount(): void;
        componentWillUnmount(): void;
        protected addGlobalListeners(): void;
        protected removeGlobalListeners(): void;
        protected getTextValue(): string;
        protected renderInto(props: DateTimePickerParams, container: HTMLElement): void;
        getDefaultValue(): Date;
        protected getDateString(): string;
        protected getTimeString(): string;
        protected readonly dateInput: HTMLInputElement;
        protected onInPlaceEditOpened(): void;
        protected onEditPopoverShowed(control: any): void;
        protected onPlaceholderClick(event: any): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<Date, DateTimePickerParams, DateTimePickerState>>;
        setValue(value: Date, redraw: boolean): void;
        protected onSelectedDate(newValue: Date): void;
        protected setTimeFor(date: Date, time: Date): Date;
        protected getDefaultTime(newValue: Date, loadSettings: boolean, onLoaded?: () => void): Date;
        protected timeIsEqual(date1: Date, date2: Date): boolean;
        protected updateTimeForSelectedDate(date: Date): Date;
        protected getTimeFromWorkTime(mode: GenModels.DateTimeDefaultTimeModes, workTime: GenModels.CalendarWorkTime): Date;
        protected loadWorktimeSettings(year: number): JQueryDeferred<GenModels.CalendarYearSettings[]>;
        /**
         * From DatepickerControl.ts Initialize()
         * @deprecated Use this.initializeJQueryDatePicker instead
         */
        protected initializeJQuryDatePicker(): void;
        /** From DatepickerControl.ts Initialize() */
        protected initializeJQueryDatePicker(): void;
        showDatePicker(): void;
        hideDatePicker(): void;
        protected onDateInputClick(): void;
        protected onDateInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected onCalendarIconClick(): void;
        protected onTimeInputKeypress(ev: React.KeyboardEvent<any>): void;
        protected hideCalendar(): void;
        protected onTimeInputChange(ev: React.ChangeEvent<any>): void;
        protected processTimeInputChange(newText: string, input: HTMLInputElement, newCursorPos?: number): void;
        protected onTimeInputBlur(): void;
        protected isOverdue(): boolean;
        protected getCssClass(): string;
        protected renderInputWithPlaceholder(): JSX.Element;
        protected renderInput(): React.ReactNode;
        clear(): void;
        canClear(): boolean;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Подразделение]{@link Department}.
     */
    class DepartmentParams extends InputBasedControlParams<GenModels.DepartmentModel> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Флаг, указывающий, что из справочника разрешено выбирать организации: true - разрешено, false - не разрешено. */
        selectOrganisations?: boolean;
        /** Флаг, указывающий, что из справочника разрешено выбирать подразделения: true - разрешено, false - не разрешено. */
        selectDepartments?: boolean;
        /** Справочник, из которого осуществляется выбор организации/подразделения. */
        source?: GenModels.DepartmentDataSource;
        /** Флаг, указывающий на состояние окна выбора организации/подразделения: true - открыто, false - закрыто. */
        isDictionaryShown?: boolean;
        /** Режим диалога */
        dialogMode?: GenModels.DepartmentDialogMode;
        /** Задержка перед поиском (в мс) */
        searchDelay?: number;
        /** Сервисы. */
        services?: $LayoutStaffController & $EditOperationStore & $LayoutInfo;
    }
    /**
     * Класс элемента управления Подразделение.
     *
     * Добавляет в web-разметку поле ввода с кнопкой вызова диалогового окна для выбора записи из *Справочника сотрудников* или *Справочника контрагентов*.
     */
    class Department extends InputBasedControl<GenModels.DepartmentModel, DepartmentParams, DepartmentState> {
        protected createParams(): DepartmentParams;
        private readonly departmentImpl;
        protected getServices(): $LayoutStaffController & $EditOperationStore & $LayoutInfo;
        private DepartmentBinding;
        /** Показано ли модальное окно выбора организации/подразделения. */
        readonly isDictionaryShown: boolean;
        /**
         * Проверяет возможность открытия модального окна выбора организации/подразделения.
         * @return true - возможно (если значение редактируемое), false - невозможно.
         */
        canShowDictionary(): boolean;
        /**
         * Открывает окно выбора организации/подразделения.
         */
        showDictionary(): void;
        /**
         * Закрывает окно выбора организации/подразделения.
         */
        hideDictionary(): void;
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected createImpl(): DepartmentImpl;
    }
}
declare namespace WebClient {
    namespace DepartmentHelpers {
        /** @internal */
        interface IDepartmentFilterProps {
            predefinedFilter?: GenModels.DepartmentModel;
            selectedFilterPath: GenModels.DepartmentModel[];
            readonly?: boolean;
            rootLabel: string;
            rootTip?: string;
            onSelectedFilterPathChange: (newPath: GenModels.DepartmentModel[]) => void;
        }
        interface IDepartmentFilterState {
        }
        /** @internal */
        class DepartmentFilter extends React.Component<IDepartmentFilterProps, IDepartmentFilterState> {
            protected onFilterItemClick: (item: GenModels.DepartmentModel) => void;
            render(): JSX.Element;
        }
        function getFilterPath(predefinedFilter: GenModels.DepartmentModel, selectedFilterPath: GenModels.DepartmentModel[]): GenModels.DepartmentModel[];
        function getFilterId(predefinedFilter: GenModels.DepartmentModel, selectedFilterPath: GenModels.DepartmentModel[]): string | undefined;
        function getFilter(predefinedFilter: GenModels.DepartmentModel, selectedFilterPath: GenModels.DepartmentModel[]): GenModels.DepartmentModel | undefined;
    }
}
declare namespace WebClient {
    namespace DepartmentHelpers {
        /** @internal */
        interface IDepartmentFilterViewProps {
            predefinedFilter?: GenModels.DepartmentModel;
            selectedFilterPath: GenModels.DepartmentModel[];
            readonly?: boolean;
            rootLabel: string;
            rootTip?: string;
            /** При выборе элемента */
            onFilterItemClick?: (item: GenModels.DepartmentModel | null) => void;
        }
        /** @internal */
        const DepartmentFilterView: (props: IDepartmentFilterViewProps) => JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface DepartmentState extends DepartmentParams, InputBasedControlState<GenModels.DepartmentModel> {
        binding: IBindingResult<GenModels.DepartmentModel>;
        requestHelper: RequestHelper;
        directoryDialogOpen: boolean;
        directoryDialogSelectedValue: GenModels.DepartmentModel;
        inputKeyDown: SimpleEvent<React.KeyboardEvent<any>>;
    }
    /** @internal */
    type DepartmentImplState = DepartmentState;
    /** @internal */
    class DepartmentImpl extends InputBasedControlImpl<GenModels.DepartmentModel, DepartmentParams, DepartmentState> {
        static FirstPageSize: number;
        static NextPageSize: number;
        private typeahead;
        constructor(props: DepartmentParams, state: DepartmentState);
        protected readonly source: GenModels.DepartmentDataSource;
        protected getTextValue(): string;
        protected getValueTitle(): string;
        protected getInputTitle(): string;
        protected renderInto(props: DepartmentParams, container: HTMLElement): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<GenModels.DepartmentModel, DepartmentParams, DepartmentState>>;
        protected readonly itemTypes: GenModels.SearchDepartmentType;
        protected findItems(typeaheadQuery: ITypeaheadSearchQuery): JQueryDeferred<ITypeaheadSearchResult>;
        protected onSelected(variant: ITypeaheadVariant): void;
        showDictionary(): void;
        hideDictionary(): void;
        protected attachTypeahed(t: Typeahead): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected onDirectoryDialogNodeSelected(node: GenModels.DepartmentModel): void;
        protected onDirectoryDialogNodeAccepted(node: GenModels.DepartmentModel): void;
        protected onDirectoryDialogSelectButtonClick(): void;
        protected onInputChange(event: any): void;
        readonly isDictionaryShown: boolean;
        protected renderInputWithPlaceholder(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Строка конструктора справочников]{@link DirectoryDesignerRow}.
     */
    class DirectoryDesignerRowParams extends InputBasedControlParams<GenModels.DirectoryDesignerRowModel> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Флаг, указывающий на состояние окна выбора строки: true - открыто, false - закрыто. */
        isDictionaryShown?: boolean;
        /** Идентификатор узла Конструктора справочников, из которого выбираются записи.
        *
        * Если ограничение по узлам отсутствует, то свойство имеет значение Guid.Empty.
        */
        itemType?: string;
        /**  Область выбора (и поиска) элементов из Конструктора справочников. */
        selectionArea?: GenModels.DirectoryDesignerSearchArea;
        /** Задержка перед поиском (в мс) */
        searchDelay?: number;
        /** Сервисы. */
        services?: $LayoutDirectoryDesignerController & $EditOperationStore & $LayoutInfo;
    }
    /**
     * Класс элемента управления Строка конструктора справочников.
     *
     * Добавляет в web-разметку поле ввода с кнопкой вызова диалогового окна для выбора записи из *Конструктора справочников*.
     */
    class DirectoryDesignerRow extends InputBasedControl<GenModels.DirectoryDesignerRowModel, DirectoryDesignerRowParams, DirectoryDesignerRowState> {
        private readonly departmentImpl;
        protected createParams(): DirectoryDesignerRowParams;
        protected getServices(): $LayoutDirectoryDesignerController & $EditOperationStore & $LayoutInfo;
        private DirectoryDesignerRowBinding;
        private DefaultBindingHandler;
        private DefaultHandler;
        readonly isDictionaryShown: boolean;
        /**
         * Проверяет возможность открытия модального окна выбора строки.
         * @return true - возможно (если значение редактируемое), false - невозможно.
         */
        canShowDictionary(): boolean;
        /**
         * Открывает окно выбора строки.
         */
        showDictionary(): void;
        /**
         * Закрывает окно выбора строки.
         */
        hideDictionary(): void;
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected createImpl(): DirectoryDesignerRowImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface DirectoryDesignerRowState extends DirectoryDesignerRowParams, InputBasedControlState<GenModels.DirectoryDesignerRowModel> {
        binding: IBindingResult<GenModels.DirectoryDesignerRowModel>;
        dialog: ModalWindow;
        requestHelper: RequestHelper;
        inputKeyDown: SimpleEvent<React.KeyboardEvent<any>>;
    }
    /** @internal */
    type DirectoryDesignerRowImplState = DirectoryDesignerRowState;
    /** @internal */
    class DirectoryDesignerRowImpl extends InputBasedControlImpl<GenModels.DirectoryDesignerRowModel, DirectoryDesignerRowParams, DirectoryDesignerRowState> {
        static FirstPageSize: number;
        static NextPageSize: number;
        private typeahead;
        constructor(props: DirectoryDesignerRowParams, state: DirectoryDesignerRowState);
        protected getTextValue(): string;
        protected renderInto(props: DirectoryDesignerRowParams, container: HTMLElement): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<GenModels.DirectoryDesignerRowModel, DirectoryDesignerRowParams, DirectoryDesignerRowState>>;
        protected findItems(typeaheadQuery: ITypeaheadSearchQuery): JQueryDeferred<ITypeaheadSearchResult>;
        protected onSelected(variant: ITypeaheadVariant): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        readonly isDictionaryShown: boolean;
        protected attachTypeahead(t: Typeahead): void;
        showDictionary(): void;
        protected renderInputWithPlaceholder(): React.ReactNode;
        canShowDictionary(): boolean;
        hideDictionary(): void;
        protected onInputChange(event: any): void;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Раскрывающийся список]{@link Dropdown}.
    */
    class DropdownParams extends InputBasedControlParams<string> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Список элементов, доступных для выбора */
        items: GenModels.Element[];
        /** @deprecated Используйте {@link items}*/
        elements?: GenModels.Element[];
        /** Флаг развернутости Раскрывающегося списка */
        isCollapsed?: boolean;
        /** Доступно ли нулевое значение для выбора. Как правило значение сооветствует настройкам привязанного поля карточки в метаданных. */
        isEmptyKeyAllowed?: boolean;
        /** Событие возникает при сворачивании Раскрывающегося списка. */
        collapsing?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после сворачивания Раскрывающегося списка. */
        collapsed?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при разворачивании Раскрывающегося списка. */
        expanding?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после разворачивания Раскрывающегося списка. */
        expanded?: BasicApiEvent<IEventArgs>;
        /** Сервисы. */
        services?: $EditOperationStore & $LayoutInfo;
    }
    /**
     * Класс элемента управления Раскрывающийся список.
     */
    class Dropdown extends InputBasedControl<string, DropdownParams, DropdownState> {
        protected createParams(): DropdownParams;
        protected getServices(): $EditOperationStore & $LayoutInfo;
        private setElements;
        private readonly getElements;
        private setBinding;
        private setDefault;
        protected getBindings(): IBindingResult<any>[];
        protected getDefault(): string;
        /** @internal */
        protected createImpl(): DropdownImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface DropdownState extends DropdownParams, InputBasedControlState<string> {
        binding: IBindingResult<string>;
    }
    /** @internal */
    type DropdownImplState = DropdownState;
    /** @internal */
    class DropdownImpl extends InputBasedControlImpl<string, DropdownParams, DropdownState> {
        /**
         * Корневой узел дропдауна
         */
        protected el: HTMLElement;
        /**
         * Сфокусированный элемент
         */
        protected focusedElement: GenModels.BindingMetadata;
        /**
         * Заголовок комбобокса
         */
        protected comboboxTitle: ComboBoxTitle;
        /**
         * Предыдущий сфокусированный элемент (глобально)
         */
        protected prevActiveElement: HTMLElement;
        protected prevActiveElementEvent: (event: FocusEvent) => void;
        static readonly EMPTY_ELEMENT: GenModels.BindingMetadata;
        constructor(props: DropdownParams, state: DropdownState);
        componentWillMount(): void;
        componentWillUnmount(): void;
        protected handleDocumentClick: (event?: Event) => void;
        protected handleDocumentFocus: (event: FocusEvent) => void;
        setValue(value: string, redraw: boolean): void;
        protected getTextValue(): string;
        protected onDropdownContainerClick(e?: any): void;
        protected onElementClick(element: GenModels.BindingMetadata): void;
        protected onClearValueClick(e: React.MouseEvent<any>): void;
        protected onPlaceholderClick(event: any): void;
        protected toggleCollapsed: () => CancelableEventArgs<IEventArgs>;
        protected expandDropdown: () => CancelableEventArgs<IEventArgs>;
        protected collapseDropdown: () => CancelableEventArgs<IEventArgs>;
        protected onCloseDropdownTriggered: () => void;
        protected isNotSameDropdown: (target: HTMLElement) => boolean;
        protected onInputFocus(event: React.FocusEvent<any>): void;
        protected onInputBlur(event: React.FocusEvent<any>): void;
        /**
         * При фокусе элемента списка
         * @param event Событие фокуса
         * @param element Текущий элемент
         */
        protected onFocusElement: (event: React.FocusEvent<any>, element: GenModels.BindingMetadata) => void;
        /**
         * При снятии фокуса у элемента списка
         * @param event Событие снятия фокуса
         * @param element Текущий элемент
         */
        protected onBlurElement: (event: React.FocusEvent<any>, element: GenModels.BindingMetadata) => void;
        /**
         * При фокусе соседнего элемента в списке
         * @param element Текущий элемент
         * @param mode Какой из соседних элементов должен получить фокус (предыдущий или следующий)
         */
        protected onFocusSiblingElement: (element: GenModels.BindingMetadata, mode: "next" | "prev") => void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<string, DropdownParams, DropdownState>>;
        protected renderInto(props: DropdownParams, container: HTMLElement): void;
        protected renderInput(): React.ReactNode;
        protected renderPlaceholder(): any;
    }
}
declare namespace WebClient {
    /** @internal */
    class EmployeeLoader {
        private employeeVisualizer;
        private favoritesStorage;
        private mUnitId;
        private mKindId;
        services: $LayoutStaffController;
        constructor(employeeVisualizer: EmployeeVisualizer, favoritesStorage?: FavoriteEmployeesStorage, mUnitId?: string, mKindId?: string, services?: $LayoutStaffController);
        unitId: string;
        readonly kindId: string;
        findItems(query: ITypeaheadSearchQuery, skipEmployees?: string[]): JQueryDeferred<ITypeaheadSearchResult>;
        protected convertFindResultItem(data: GenModels.EmployeeModel): GenModels.EmployeeDataModel;
    }
}
declare namespace WebClient {
    /** @internal */
    class EmployeeVisualizer {
        tipMode: GenModels.PartnerTipModeItems;
        viewMode: GenModels.EmployeeViewMode;
        constructor(tipMode: GenModels.PartnerTipModeItems, viewMode?: GenModels.EmployeeViewMode);
        getTooltip(employeeData: GenModels.EmployeeDataModel | GenModels.EmployeeModel): string;
        getDisplayName(employee: GenModels.EmployeeDataModel | GenModels.EmployeeModel): string;
    }
}
declare namespace WebClient {
    /** @internal */
    class FavoriteEmployeesStorage {
        private storageName;
        private services;
        constructor(storageName: string, services: $LocalStorage);
        getFavorites(query: ITypeaheadSearchQuery): GenModels.EmployeeDataModel[];
        favoriteEmployees: GenModels.EmployeeDataModel[];
        addToFavorite(item: GenModels.EmployeeDataModel): void;
        private arrayUnique(array);
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Список файлов]{@link FileListControl}.
     */
    class FileListControlParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Общее количество файлов */
        totalCount: number;
        /** Выбранные файлы. */
        files: FileListItem[];
        /** Флаг, указывающий на наличие ЭЦП на основных файлах: true - файлы подписаны, false - не подписаны. */
        hasAnySignature: boolean;
        /** Флаг, определяющий раскрыт ли блок со списком основных файлов: true - раскрыт, false - свернут. */
        mainFilesExpanded: boolean;
        /** Флаг, определяющий раскрыт ли блок со списком дополнительных файлов: true - раскрыт, false - свернут. */
        extraFilesExpanded: boolean;
        /** Флаг, определяющий отображается ли меню добавления файлов: true - отображается, false - скрыто. */
        fileCommandBarExpanded: boolean;
        /** Флаг, определяющий отображается ли меню подписания файлов: true - отображается, false - скрыто. */
        signCommandBarExpanded: boolean;
        /** Возвращает режим редактирования элемента управления. */
        editMode: EditMode;
        /** Флаг, указывающий, разрешено ли добавлять основные файлы: true - разрешено, false - не разрешено. */
        canAddMain: boolean;
        /** Флаг, указывающий, разрешено ли добавлять дополнительные файлы: true - разрешено, false - не разрешено. */
        canAddExtra: boolean;
        /** Флаг, указывающий, разрешено ли подписывать файлы: true - разрешено, false - не разрешено. */
        canSign: boolean;
        /** Флаг, указывающий, разрешено ли открывать журнал подписей: true - разрешено, false - не разрешено. */
        canViewSign: boolean;
        /** Событие возникает при добавлении основного файла. */
        mainFileAdding: CancelableApiEvent<IMainFileAddingArgs>;
        /** Событие возникает при добавлении дополнительного файла. */
        extraFileAdding: CancelableApiEvent<IExtraFileAddingArgs>;
        /** Событие возникает при удалении основного файла. */
        mainFileDeleting: CancelableApiEvent<IMainFileDeletingArgs>;
        /** Событие возникает при удалении дополнительного файла. */
        extraFileDeleting: CancelableApiEvent<IExtraFileDeletingArgs>;
        /** Событие возникает при скачивании версии файла. */
        fileVersionDownloading: CancelableApiEvent<IFileVersionDownloadingArgs>;
        /** Событие возникает при загрузке версии файла. */
        fileVersionUploading: CancelableApiEvent<IFileVersionUploadingArgs>;
        /** Событие возникает при открытии файла через WebDAV. */
        fileOpening: CancelableApiEvent<IFileOpeningArgs>;
        /** Событие возникает при открытии журнала подписей. */
        signatureListViewing: CancelableApiEvent<ISignatureListViewingArgs>;
        /** Событие возникает при подписании файла. */
        signatureCreating: CancelableApiEvent<ISignatureCreatingArgs>;
        /** Событие возникает при добавлении комментария к версии файла. */
        fileVersionCommentAdding: CancelableApiEvent<IFileVersionCommentAddingArgs>;
        /** Событие возникает при удалении комментария к версии файла. */
        fileVersionCommentDeleting: CancelableApiEvent<IFileVersionCommentDeletingArgs>;
        /** Событие возникает при открытии окна предварительного просмотра файла. */
        filePreviewing: CancelableApiEvent<IFilePreviewingArgs>;
        /** Событие возникает после удаления основного файла. */
        mainFileDeleted: BasicApiEvent<IMainFileDeletedArgs>;
        /** Событие возникает после удаления дополнительного файла. */
        extraFileDeleted: BasicApiEvent<IExtraFileDeletedArgs>;
        /** Событие возникает после скачивания версии файла. */
        fileVersionDownloaded: BasicApiEvent<IFileVersionDownloadedArgs>;
        /** Событие возникает после загрузки версии файла. */
        fileVersionUploaded: BasicApiEvent<IFileVersionUploadedArgs>;
        /** Событие возникает после открытии файла через WebDAV. */
        fileOpened: BasicApiEvent<IFileOpenedArgs>;
        /** Событие возникает после открытия журнала подписей. */
        signatureListViewed: BasicApiEvent<ISignatureListViewedArgs>;
        /** Событие возникает после подписания файла. */
        signatureCreated: BasicApiEvent<ISignatureCreatedArgs>;
        /** Событие возникает после добавления комментария к версии файла. */
        fileVersionCommentAdded: BasicApiEvent<IFileVersionCommentAddedArgs>;
        /** Событие возникает после удаления комментария к версии файла. */
        fileVersionCommentDeleted: BasicApiEvent<IFileVersionCommentDeletedArgs>;
        /** Событие возникает после добавления основного файла. */
        mainFileAdded: BasicApiEvent<IMainFileAddedArgs>;
        /** Событие возникает после добавления дополнительного файла. */
        extraFileAdded: BasicApiEvent<IExtraFileAddedArgs>;
        /** Событие возникает после открытия окна предварительного просмотра файла. */
        filePreviewed: BasicApiEvent<IFilePreviewedArgs>;
        /** Сервисы. */
        services?: $DocumentCardController & $FileController & $LayoutFileController & $RequestManager & $CardId & $RealtimeCommunicationService & $Router & $DeviceType;
    }
    /** @internal */
    interface FileListControlState extends FileListControlParams, BaseControlState {
        logic: FileListControlLogic;
        autoUpload: boolean;
    }
    /**
     * Класс элемента управления Список файлов.
     *
     * Добавляет в web-разметку компонент для управления основными и дополнительныеми файлами карточки.
     * В разметку режима чтения добавляет компонент для добавления основных файлов.
     */
    class FileListControl extends BaseControl<FileListControlParams, FileListControlState> {
        protected fileCommentWindowCloser: () => void;
        /** @internal */
        componentWillUnmount(): void;
        protected createParams(): FileListControlParams;
        protected createImpl(): FileListControlImpl;
        private readonly fileListImpl;
        private bindingEditOperation;
        /** Установка раскрытости основных файлов. */
        mainFilesExpanded: boolean;
        /** Установка раскрытости остальных файлов. */
        extraFilesExpanded: boolean;
        /** Установка раскрытости панели управления для работы с файлами. */
        fileCommandBarExpanded: boolean;
        /** Установка раскрытости панели управления для работы с подписями. */
        signCommandBarExpanded: boolean;
        /**
         * Открывает меню добавления основных файлов.
         */
        openAddMainFileDialog(): void;
        /**
         * Открывает меню добавления дополнительных файлов.
         */
        openAddExtraFileDialog(): void;
        /**
         * Открывает журнал подписей.
         */
        openSignListDialog(): void;
        /**
         * Открывает диалоговое окно подписания файлов.
         */
        openSignDialog(): void;
        /**
         * Проверяет возможность открытия указанного файла.
         * @param fileItem Файл.
         * @return true - открытие возможно, иначе - false.
         */
        canRead(fileItem: FileListItem): boolean;
        /**
         * Проверяет возможность редактирования указанного файла.
         * @param fileItem Файл.
         * @return true - редактирование возможно, иначе - false.
         */
        canEdit(fileItem: FileListItem): boolean;
        /**
         * Проверяет возможность удаления указанного файла.
         * @param fileItem Файл.
         * @return true - удаление возможно, иначе - false.
         */
        canDelete(fileItem: FileListItem): boolean;
        /**
         * Проверяет возможность блокировки указанного файла.
         * @param fileItem Файл.
         * @return true - блокировка возможна, иначе - false.
         */
        canLock(fileItem: FileListItem): boolean;
        /**
         * Проверяет возможность комментирования указанного файла.
         * @param fileItem Файл.
         * @return true - комментирование возможно, иначе - false.
         */
        canComment(fileItem: FileListItem): boolean;
        /**
         * Удаляет файл из списка.
         * @param fileItem Файл.
         */
        removeFile(fileItem: FileListItem): JQueryDeferred<any>;
        /**
         * Блокирует файл.
         * @param fileItem файл.
         */
        lockFile(fileItem: FileListItem): void;
        /**
         * Снимает установленную блокировку с файла.
         * @param fileItem Файл.
         */
        unlockFile(fileItem: FileListItem): void;
        /**
         * Открывает диалоговое окно комментирования версии файла.
         * @param fileItem Файл.
         * @param fileVersion Версия файла. Если пропущен, то будет комментироваться текущая версия.
         */
        openCommentsDialog(fileItem: FileListItem, fileVersion?: GenModels.VersionedFileModel): void;
        /**
         * Проверяет раскрыт ли список версий указанного файла.
         * @param fileItem Файл.
         * @return true - раскрыт, false - свернут.
         */
        getVersionsListExpanded(fileItem: FileListItem): boolean;
        /**
         * Сворачивает раскрытый список версий файлов или раскрывает свернутый.
         * @param fileItem Файл.
         */
        toggleVersionsList(fileItem: FileListItem): void;
        /**
         * Открывает предварительный просмотр указанной версии файла.
         * @param fileItem Файл.
         * @param fileVersion Версия файла. Если пропущен, то будет открыта текущая версия.
         */
        openPreview(fileItem: FileListItem, fileVersion?: GenModels.VersionedFileModel): void;
        /**
         * Скачивает (на компьютер) указанную версию файла.
         * @param fileItem Файл.
         * @param fileVersion Версия файла. Если пропущен, то будет скачана текущая версия.
         */
        download(fileItem: FileListItem, fileVersion?: GenModels.VersionedFileModel): void;
        /**
         * Открывает файл с использованием технологии WebDAV.
         * @param fileItem Файл.
         */
        openWebDav(fileItem: FileListItem): void;
        /** @inheritDoc */
        init(): void;
        /** @internal */
        onSaved(): JQueryDeferred<any>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface FileListControlState extends BaseControlImplState, FileListControlParams {
        logic: FileListControlLogic;
        autoUpload: boolean;
        /** Загружены ли оставшиеся файлы в данный момент */
        isLeftFilesLoaded: boolean;
    }
    type FileListImplState = FileListControlState;
    interface ICardChangedByWebDavMessage {
        OwnerCardId: string;
    }
    /** @internal */
    class FileListControlImpl extends BaseControlImpl<FileListControlParams, FileListControlState> {
        mainAttach: FileListAttachedElements;
        extraAttach: FileListAttachedElements;
        signButton: HTMLElement;
        viewSignButton: HTMLElement;
        fileSignLogic: FileSign;
        readonly logic: FileListControlLogic;
        constructor(props: FileListControlParams, state: FileListControlState);
        componentDidMount(): void;
        componentWillUnmount(): void;
        init(): void;
        protected onDocumentChangedByWebdav(msg: IRealTimeCommunicationMessage<ICardChangedByWebDavMessage>): void;
        protected getCssClass(): string;
        protected getFilesSignInfo(): IFileSignInfo[];
        extraFilesExpanded: boolean;
        fileCommandBarExpanded: boolean;
        /** @deprecated */
        isLeftFilesLoaded: boolean;
        /** @deprecated */
        isLeftFilesLoading: boolean;
        mainFilesExpanded: boolean;
        signCommandBarExpanded: boolean;
        renderUploadForm(attach: FileListAttachedElements, action: string, main: boolean, fileItem?: FileListItem): JSX.Element;
        protected renderEditModeFileList(): JSX.Element;
        protected onDropzoneClick(): void;
        protected renderEditMode(): JSX.Element;
        protected onDocumentClick(ev: any): void;
        onToggleTableClick(main: boolean): void;
        onToggleCommandBarClick(ev?: React.MouseEvent<any>): void;
        onAddClick(main: boolean, ev?: React.MouseEvent<any>): void;
        protected attachSignButton(element: HTMLElement): void;
        protected attachViewSignButton(element: HTMLElement): void;
        protected onSignButtonClick(ev: React.MouseEvent<any>): void;
        onToggleSignPanelClick(ev?: React.MouseEvent<any>): void;
        protected renderViewModeTitle(mainFiles: boolean): JSX.Element;
        protected renderViewModeCommandBar(): JSX.Element;
        protected renderViewModeSignPanel(): JSX.Element;
        protected renderViewModeFilesHeader(): JSX.Element;
        protected renderViewModeFiles(main: boolean): JSX.Element;
        protected renderPlaceholders(): any[];
        protected getLoaderWidth(i: number): number;
        protected renderViewModeMain(): JSX.Element;
        protected renderViewModeExtra(): JSX.Element;
        protected renderViewMode(): JSX.Element;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class FileListControlLogic {
        mainAttach: FileListAttachedElements;
        extraAttach: FileListAttachedElements;
        initialized: boolean;
        lastSaveDeferred: JQueryDeferred<any>;
        parent: FileListControlImpl;
        filesToRemove: FileListItem[];
        constructor();
        init(_mainAttach: FileListAttachedElements, _extraAttach: FileListAttachedElements, _parent: FileListControlImpl): void;
        loadFilesFromModel(model: GenModels.FileListDataModel, oldFiles?: FileListItem[]): FileListItem[];
        loadFileModel(model: GenModels.FileListDataModel, appendFiles?: boolean): void;
        onSaved(): JQueryDeferred<any>;
        uploadNewFiles(): JQueryDeferred<any>;
        sendRequest(sendFunc: () => JQueryDeferred<GenModels.FileListDataModel>, savingItems: FileListItem[]): JQueryDeferred<any>;
        getFiles(mainFiles: boolean): FileListItem[];
        initJQueryUploaderForAddFiles(attach: FileListAttachedElements, main: boolean): void;
        initJQueryUploaderForAddFileVersions(attach: FileListAttachedElements, fileItem: FileListItem): void;
        download(fileItem: FileListItem, fileVersion: GenModels.VersionedFileModel, action: string): void;
        getDownloadUrl(fileItem: FileListItem, fileVersion: GenModels.VersionedFileModel, action: string): string;
        webDav(fileItem: FileListItem, canEdit: boolean): void;
        /**
         * Mark file for remove, or send remove request imediately
         * @param fileItem File to remove
         * @param immediately Send request to the server right now, or wait onSaved
         */
        removeFile(fileItem: FileListItem, immediately: boolean): JQueryDeferred<any>;
        protected removeFileFromServer(fileItem: FileListItem): JQueryDeferred<any>;
        showPreviewIfSupported(fileItem: FileListItem, version?: GenModels.VersionedFileModel): void;
        /** @deprecated  Use {@link Helpers.ShowFilePreview} */
        getFilePreviewUrl(fileItem: FileListItem, action: string, version?: GenModels.VersionedFileModel, pageIndex?: number): string;
        lockFile(fileItem: FileListItem): void;
        unlockFile(fileItem: FileListItem): void;
        showCommentsDialog(fileItem: FileListItem, versionId: string, enableAddComments: boolean): () => void;
        loadFilesPart(skipCount: number, maxCount?: number): JQueryDeferred<void>;
        reloadFiles(): JQueryDeferred<void>;
        protected updateVersionsOnLoad(): void;
        closeAllMenusBut(fileItem: FileListItem): void;
        removeFileItem(index: number): void;
        clearFileItems(): void;
        protected readonly state: FileListImplState;
        protected readonly props: FileListControlParams;
        protected deinitFileItem(item: FileListItem): void;
        protected initJQueryUploader(attach: FileListAttachedElements, options: IFileUploadOptions): void;
        protected onFilesAdded(main: boolean, attach: FileListAttachedElements, e: any, data: any): void;
        protected onFileVersionAdded(fileItem: FileListItem, attach: FileListAttachedElements, data: any): void;
        protected sendFiles(attach: FileListAttachedElements, items: FileListItem[], areVersions?: boolean): JQueryDeferred<any>;
        protected processResponse(responseData: GenModels.FileListDataModel, deferred: JQueryDeferred<any>, uploadingItems: FileListItem[], areVersions?: boolean): void;
        protected getItemsToUpload(): FileListItem[];
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Выбор папки]{@link Folder}.
     */
    class FolderParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /** Текст заполнителя. */
        placeHolder?: string;
        /** Текст метки. */
        labelText?: string;
        /** Флаг, определяющий, что метка должна отображаться, когда значение элемента управления не задано: true - отображать, false - не отображать. */
        showEmptyLabel?: boolean;
        /** Флаг, указывающий, обязательно ли должно быть задано значение элемента управления: true - обязательно, false - не обязательно. */
        required?: boolean;
        /** Возвращает метод выбора папки по умолчанию. */
        folderMode?: GenModels.FolderMode;
        /** Флаг доступности создания карточки в текущей папке */
        currentFolderForbidden?: boolean;
        /** Идентификатор текущей папки */
        currentFolder?: string;
        /** Данные выбранной папки. */
        value?: GenModels.FolderNode;
        /** Идентификатор карточки, для которой выбирается размещение. */
        cardId?: string;
        /** Событие возникает после выбора папки. */
        dataChanged?: BasicApiEvent<IDataChangedEventArgs>;
        /** Сервисы. */
        services?: $LayoutFolderController & $CardInfo & $LayoutInfo;
    }
    /**
     * Класс элемента управления Выбор папки.
     *
     * Добавляет в web-разметку ссылку, при нажатии которой вызывается диалог выбора папки для размещения создаваемой карточки.
     */
    class Folder extends BaseControl<FolderParams, FolderState> {
        constructor(props: FolderParams);
        protected createParams(): FolderParams;
        private readonly folderImpl;
        private visibility;
        /** Установка значения. */
        value: GenModels.FolderNode;
        /**
         * Закрывает диалоговое окно выбора папки.
         */
        hide(): void;
        /**
         * Отменяет выбор папки.
         */
        clear(): void;
        /**
         * Открывает диалоговое окно выбора папки.
         */
        show(): void;
        /** @inheritDoc */
        onSaving(): JQueryDeferred<any>;
        /** @inheritDoc */
        validate(params: IValidationParams): IValidationResult[];
        protected checkFolderForAvailable(folderId: string): JQueryDeferred<GenModels.CheckResult>;
        /** @inheritDoc */
        init(): void;
        /** @internal */
        protected createImpl(): FolderImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface FolderState extends FolderParams, BaseControlState {
        checkFolderForAvailable: (folderId: string) => JQueryDeferred<GenModels.CheckResult>;
        dialog: ModalWindow;
        validationMessage: string;
    }
    /** @internal */
    type FolderImplState = FolderState;
    /** @internal */
    class FolderImpl extends BaseControlImpl<FolderParams, FolderState> {
        constructor(props: FolderParams, state: FolderState);
        componentDidMount(): void;
        show(): void;
        hide(): void;
        clear(): void;
        validate(params: IValidationParams): IValidationResult;
        protected handleDataChanged(eventArgs: IDataChangedEventArgs): void;
        protected renderValidationMessage(): JSX.Element;
        protected updateValidationMessage(): void;
        value: GenModels.FolderNode;
        changeFolder(newFolder: GenModels.FolderNode): void;
        protected onFolderSelected(controlInModal: FolderModal, window: ModalWindow): void;
        protected selectFolder(folderId: string): Promise<void>;
        protected getFolderInfo(folderId: string): JQueryDeferred<GenModels.FolderNode>;
        protected renderLabel(): JSX.Element;
        protected renderValue(): JSX.Element;
        protected renderClearButton(): JSX.Element;
        protected getCssClass(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [История]{@link History}.
     */
    class HistoryParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Текст, отображаемый в кнопке. */
        buttonText?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /**
         * Флаг, определяющий, что пользователь может просматривать историю:
         * true - разрешено (разрешена настроенная операция редактирования),
         * false - не разрешено.
         */
        canViewHistory?: boolean;
        /** Показывать таблицу с записями на странице или нет. По умолчанию - нет. */
        showPreview?: boolean;
        /** Количество записей, загружаемых с сервера за раз. */
        recordsOnPage?: number;
        /** Отображаемые в данный момент записи истории. */
        records?: GenModels.HistoryRecord[];
        /** Сотрудник, по которому производится фильтрация записей в текущий момент. */
        authorFilterValue?: GenModels.EmployeeDataModel;
        /** Дата, по которой производится фильтрация записей в текущий момент. */
        dateFilterValue?: string;
        /** Текст события, по которому производится фильтрация записей в текущий момент. */
        eventFilterValue?: string;
        /** Показывать кнопку "показать еще" на странице или нет. По умолчанию: false */
        showMoreButtonInPreview?: boolean;
        /** Показывать кнопку открытия модального окна. По умолчанию - true  */
        showOpenButton?: boolean;
        /** Показывать фильтры на странице или нет. По умолчанию - false */
        showFiltersInPreview?: boolean;
        /** Идентификатор карточки. Необходим только в случае, когда контрол находится вне разметки. */
        cardId?: string;
        /** Массив идентификаторов операций, которые не отображаются в элементе управления */
        operationsToHide: string[];
        /** Событие, возникающее после изменения списка отображаемых записей истории (см. {@link records})
          * (например, при применении фильтра или подгрузке новых страниц).
          */
        recordsChanged?: BasicApiEvent<IRecordsChangedEventArgs>;
        /** Событие, возникающее перед открытием окна с историей. */
        windowOpeninig?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после открытия окна с историей. */
        windowOpened?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед закрытием окна с историей. */
        windowClosing?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после закрытия окна с историей. */
        windowClosed?: BasicApiEvent<IEventArgs>;
        services?: $LayoutHistoryController & Optional<$CardId> & $EditOperationStore;
    }
    /**
     * Класс элемента управления История.
     *
     * Добавляет в web-разметку кнопку для отображения истории операций над карточкой.
     */
    class History extends BaseControl<HistoryParams, HistoryState> {
        constructor(props: HistoryParams);
        /** @internal */
        protected createParams(): HistoryParams;
        private readonly myControlImpl;
        private operationsToHideBinding;
        private binding;
        /** @internal */
        records: GenModels.HistoryRecord[];
        /** @internal */
        recordsOnPage: number;
        /** @internal */
        authorFilterValue: GenModels.EmployeeDataModel;
        /** @internal */
        dateFilterValue: Date;
        /** @internal */
        eventFilterValue: string;
        /** @internal */
        protected readonly currentView: HistoryView;
        /**
         * Открывает окно просмотра истории.
         */
        openHistoryWindow(): void;
        /**
         * Закрывает окно просмотра истории.
         */
        closeHistoryWindow(): void;
        /**
         * Загружает с сервера очередную порцию данных и отображает в интерфейсе.
         * @param pageSize Размер страницы (по умолчанию берется значение соответствующего параметра).
         * @returns JQueryDeferred объект для отслеживания процесса загрузки.
         */
        loadNextPage(pageSize?: number): JQueryDeferred<GenModels.HistorySearchResult>;
        /** @internal */
        createImpl(): HistoryImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    class HistoryExternalRelations {
        private cardId;
        private services;
        constructor(cardId: string, services: $LayoutHistoryController);
        getHistoryRecords(skip: number, maxCount: number, cacheId: string, editOperation: string, hideOperations?: string[], employeeName?: string, date?: Date, eventSearch?: string): JQueryDeferred<GenModels.HistorySearchResult>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface HistoryState extends HistoryParams, BaseControlState {
        external: HistoryExternalRelations;
        /** Записи, которые будут показаны на странице при значении параметра {@link showPreview} = true. */
        previewRecords: GenModels.HistoryRecord[];
        /** Сигнализирует о том, что {@link previewRecords} содержит все записи истории. */
        previewRecordsContainsAllRecords: boolean;
        /** Идентификатор для поиска записей истории в кэше */
        cacheId: string;
        /** Идентификатор операции изменения */
        editOperation: string;
        employeeVisualiser: EmployeeVisualizer;
        modalHost: ModalHost;
        modalView: HistoryView;
        previewView: HistoryView;
    }
    /** @internal */
    interface HistoryImplState extends HistoryState {
        /** Временные записи, которые хранят данные до загрузки this.currentView */
        tempRecordsForView?: GenModels.HistoryRecord[];
    }
    /** @internal */
    class HistoryImpl extends BaseControlImpl<HistoryParams, HistoryImplState> {
        static ModalPageSize: number;
        constructor(props: HistoryParams, state: HistoryImplState);
        componentWillUnmount(): void;
        openHistoryWindow(): void;
        closeHistoryWindow(): void;
        onRecordsChanged(records: GenModels.HistoryRecord[]): void;
        renderModalWindow(): React.ReactNode;
        onButtonClick(event?: React.MouseEvent<any>): void;
        onShowMoreClick(): void;
        protected forceCloseHistoryWindow(): void;
        authorFilterValue: GenModels.EmployeeDataModel;
        dateFilterValue: Date;
        eventFilterValue: string;
        records: GenModels.HistoryRecord[];
        recordsOnPage: number;
        renderControl(): JSX.Element;
        attachModalView(view: HistoryView): void;
        attachPreviewView(view: HistoryView): void;
        protected syncViewWithTempRecords(view: HistoryView): void;
        readonly currentView: HistoryView;
        loadNextPage(pageSize?: number): JQueryDeferred<GenModels.HistorySearchResult>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface HistoryRecordViewProps {
        record: GenModels.HistoryRecord;
        employeeVisualiser: EmployeeVisualizer;
        eventSearch?: string;
        columnsWidth?: string[];
        mobile: boolean;
    }
    /** @internal */
    const HistoryRecordView: (props: HistoryRecordViewProps) => JSX.Element;
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Html виджет]{@link HtmlView}.
     */
    class HtmlViewParams extends BaseControlParams {
        /** Адрес html-ресурса. */
        sourceUrl: string;
        /** В режиме без использования фрейма - содержимое html, расположенного по адресу {@link sourceUrl}. */
        sourceHtml?: string;
        /**
         * Параметр определяет каким образом HTML-содрежимое будет загружено и отображено.
         *
         * - При значении 0 (`HtmlViewMode.FromCard`) - HTML будет загружен из поля карточки, указанного в привязке в конструкторе разметок.
         * - При значении 1 (`HtmlViewMode.FromFile`) - HTML будет загружен из файла на сервере, путь к которому указан в параметре {@link sourceUrl}.
         * - При значении 2 (`HtmlViewMode.External`) - Будет использован iframe,
         *   которому в качестве значения аттрибута `src` будет передан URL из параметра {@link sourceUrl}.
         *
         * В первых двух вариантах HTML будет непосредственно вставлен в тело страницы, в последнем через iframe.
         */
        mode?: GenModels.HtmlViewMode;
        /** Ширина содержимого с единицами измерения. Учитывается только для режима {@link mode} = `HtmlViewMode.External (2)`. */
        width?: string;
        /** Высота содержимого с единицами измерени. Учитывается только для режима {@link mode} = `HtmlViewMode.External (2)`. */
        height?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Значение атрибута sandbox тега iframe. */
        frameSandbox?: string;
        /** Назначить атрибут sandbox для тега iframe или нет. */
        useFrameSandbox?: boolean;
        /** Значение атрибута scrolling тега iframe. */
        frameScrolling?: string;
        /** Закончилась загрузка фрейма или нет */
        frameLoaded?: boolean;
    }
    /** @internal */
    interface HtmlViewState extends HtmlViewParams, BaseControlState {
    }
    /**
     * Класс элемента управления Html виджет.
     *
     * Добавляет в web-разметку произвольную html разметку.
     */
    class HtmlView extends BaseControl<HtmlViewParams, HtmlViewState> {
        /** @internal */
        protected createParams(): HtmlViewParams;
        /** @internal */
        protected createImpl(): ControlImpl;
        /** @internal */
        protected isDigit(c: string): boolean;
        /** @internal */
        protected processSize(val: string): string;
        private widthSetter;
        private heightSetter;
        private frameScrollingSetter;
        /** @internal */
        protected onFrameLoaded: () => void;
        /** @internal */
        protected attachInlineHtml: (elem: HTMLElement) => void;
        /** @internal */
        protected attachTooltip: (elem: HTMLElement) => void;
        /** @internal */
        protected renderFrame(): JSX.Element;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Метка]{@link Label}.
    */
    class LabelParams extends BaseControlParams {
        /** Текст метки. */
        text: string;
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
    }
    /**
     * Класс элемента управления Метка.
     *
     * Добавляет в web-разметку текстовый не редактируемый элемент.
     */
    class Label extends BaseControl<LabelParams, LabelState> {
        /** @notest @internal */
        protected createParams(): LabelParams;
        /** @notest @internal  */
        protected createImpl(): LabelImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface LabelState extends LabelParams, BaseControlState {
    }
    /** @internal */
    type LabelImplState = LabelState;
    /** @internal */
    class LabelImpl extends BaseControlImpl<LabelParams, LabelState> {
        constructor(props: LabelParams, state: LabelState);
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Публичные свойства для контрола {@link Layout}.
     */
    class LayoutParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Название разметки. */
        layoutName: string;
        /** Владелец разметки. */
        owner: Layout;
        /** Дочерние разметки. */
        childLayouts: Layout[];
        /** Событие возникает при открытии карточки. */
        cardOpening?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает после открытия карточки. */
        cardOpened?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при сохранении карточки. */
        cardSaving?: CancelableApiEvent<SaveControlDataModelEventArgs>;
        /** Событие возникает после сохранения карточки. */
        cardSaved?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает, если при сохранении карточки возникли ошибки. */
        cardSaveFailed?: BasicApiEvent<IEventArgs>;
        /** Событие возникает перед изменением состояния карточки. */
        cardStateChanging?: CancelableApiEvent<ICardStateChangingEventArgs>;
        /** Событие возникает перед изменением разметки карточки. */
        cardLayoutSwitching?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает перед изменением разметки карточки. */
        layoutWillUnmount?: BasicApiEvent<IEventArgs>;
        /** @internal */
        mapLayout?: (layoutResolver: () => Layout) => void;
        /** @internal */
        initializationDeferred: JQueryDeferred<Layout>;
        services?: App & $BusinessCalendarController & $DocumentCardController & $FileController & $LayoutAgreementController & $LayoutCardController & $LayoutCardKindController & $LayoutController & $LayoutDirectoryDesignerController & $LayoutDocumentController & $LayoutFileController & $LayoutFolderController & $LayoutHistoryController & $LayoutLinksController & $LayoutPartnerController & $LayoutStaffController & $LayoutTasksController & $LayoutUserSettingsController & $PagesController & $EmployeesController & $CommentsController & $LayoutFileApiController & $Layout & $Router & $CurrentEmployeeId & $CurrentEmployeeAccountName & $DeviceType & $SiteUrl & $Locale & $FullTextSearchEnabled & $RequestManager & $Sidebar & $FolderViews & $SearchPanel & $NavBar & $Folders & $UnreadCounter & $InstalledCSP & $ApplicationTimestamp & $LayoutManager & $RealtimeCommunicationService & $UserMenu & $LayoutControlFactory & $EditOperationStore & $LayoutInfo & $CardInfo & $CardId & $ControlStore & $LocalStorage & $BaseName & $EnableRouterLogging;
    }
    type SaveControlDataModelEventArgs = GenModels.SaveControlDataModel & {
        deferred: JQueryDeferred<any>;
    };
    /**
     * Класс разметки карточки.
     *
     * Предоставляет доступ к элементам управления, расположенным на разметке, а также методы управления и события карточки.
     */
    class Layout extends Panel<LayoutParams, LayoutState> {
        constructor(props: LayoutParams);
        /** @internal */
        protected createParams(): LayoutParams;
        /** @internal */
        componentDidMount(): void;
        /** Возвращает элементы управления разметки. */
        readonly controls: ControlWrapperMap;
        private cardInfoHandler;
        /** Возвращает модель данных карточки. */
        readonly cardInfo: GenModels.CardInfoModel;
        private layoutInfoHandler;
        /** Возвращает модель данных разметки. */
        readonly layoutInfo: GenModels.LayoutInfoModel;
        private layoutContainerHandler;
        /** Возвращает контейнер разметки. */
        readonly layoutContainer: LayoutContainer;
        private editOperationsrHandler;
        /** Предоставляет доступ к хранилищу операций редактирования. */
        readonly editOperations: IEditOperationStore;
        /** Возвращает текущую разметку. */
        readonly layout: Layout;
        /** Возвращает отображаемое название типа карточки. */
        readonly cardTypeName: string;
        /** @internal */
        protected readonly control: LayoutImpl;
        /** Регистрирует элемент управления в {@link controls}. */
        protected registerControl(control: BaseControl<BaseControlParams, BaseControlState>): void;
        /** Отменяет регистрирацию элемента управления в {@link controls}. */
        protected unregisterControl(control: BaseControl<BaseControlParams, BaseControlState>): void;
        /**
         * Сохраняет изменения всей разметки (карточки) или конкретного элемента управления.
         * @param control Элемент управления который требуется сохранить. Если не указан, будет сохранена вся разметка.
         * @param doNotMarkAsSaved Флаг, указывающий, что карточка должна сохранить признак "не сохранена": true - карточка остается с признаком "не сохранена",
         * false - карточка сохраняется в обычном режиме.
         */
        saveCard(control?: BaseControl<BaseControlParams, BaseControlState>, doNotMarkAsSaved?: boolean): JQueryDeferred<any>;
        /**
         * Изменяет состояние карточки, по полученной операции редактирования.
         * @param operationId Идентификатор операции редактирования.
         */
        changeState(operationId: string): JQueryDeferred<any>;
        /**
         * Проверяет, что карточка заблокирована и есть изменения.
         * @return done срабатывает, когда карточка заблокирована и есть изменения; иначе - срабатывает fail.
         */
        checkLockAndModified(): JQueryDeferred<void>;
        /** @internal */
        protected handleCardOpening(): void;
        /** @internal */
        protected handleCardOpened(): void;
        /** @internal */
        protected handleCardSaving(saveControlData: SaveControlDataModelEventArgs): JQueryDeferred<any>;
        /** @internal */
        protected handleCardSaved(callback: () => void): void;
        /** @internal */
        protected handleCardSaveFailed(): void;
        /** @internal */
        protected handleCardStateChanging(operationId: string, acceptedCallback?: (data?: ICardStateChangingEventArgs) => void, cancelledCallback?: (data?: ICardStateChangingEventArgs) => void): void;
        /** @internal */
        protected handleCardLayoutSwitching(callback: () => void): void;
        /**
        * Возвращает флаг, указывающий, что карточка была сохранена после загрузки разметки: true - была сохранена, false - не была сохранена.
        */
        readonly saved: boolean;
        /** @internal */
        componentWillMount(): void;
        /** @internal */
        componentWillUnmount(): void;
        /** @internal */
        deinit(): void;
        /** @internal Освобождает дерево компонентов. */
        destroy(): JQueryDeferred<any>;
        /** @internal */
        protected createImpl(): LayoutImpl;
    }
    /** Сервис доступа к текущией разметке. */
    type $Layout = {
        layout: Layout;
    };
}
declare namespace WebClient {
    /** @internal */
    interface LayoutState extends LayoutParams, PanelState {
        isInitialized: boolean;
        controlStore: ControlStore;
        cardInfo: GenModels.CardInfoModel;
        layoutInfo: GenModels.LayoutInfoModel;
        layoutContainer: LayoutContainer;
        editOperations: IEditOperationStore;
        saved: boolean;
        cardTypeName: string;
    }
    /** @internal */
    interface LayoutImplProps extends LayoutParams {
    }
    /** @internal */
    type LayoutImplState = LayoutState;
    /** @internal */
    class LayoutImpl extends PanelImpl<LayoutImplProps, LayoutImplState> {
        constructor(props: LayoutImplProps, state: LayoutImplState);
        protected readonly wrapper: Layout;
        protected prepareChildren(): void;
        protected getCssClass(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Сервис информации о разметке. */
    type $LayoutInfo = {
        layoutInfo: GenModels.LayoutInfoModel;
    };
    /** Сервис информации о карточке. */
    type $CardInfo = {
        cardInfo: GenModels.CardInfoModel;
    };
    /** Сервис для доступа к идентификатору карточки. */
    type $CardId = {
        cardId: string;
    };
    /** Сервис для доступа к операциям редактирования. */
    type $EditOperationStore = {
        editOperations?: IEditOperationStore;
    };
    /** Сервис для доступа к элементам управления разметки. */
    type $ControlStore = {
        controlStore: ControlWrapperMap;
    };
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Кнопка]{@link LayoutIconButton}.
     */
    class LayoutIconButtonParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /** Имя CSS класса, в котором определен путь к иконке, отображаемой в Кнопке. */
        iconClass?: string;
        /** Флаг, определяющий, что Кнопка может быть нажата: true - разрешено (разрешена настроенная операция редактирования), false - не разрешено. */
        canClick?: boolean;
        services?: $EditOperationStore;
    }
    /**
     * Класс элемента управления кнопки, отобржаемой в виде иконки.
     */
    class LayoutIconButton extends BaseControl<LayoutIconButtonParams, LayoutIconButtonState> {
        constructor(props: LayoutIconButtonParams);
        /** @internal */
        protected createParams(): LayoutIconButtonParams;
        private readonly myControlImpl;
        private bindingEditOperation;
        /**
         * Вызывает настроенный обработчик нажатия Кнопки.
         */
        performClick(): void;
        /** @internal */
        protected createImpl(): LayoutIconButtonImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface LayoutIconButtonState extends LayoutIconButtonParams, BaseControlState {
        loading: boolean;
    }
    /** @internal */
    type LayoutIconButtonImplState = LayoutIconButtonState;
    /** @internal */
    class LayoutIconButtonImpl extends BaseControlImpl<LayoutIconButtonParams, LayoutIconButtonState> {
        constructor(props: LayoutIconButtonParams, state: LayoutIconButtonState);
        performClick(event?: React.MouseEvent<any>): void;
        /** Переопределяет базовый метод, отменяя его логику (для данного контрола она отлична от базовой версии). */
        protected handleClick(event: React.MouseEvent<any>): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [LayoutPosition]{@link LayoutPosition}.
    */
    class LayoutPositionParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Имя загружаемой разметки. */
        layoutPositionName: string;
        /** В случае значения true, у контрола свойство layout содержит модель другой разметки, которая указана в layoutPositionName. */
        inline?: boolean;
        /** В случае true, запрос разметки будет асинхронным после монтирования контрола. По умолчанию false. */
        async?: boolean;
        /** Json объект с перечнем параметров layoutParams, которые будут переданы при получении разметки */
        params?: string;
        /** Функция выполняющая собственную логику загрузки разметки.  */
        customLayoutLoader?: (sender: LayoutPosition) => JQueryDeferred<GenModels.LayoutViewModel>;
        /** Загруженная модель разметки */
        layoutModel?: GenModels.LayoutViewModel;
        services?: $LayoutController & $LayoutManager;
    }
    /** @internal */
    interface LayoutPositionState extends BaseControlState, LayoutPositionParams {
        loadingHelper: RequestHelper;
    }
    /**
     * Класс элемента управления, служащего для загрузки и отображения разметки.
     */
    class LayoutPosition extends BaseControl<LayoutPositionParams, LayoutPositionState> {
        private root;
        constructor(props: any);
        private customLayoutLoader;
        /** @internal */
        protected createParams(): LayoutPositionParams;
        /** @internal */
        protected createImpl(): ControlImpl;
        /** @internal */
        init(): void;
        /** @internal */
        protected initInternal(): JQueryDeferred<any>;
        /** @internal */
        protected loadLayout(): Promise<GenModels.LayoutViewModel>;
        /** @internal */
        protected attachRoot(elem: HTMLElement): void;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Режим отображения */
    enum ViewDisplayMode {
        /** Стандартный */
        Standard = 0,
        /** Простой */
        Easy = 1,
    }
    /**
     * Публичные свойства для контрола {@link Links}.
     */
    class LinksParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Список ссылок */
        links?: LinkItem[];
        /** Режим отображения для просмотра. */
        viewDisplayMode?: ViewDisplayMode;
        /** Доступно ли создание ссылок */
        createLinkAvailable?: boolean;
        /** Доступно ли добавление ссылок */
        addLinkAvailable?: boolean;
        /** Доступно ли добавление гиперссылок */
        addUrlAvailable?: boolean;
        /** Доступно ли удаление ссылок */
        deleteLinkAvailable?: boolean;
        /** Доступно ли изменение ссылок */
        editLinkAvailable?: boolean;
        /** Заголовок блока ссылок */
        header?: string;
        /** Отображать ли раскрытым */
        showOpened?: boolean;
        /** Хранить ли сильную ссылку */
        saveHardLink?: boolean;
        /** Доступно ли создание ссылок */
        createLinkEnabled?: boolean;
        /** Доступно ли добавление существующих ссылок */
        addLinkEnabled?: boolean;
        /** Доступно ли добавление гиперссылок */
        addUrlEnabled?: boolean;
        /** Раскрыт ли контрол */
        isExpanded?: boolean;
        /** Раскрыта ли командная панель */
        commandBarExpanded?: boolean;
        /** Типы ссылок при добавлении ссылки */
        addLinkLinkTypes?: GenModels.LinkTypeModel[];
        /** Типы ссылок при добавлении гиперссылки */
        addUrlLinkTypes?: GenModels.LinkTypeModel[];
        /** Виды карточек при создании ссылки */
        createLinkKinds?: GenModels.AllowedCardKind[];
        /** Типы ссылок при создании ссылки  */
        createLinkLinkTypes?: GenModels.LinkTypeModel[];
        /** Типы карточек при добавлении ссылки */
        addLinkTypes?: GenModels.CardNodeInfo[];
        /** Протокол по умолчанию */
        defaultProtocol: string;
        /** Событие возникает перед добавлением ссылки на существующую карточку. */
        linkAdding?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает перед удалением ссылки. */
        linkDeleting?: CancelableApiEvent<ILinkEventArgs>;
        /** Событие возникает перед добавлением ссылки на новую карточку. */
        linkCardCreating?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает перед открытием тултипа с информацией о карточке. */
        linkInfoOpening?: CancelableApiEvent<ILinkEventArgs>;
        /** Событие возникает перед закрытием тултипа с информацией о карточке. */
        linkInfoClosing?: CancelableApiEvent<ILinkEventArgs>;
        /** Событие возникает перед редактированием комментария к ссылке. */
        linkInfoEditing?: CancelableApiEvent<ILinkEventArgs>;
        /** Событие возникает перед открытием предпросмотра файла. */
        linkFilePreviewing?: CancelableApiEvent<ILinkEventArgs>;
        /** Событие возникает перед открытием карточки. */
        linkCardOpening?: CancelableApiEvent<ILinkEventArgs>;
        /** Событие возникает перед сворачиванием контрола. */
        collapsing?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает перед разворачивании контрола. */
        expanding?: CancelableApiEvent<IEventArgs>;
        /** Событие возникает при добавлении ссылки на существующую карточку. */
        linkAdded?: BasicApiEvent<ILinkEventArgs>;
        /** Событие возникает при удалении ссылки. */
        linkDeleted?: BasicApiEvent<ILinkEventArgs>;
        /** Событие возникает при редактировании комментария к ссылке. */
        linkInfoEdited?: BasicApiEvent<ILinkEventArgs>;
        /** Событие возникает при открытии предпросмотра файла. */
        linkFilePreviewed?: BasicApiEvent<ILinkEventArgs>;
        /** Событие возникает при сворачивании контрола. */
        collapsed?: BasicApiEvent<IEventArgs>;
        /** Событие возникает при разворачивании контрола. */
        expanded?: BasicApiEvent<IEventArgs>;
        services: $FileController & $LayoutFileController & $LayoutLinksController & $EditOperationStore;
    }
    /**
     * Представляет элемент управления Ссылки
     */
    class Links extends BaseControl<LinksParams, LinksState> {
        protected createParams(): LinksParams;
        private readonly linksImpl;
        private addLinkEnabled;
        private addUrlEnabled;
        private createLinkEnabled;
        private binding;
        private createLinkOperationBinding;
        private addLinkOperationBinding;
        private addUrlOperationBinding;
        private removeLinkOperationBinding;
        private editLinkOperationBinding;
        private createLinkLinkTypes;
        private createLinkKinds;
        private addLinkLinkTypes;
        private addUrlLinkTypes;
        private addLinkTypes;
        private showOpened;
        private model;
        private isExpanded;
        private commandBarExpanded;
        /** Открывает диалог для возможности добавления существующей карточки. */
        openAddExitingCardDialog(): void;
        /** Предоставляет доступ к хранилищу операций редактирования. */
        openAddNewCardDialog(): void;
        /** Открывает диалог для предпросмотра переданного файла. */
        openFilePreview(linkItem: LinkItem): void;
        /** Возвращает URL переданной ссылки. */
        getLinkUrl(linkItem: LinkItem): string;
        /** Удаляет переданную ссылку. */
        deleteLink(linkItem: LinkItem): void;
        /** @internal */
        protected createImpl(): LinksImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface LinksState extends LinksParams, BaseControlState {
        model: GenModels.LinksDataModel;
        bindingInfo: GenModels.SimpleBindingInfo;
        createLinkOperationBinding: string;
        addLinkOperationBinding: string;
        addUrlOperationBinding: string;
        addExistingCardLinkDialog: ExistingCardLinkDialog;
        totalLinksCount: number;
        linksLoaded: boolean;
        isAddUrlDialogShown: boolean;
        editOperationAllowed: boolean;
    }
    /** @internal */
    type LinksImplState = LinksState;
    /** @internal */
    class LinksImpl extends BaseControlImpl<LinksParams, LinksState> {
        requestHelper: RequestHelper;
        constructor(props: LinksParams, state: LinksState);
        componentDidMount(): void;
        componentWillUnmount(): void;
        protected closeAllMenus(): void;
        model: GenModels.LinksDataModel;
        isExpanded: boolean;
        commandBarExpanded: boolean;
        loadLinksModel(model: GenModels.LinksDataModel): void;
        protected getCardCreateLink(cardTypeId: string, kindId: string, linkTypeId: string): string;
        protected onDocumentClick(ev: any): void;
        protected onLinkClick(linkItem: LinkItem): void;
        protected makeLinkUrl(url: string): string;
        onHeaderClick(): void;
        protected onCollapsed(): void;
        protected onExpanded(): void;
        onCommandBarClick(ev?: React.MouseEvent<any>): void;
        onAddNewUrlClick: (ev?: React.MouseEvent<any>) => void;
        addNewUrl: (url: string, linkType: string) => void;
        closeAddNewUrlDialog: () => void;
        onAddNewCardLinkClick(ev?: React.MouseEvent<any>): void;
        onAddExistingCardLinkClick(ev?: React.MouseEvent<any>): void;
        protected onViewFileMenuClick(linkItem: LinkItem): void;
        protected onFollowLinkClick(linkItem: LinkItem): void;
        onDeleteMenuClick(linkItem: LinkItem): void;
        protected onLinkMenuClick(linkItem: LinkItem): void;
        protected getLinkIconClass(linkItem: LinkItem): "dv-ico icon-spin loader-animate" | "dv-ico ico-url" | "dv-ico ico-dv-card" | "dv-ico ico-file";
        protected hideInfoPopover(linkItem: LinkItem): void;
        protected showInfoPopover(linkItem: LinkItem): void;
        protected onLinkInfoEdited(linkItem: LinkItem): void;
        protected getLinksCount(): number;
        protected renderHeader(): JSX.Element;
        protected renderLinksTable(): JSX.Element;
        protected renderEasyLinksTable(): JSX.Element;
        protected renderPlaceholders(): any[];
        protected getLoaderWidth(i: number): number;
        protected renderSettingsMenu(linkItem: LinkItem): JSX.Element;
        renderControl(): JSX.Element;
        openFilePreview(linkItem: LinkItem): void;
        getLinkUrl(linkItem: LinkItem): string;
    }
}
declare namespace WebClient {
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link RefreshFoldersTreeScript}.
     */
    class RefreshFoldersTreeScriptParams extends LayoutScriptParams {
        /** Название контрола кнопки настройки главного меню */
        refreshButtonName: string;
        services?: $ControlStore & $Sidebar & $LayoutFolderController & $Router;
    }
    /** @internal */
    interface RefreshFoldersTreeScriptScriptState extends RefreshFoldersTreeScriptParams, BaseControlState {
    }
    /**
     * Класс для связывания кнопки настройки главного меню с пользовательскими папками
     */
    class RefreshFoldersTreeScript extends LayoutScript<RefreshFoldersTreeScriptParams, RefreshFoldersTreeScriptScriptState> {
        private button;
        /** @internal */
        protected createParams(): RefreshFoldersTreeScriptParams;
        /** @internal */
        init(): void;
        /** @internal */
        protected onRefreshFoldersClick: () => Promise<void>;
        /** @internal */
        protected refreshRoute(): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Число]{@link NumberControl}.
     */
    class NumberParams extends InputBasedControlParams<number> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Количество символов в дробной части. Если значение = NumberImpl.INFINITY_FRACTION_DIGITS, то можно писать сколько угодно чисел после запятой. */
        fractionDigits?: number;
        services?: $EditOperationStore & $LayoutInfo;
    }
    /**
     * Класс элемента управления Число.
     */
    class NumberControl extends InputBasedControl<number, NumberParams, NumberState> {
        /** @internal */
        protected createParams(): NumberParams;
        /** @internal */
        protected getServices(): $EditOperationStore & $LayoutInfo;
        /** @internal */
        private RealNumberBinding;
        /** @internal */
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected createImpl(): NumberImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface NumberState extends NumberParams, InputBasedControlState<number> {
        binding: IBindingResult<number>;
    }
    /** @internal */
    type NumberImplState = NumberState;
    /** @internal */
    class NumberImpl extends InputBasedControlImpl<number, NumberParams, NumberState> {
        protected static readonly INFINITY_FRACTION_DIGITS: number;
        constructor(props: NumberParams, state: NumberState);
        protected trimFractionDigits(value: number): number;
        protected numberToString(value: number, useGrouping: boolean): string;
        protected prepareValueForSettingToInput(value: number): string;
        protected getTextValue(): string;
        protected renderInto(props: NumberParams, container: HTMLElement): void;
        protected onInputChange(event: React.ChangeEvent<any>): void;
        protected setInputValue(value: string): void;
        setValue(value: number | string, redraw: boolean): void;
        protected attachInput(elem: HTMLInputElement): void;
        protected onInputBlur(event: React.FocusEvent<any>): void;
        protected parseStringValue: (value: string, trim: boolean) => number;
        protected processInputValue(): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected renderInput(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Нумератор]{@link Numerator}.
     */
    class NumeratorParams extends InputBasedControlParams<INumberInfo> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Правило генерации номера */
        generationRule: string;
        /** Разрешён ли ручной ввод */
        allowManualEdit: boolean;
        services?: $LayoutDocumentController & $EditOperationStore & $Layout & $LayoutInfo;
        /** Событие, возникающее перед началом генерации нового номера. */
        generating?: CancelableApiEvent<void>;
        /** Событие, возникающее после начала генерации нового номера. */
        generated?: BasicApiEvent<boolean>;
    }
    /**
     * Класс элемента управления Нумератор.
     */
    class Numerator extends InputBasedControl<INumberInfo, NumeratorParams, NumeratorState> {
        /** @internal */
        protected createParams(): NumeratorParams;
        private readonly numeratorImpl;
        /** @internal */
        protected getServices(): $LayoutDocumentController & $EditOperationStore & $Layout & $LayoutInfo;
        private numeratorBinding;
        /** Set the name of the current value of the control */
        setNumberText(num: string): void;
        /** Send request to the server to generate new number, with sepcified rule.
        * With default parameters values equal to press generate button.
        * @param saveToTheCard Should be new number saved as the current card number or not.
        * @param ruleId Generation rule id.
        * @param saveCardBefore Should control save the card, before generate number.
        *        Saving a card required, because card fields can be used in number generation rule.
        */
        generateNewNumber(saveToTheCard?: boolean, saveCardBefore?: boolean): JQueryDeferred<INumberInfo>;
        /**
         * Clear number value
         */
        clearNumber(): JQueryDeferred<any>;
        /** @internal */
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected createImpl(): NumeratorImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface NumeratorState extends NumeratorParams, InputBasedControlState<INumberInfo> {
        numeratorBinding: IBindingResult<INumberInfo>;
        bindingInfo: GenModels.BindingInfo;
        requestHelper: RequestHelper;
        currentValueGeneratedNumber: string;
        disableRequiredCheck: boolean;
    }
    /** @internal */
    type NumeratorImplState = NumeratorState;
    /** @internal */
    class NumeratorImpl extends InputBasedControlImpl<INumberInfo, NumeratorParams, NumeratorState> {
        constructor(props: NumeratorParams, state: NumeratorState);
        generateNewNumber(saveToTheCard: boolean, prepareAction: () => JQueryDeferred<any>): JQueryDeferred<INumberInfo>;
        componentDidMount(): void;
        protected getTextValue(): string;
        protected onInputChange(event: any): void;
        validate(params: any): IValidationResult;
        clearNumber(): JQueryDeferred<any>;
        protected renderInto(props: NumeratorParams, container: HTMLElement): void;
        protected readonly editAvailable: boolean;
        protected readonly withInputMode: boolean;
        protected getCssClass(): string;
        protected onGenerateClick(): void;
        protected onClearClick(): void;
        protected onValueClick(event: any): void;
        protected getButtons(): IBoxWithButtonsButtonInfo[];
        protected renderWithText(): JSX.Element;
        protected renderInputWithPlaceholder(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Сотрудник контрагента]{@link Partner}.
     */
    class PartnerParams extends InputBasedControlParams<GenModels.EmployeeDataModel> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Формат отображения информации о выбранном сотруднике в контроле. */
        partnerViewMode?: GenModels.EmployeeViewMode;
        /** Формат отображения информации о выбранном сотруднике во всплывающей подсказке. */
        partnerTipMode?: GenModels.PartnerTipModeItems;
        /**
         * Значение фильтра, которое которое недоступно для очистки в пользовательском интерфейсе.
         * Внимание: при изменении значения параметра, значение {@link selectedFilterPath} сбрасывается.
         */
        predefinedFilter?: GenModels.DepartmentModel;
        /** Значение фильтра, которое было выбрано пользователем. */
        selectedFilterPath?: GenModels.DepartmentModel[];
        /** Текущий фильтр. Объединяет значения {@link predefinedFilter} и {@link selectedFilter}  */
        currentFilterPath?: GenModels.DepartmentModel[];
        /** Задержка в милисекундах после изменения поискового запроса и перед отправкой запроса на сервер. */
        searchDelay?: number;
        /** Флаг, указывающий на состояние окна выбора организации/подразделения: true - открыто, false - закрыто. */
        isDirectoryWindowShown?: boolean;
        /** Ссылка на компонент модального окна для выбора контрагентов. */
        directoryWindow?: PartnerSelectDialog;
        /** Событие, возникающее перед открытием модального окна для выбора контрагентов. */
        directoryWindowOpening?: CancelableApiEvent<void>;
        /** Событие, возникающее после открытия модального окна для выбора контрагентов. */
        directoryWindowOpened?: BasicApiEvent<void>;
        /** Событие, возникающее перед закрытием модального окна для выбора контрагентов. */
        directoryWindowClosing?: CancelableApiEvent<void>;
        /** Событие, возникающее после закрытия модального окна для выбора контрагентов. */
        directoryWindowClosed?: BasicApiEvent<void>;
        /**
         * Событие, возникающее перед выполнением поиска записей на сервере. В обработчике события можно изменить параметры запроса.
         * Если в обработчике задать значение result, то запрос на сервер выполнен не будет.
         */
        searchResultsLoading?: CancelableApiEvent<IPartnerDataLoadingEventArgs>;
        /** Событие, возникающее после выполнения поиска записей на сервере. В обработчике события можно изменить возвращенные данные. */
        searchResultsLoaded?: BasicApiEvent<IPartnerDataLoadingEventArgs>;
        /** Событие, возникающее перед изменением фильтра контрагентов. */
        currentFilterChanging?: CancelableApiEvent<IPartnerFilterChangeEventArgs>;
        /** Событие, возникающее после изменения фильтра контрагентов. */
        currentFilterChanged?: BasicApiEvent<IPartnerFilterChangeEventArgs>;
        services?: $LayoutPartnerController & $EditOperationStore & $LayoutInfo;
    }
    /**
     * Класс элемента управления Сотрудник контрагента.
     *
     * Добавляет в web-разметку поле ввода с кнопкой вызова диалогового окна для выбора записи из *Справочника сотрудников* или *Справочника контрагентов*.
     */
    class Partner extends InputBasedControl<GenModels.EmployeeDataModel, PartnerParams, PartnerState> {
        private isSelectedFilterPathInitialized;
        private isBindingInitialized;
        private isParentOrganizationBindingInitialized;
        /** @internal */
        protected createParams(): PartnerParams;
        /** @internal */
        protected getServices(): $LayoutPartnerController & $EditOperationStore & $LayoutInfo;
        /** @internal */
        protected readonly partnerImpl: PartnerImpl;
        private binding;
        private parentOrganizationBinding;
        private readonly currentFilterPath;
        private selectedFilterPath;
        private predefinedFilter;
        /** @internal */
        readonly isDictionaryShown: boolean;
        /** @internal */
        protected partnerTipMode: GenModels.PartnerTipModeItems;
        /** @internal */
        protected partnerViewMode: GenModels.EmployeeViewMode;
        /** @internal */
        protected getParamsToKeep(params: any): {
            selectedFilterPath: any;
            value: GenModels.EmployeeDataModel;
        };
        /**
         * Фильтрует путь selectedPath с учётом predefinedFilter
         *
         * Если selectedPath не существует, то возвращается пустой массив.
         * Если predefinedFilter не существует, то возвращается исходный selectedPath или пустой массив, если selectedPath не существует.
         * Если predefinedFilter входит в состав selectedPath, то selectedPath обрезается так,
         * что остаются только элементы, первый из которых равен predefinedFilter, а остальные идут глубже по дереву.
         * Если predefinedFilter не входит в состав selectedPath, то возвращается исходный selectedPath.
         *
         * @param selectedPath Выбранное значение фильтра.
         * @param predefinedFilter Значение фильтра, которое которое недоступно для очистки в пользовательском интерфейсе.
         */
        static filterSelectedPath(selectedPath: GenModels.DepartmentModel[], predefinedFilter: GenModels.DepartmentModel): GenModels.DepartmentModel[];
        /**
         * Входит ли значение predefinedFilter в состав selectedPath.
         * @param selectedPath Выбранное значение фильтра.
         * @param predefinedFilter Значение фильтра, которое которое недоступно для очистки в пользовательском интерфейсе.
         */
        static isFilterInSelectedPath(selectedPath: GenModels.DepartmentModel[], predefinedFilter: GenModels.DepartmentModel): boolean;
        /**
         * Проверяет возможность открытия модального окна выбора организации/подразделения.
         * @return true - возможно (если значение редактируемое), false - невозможно.
         */
        canShowDictionary(): boolean;
        /**
         * Открывает окно выбора организации/подразделения.
         */
        showDictionary(): void;
        /**
         * Закрывает окно выбора организации/подразделения.
         */
        hideDictionary(): void;
        /** @internal */
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected createImpl(): PartnerImpl;
    }
}
declare namespace WebClient {
    namespace PartnerHelpers {
        /** @internal */
        class PartnerDirectoryItemVisualiser {
            employeeVisualiser: EmployeeVisualizer;
            constructor(employeeVisualiser: EmployeeVisualizer);
            getDisplayName(item: GenModels.PartnerDirectoryItem): string;
            getTooltip(item: GenModels.PartnerDirectoryItem): string;
            getIconClassName(item: GenModels.PartnerDirectoryItem): string;
        }
    }
}
declare namespace WebClient {
    /** @internal */
    interface ISimpleItemViewContentProps {
        className?: string;
        tabIndex?: number;
        /** Current element's id */
        id?: string;
        /** Focused element's id */
        focusedId?: string;
        /** Get wrapper of el (e.g. to find siblings) */
        getNodeEl?: (el: HTMLElement) => HTMLElement;
        /** Finds el in wrapper */
        findElInNode?: (node: HTMLElement) => HTMLElement;
        /** On move to component children */
        onMoveForward?: () => void;
        onSelectSibling?: (mode: 'prev' | 'next') => void;
        onSelect?: () => void;
        onClick?: (ev: React.MouseEvent<any>) => void;
        primaryAction: "moveForward" | "select";
    }
    /** @internal */
    class SimpleItemViewContent extends React.Component<ISimpleItemViewContentProps, undefined> {
        protected el: HTMLElement;
        protected getNodeEl: () => HTMLElement;
        protected findElInNode: (node: HTMLElement) => HTMLElement;
        protected onKeyDown: (ev: any) => void;
        protected onDoubleClick: (ev: any) => void;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: ISimpleItemViewContentProps): void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNodeContentDefault }  */
    interface ICustomTreeNodeContentDefaultProps {
        /** Идентификатор узла */
        id?: string;
        /** Focused element's id */
        focusedId?: string;
        /** Выделен ли узел */
        selected?: boolean;
        className?: string;
        /** Оставлять ли стили кнопки у контейнера или сбрасывать */
        keepButtonStyles?: boolean;
    }
    /** @review Содержимое узла дерева. Пример использования см. {@link CustomTreeDefault} */
    const CustomTreeNodeContentDefault: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps>;
}
declare namespace WebClient {
    /** @internal */
    const CustomTreeNodeContentCompact: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps>;
}
declare namespace WebClient {
    /** @internal */
    interface IPartnerSelectDialogSearchPathOptions {
        path: GenModels.DepartmentModel[];
        notAppendToSelectedFilterPath?: boolean;
    }
    /** @internal */
    interface IPartnerSelectDialogProps {
        partnerSelected: (node: GenModels.EmployeeDataModel) => void;
        searchDelay: number;
        onSelect?: () => void;
        predefinedFilter: GenModels.DepartmentModel;
        selectedFilterPath: GenModels.DepartmentModel[];
        onSelectedFilterPathChange?: (newPath: GenModels.DepartmentModel[]) => void;
        onSearchFilterPathChange?: (newPath: GenModels.DepartmentModel[]) => void;
        itemVisualiser: PartnerHelpers.PartnerDirectoryItemVisualiser;
        searchResultsLoading: CancelableApiEvent<IPartnerDataLoadingEventArgs>;
        searchResultsLoaded: BasicApiEvent<IPartnerDataLoadingEventArgs>;
        services: $LayoutPartnerController;
    }
    /** @internal */
    interface IPartnerChildrenCacheItem {
        items: GenModels.PartnerDirectoryItem[];
        totalItemsCount: number;
        accessTimestamp: Date;
    }
    /** @internal */
    interface IPartnerChildrenCache {
        [id: string]: IPartnerChildrenCacheItem;
    }
    /** @internal */
    interface IPartnerSelectedNodesPath {
        [departmentId: string]: GenModels.PartnerDirectoryItem;
    }
    /** @internal */
    interface IPartnerSelectDialogState {
        /** Выбранный партнёр */
        selectedEmployee: GenModels.EmployeeDataModel;
        /** Выбранный узел, используется только для навигации с клавиатуры */
        selectedNode: GenModels.EmployeeDataModel;
        /** Список выбранных узлов с прошлых уровней, используется только для навигации с клавиатуры */
        selectedNodesPath: IPartnerSelectedNodesPath;
        searchRequestHelper: RequestHelper;
        showingSearchResults: boolean;
        searchText: string;
        searchItems: GenModels.PartnerDirectorySearchItem[];
        hasMoreSearchItems: boolean;
        searchDebouncer: QuickSearchLogic;
        searchMode: GenModels.PartnerSearchMode;
        selectedNodeFocused: boolean;
        loadChildrenHelper: RequestHelper;
        childrenListCache: IPartnerChildrenCache;
        initialLoading: boolean;
        initialLoadingState: LoadingState;
        directoryTimestamp: number;
    }
    /** @internal */
    class PartnerSelectDialog extends React.Component<IPartnerSelectDialogProps, IPartnerSelectDialogState> {
        static ChildrenPageSize: number;
        static SearchPageSize: number;
        static SimpleItemView: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps & {
            className: string;
        }, any, ISimpleItemViewContentProps & React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps>;
        static SimpleItemViewCompact: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps & {
            className: string;
        }, any, ISimpleItemViewContentProps & React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps>;
        searchInput: HTMLInputElement;
        protected readonly rootId: string;
        constructor(props: IPartnerSelectDialogProps);
        componentDidMount(): void;
        componentWillUnmount(): void;
        componentWillReceiveProps(newProps: IPartnerSelectDialogProps): void;
        readonly selectedPartner: GenModels.EmployeeDataModel;
        protected onModalKeyDown: (ev: any) => void;
        protected onNavigateToFolder(departmentId: string): JQueryPromise<{}>;
        protected onSelectedFilterPathChange: (newPath: GenModels.DepartmentModel[]) => void;
        protected onSelectedFilterMoveBack: () => void;
        protected readonly currentDepartmentId: string;
        protected readonly currentDepartmentName: string;
        protected readonly currentChildren: GenModels.PartnerDirectoryItem[];
        protected readonly currentChildrenCache: IPartnerChildrenCacheItem;
        protected getDepartmentCache(id: string): IPartnerChildrenCacheItem;
        protected clearCache(): void;
        protected loadChildrenList(departmentId: string, from: number, to: number): JQueryDeferred<IPartnerDirectoryTreeItem[]>;
        protected onChildrenLoaded(response: GenModels.PartnerTreeLoadResponse, departmentId: string, from: number): void;
        protected onReactListLoadRequest: (indexes: number[]) => void;
        protected search(query: GenModels.PartnerQuickSearchQuery, reset: boolean): JQueryDeferred<{}>;
        protected onSearchResultLoaded(response: GenModels.PartnerSearchResponse, reset: boolean): void;
        attachSearchInput: (elem: HTMLInputElement) => void;
        protected onInputKeyUp(ev: React.KeyboardEvent<any>): void;
        protected onInputChange(event: any): void;
        protected onSearchFilterPathChange(newPath: GenModels.DepartmentModel[]): void;
        private resetSearchMode;
        protected onSelectEmployee(item: GenModels.EmployeeDataModel, searchPathOptions?: IPartnerSelectDialogSearchPathOptions): void;
        protected shouldShowOpenButton(item: GenModels.PartnerDirectoryItem): boolean;
        protected onChildrenListItemClick: (item: GenModels.PartnerDirectoryItem) => void;
        protected onSearchItemClick: (item: GenModels.PartnerDirectorySearchItem) => void;
        protected onItemAccepted: (item: GenModels.PartnerDirectoryItem) => void;
        protected onChildrenListItemDoubleClick: (item: GenModels.PartnerDirectoryItem) => void;
        protected onSearchItemDoubleClick: (item: GenModels.PartnerDirectorySearchItem) => void;
        protected onChildrenListItemSelectSibling: (mode: "next" | "prev", index: number, getCollectionData: () => GenModels.PartnerDirectoryItem[]) => void;
        protected onSearchPathItemClick: (department: GenModels.DepartmentModel, item: GenModels.PartnerDirectorySearchItem) => void;
        protected onToggleSearchMode: () => void;
        protected onLoadNextSearchPage: () => JQueryDeferred<{}>;
        protected onLoadNewSearchResults: () => JQueryDeferred<{}>;
        protected renderGoToButton(item: GenModels.PartnerDirectoryItem): JSX.Element;
        renderSearchItem: (index: number, key: string) => JSX.Element;
        renderChildrenListItem: (key: string | number, item: GenModels.PartnerDirectoryItem, index: number) => JSX.Element;
        renderLoadingItem: (index: number, key: string | number) => JSX.Element;
        renderEmptyItem: (index: number, key: string | number) => JSX.Element;
        renderChildrenListItems(): JSX.Element;
        renderSearchItems(): JSX.Element;
        renderItems(): JSX.Element;
        /** @internal */
        render(): React.ReactNode;
    }
}
declare namespace WebClient {
    /** @internal */
    interface PartnerState extends PartnerParams, InputBasedControlState<GenModels.EmployeeDataModel> {
        binding: IBindingResult<GenModels.EmployeeDataModel>;
        requestHelper: RequestHelper;
        directoryDialogOpen: boolean;
        directoryDialogSelectedValue: GenModels.EmployeeDataModel;
        inputKeyDown: SimpleEvent<React.KeyboardEvent<any>>;
        employeeVisualiser: EmployeeVisualizer;
        itemVisualiser: PartnerHelpers.PartnerDirectoryItemVisualiser;
        typeahead: Typeahead;
        beforeModalSelectedFilterPath: GenModels.DepartmentModel[];
        /** Путь для элемента из поиска, отличается от selectedFilterPath тем, что применяется только при закрытии PartnerSelectDialog */
        searchFilterPath: GenModels.DepartmentModel[];
    }
    /** @internal */
    type PartnerImplProps = PartnerParams;
    /** @internal */
    type PartnerImplState = PartnerState;
    /** @internal */
    class PartnerImpl extends InputBasedControlImpl<GenModels.EmployeeDataModel, PartnerImplProps, PartnerState> {
        static FirstPageSize: number;
        static NextPageSize: number;
        static SearchTimeout: number;
        private readonly EmptySelectedPath;
        constructor(props: PartnerImplProps, state: PartnerState);
        protected getTextValue(): string;
        protected getValueTitle(): string;
        protected getInputTitle(): string;
        protected renderInto(props: PartnerParams, container: HTMLElement): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<GenModels.EmployeeDataModel, PartnerParams, PartnerState>>;
        readonly currentFilterPath: GenModels.DepartmentModel[];
        readonly currentFilter: string | undefined;
        readonly currentFilterName: string | undefined;
        protected attachTypeahead(typeahead: Typeahead): void;
        protected findItems(typeaheadQuery: ITypeaheadSearchQuery): JQueryDeferred<ITypeaheadSearchResult>;
        protected onTypeaheadSelected(variant: ITypeaheadVariant): void;
        protected onDropdownStateChanged(): void;
        attachDialogComponent: (dialog: PartnerSelectDialog) => void;
        showDictionary(): void;
        hideDictionary(): void;
        protected cancelModal: () => void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected onDirectoryDialogNodeSelected(node: GenModels.EmployeeDataModel): void;
        protected onDirectoryDialogSelectButtonClick(): Promise<void>;
        protected onFilterSelected: (items: GenModels.DepartmentModel[]) => void;
        protected onSelectedFilterPathChange: (newSelected: GenModels.DepartmentModel[]) => void;
        protected onDialogSelectedFilterPathChange: (newSelected: GenModels.DepartmentModel[]) => void;
        setSelectedFilterPath(newValue: GenModels.DepartmentModel[]): JQueryDeferred<IPartnerFilterChangeEventArgs>;
        setSearchFilterPath: (newValue: GenModels.DepartmentModel[]) => void;
        setPredefinedFilter(newValue: GenModels.DepartmentModel): JQueryDeferred<IPartnerFilterChangeEventArgs>;
        protected onInputChange(event: any): void;
        readonly isDictionaryShown: boolean;
        partnerTipMode: GenModels.PartnerTipModeItems;
        partnerViewMode: GenModels.EmployeeViewMode;
        protected renderFilter(): React.ReactNode;
        protected renderPlaceholder(): JSX.Element;
        protected renderInputWithPlaceholder(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Группа радиокнопок]{@link RadioGroup}.
     */
    class RadioGroupParams extends InputBasedControlParams<string> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Положение метки элемента - cлева/cправа. */
        labelPlacement: GenModels.RadioGroupLabelLocation;
        /** Количество колонок для расположения радио-кнопок. */
        columnCount: number;
        /** Список элементов, доступных для выбора */
        items: GenModels.BindingMetadata[];
        services?: $EditOperationStore & $LayoutInfo & $ControlStore;
    }
    /**
     * Класс элемента управления Группа радиокнопок
     *
     * Добавляет в web-разметку элемент управления для выбора и отображения варианта из набора доступных.
     */
    class RadioGroup extends InputBasedControl<string, RadioGroupParams, RadioGroupState> {
        /** @internal */
        protected createParams(): RadioGroupParams;
        /** @internal */
        protected getServices(): $EditOperationStore & $LayoutInfo & $ControlStore;
        private setRadioGroupElements;
        private setBinding;
        private setDefault;
        /** @internal */
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected getDefault(): string;
        /** @internal */
        protected createImpl(): RadioGroupImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface RadioGroupState extends RadioGroupParams, InputBasedControlState<string> {
        binding: IBindingResult<string>;
    }
    /** @internal */
    type RadioGroupImplState = RadioGroupState;
    /** @internal */
    class RadioGroupImpl extends InputBasedControlImpl<string, RadioGroupParams, RadioGroupState> {
        constructor(props: any, state: RadioGroupState);
        protected getTextValue(): string;
        protected renderInto(props: RadioGroupParams, container: HTMLElement): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<string, RadioGroupParams, RadioGroupState>>;
        protected onElementChange(element: GenModels.BindingMetadata, ev: React.FormEvent<any>): void;
        protected renderPlaceholder(): JSX.Element;
        protected renderLabel(element: GenModels.BindingMetadata): JSX.Element;
        protected getColumns(): Array<Array<GenModels.BindingMetadata>>;
        protected renderInput(): React.ReactNode;
    }
}
declare namespace WebClient {
    /** @internal */
    class BaseRazorControlParams extends BaseControlParams {
        razorContent: IBindingResult<string>;
    }
    /** @internal */
    interface BaseRazorControlState extends BaseRazorControlParams, BaseControlState {
    }
    /** @internal */
    abstract class BaseRazorControl<PropsT extends BaseRazorControlParams = BaseRazorControlParams, StateT extends BaseRazorControlState = BaseRazorControlState> extends BaseControl<PropsT, StateT> {
        constructor(props: any);
        protected createImpl(): ControlImpl;
        mountRazorContent(razorContainer: HTMLElement): void;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class ApprovalTaskCardCompletionButtonsRazorControlParams extends BaseRazorControlParams {
        /** Определяет расположение кнопок - в строку (true) или в столбик (false). */
        horizontalLayout: boolean;
    }
    /** @internal */
    interface ApprovalTaskCardCompletionButtonsRazorControlState extends ApprovalTaskCardCompletionButtonsRazorControlParams, BaseRazorControlState {
    }
    /** @internal */
    class ApprovalTaskCardCompletionButtonsRazorControl extends BaseRazorControl<ApprovalTaskCardCompletionButtonsRazorControlParams, ApprovalTaskCardCompletionButtonsRazorControlState> {
        protected createParams(): ApprovalTaskCardCompletionButtonsRazorControlParams;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class ApprovalTaskCardOperationsRazorControl extends BaseRazorControl<BaseRazorControlParams, BaseRazorControlState> {
        protected createParams(): BaseRazorControlParams;
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskCardPerformersPanelParams extends BaseRazorControlParams {
        services?: $LayoutCardController;
    }
    /** @internal */
    interface TaskCardPerformersPanelState extends TaskCardPerformersPanelParams, BaseRazorControlState {
        documents: string[];
        requestHelper: RequestHelper;
    }
    /** @internal */
    class TaskCardFilePanelRazorControl extends BaseRazorControl<TaskCardPerformersPanelParams, TaskCardPerformersPanelState> {
        constructor(props: TaskCardPerformersPanelParams);
        loadFilesAsync(): Promise<void>;
        protected createParams(): TaskCardPerformersPanelParams;
        init(): void;
        mountRazorContent(razorContainer: HTMLElement): void;
        protected getBindings(): IBindingResult<any>[];
        getDisclosureHeader(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskCardOperationButtonsRazorControlParams extends BaseRazorControlParams {
        standardCssClass?: string;
        /** Определяет расположение кнопок - в строку (true) или в столбик (false). */
        horizontalLayout: boolean;
        cardStateChanged?: BasicApiEvent<ICardStateChangingEventArgs>;
    }
    /** @internal */
    interface TaskCardOperationButtonsRazorControlState extends TaskCardOperationButtonsRazorControlParams, BaseRazorControlState {
    }
    /** @internal */
    class TaskCardOperationButtonsRazorControl extends BaseRazorControl<TaskCardOperationButtonsRazorControlParams, TaskCardOperationButtonsRazorControlState> {
        constructor(props: any);
        protected createParams(): TaskCardOperationButtonsRazorControlParams;
        mountRazorContent(razorContainer: HTMLElement): void;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskCardOperationsRazorControl extends BaseRazorControl<BaseRazorControlParams, BaseRazorControlState> {
        protected createParams(): BaseRazorControlParams;
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskCardParentGroupRazorControl extends BaseRazorControl<BaseRazorControlParams, BaseRazorControlState> {
        protected createParams(): BaseRazorControlParams;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TaskReportPanelRazorControlState extends BaseRazorControlState {
        reportPanel: Cards.TaskReportPanel;
    }
    /** @internal */
    class TaskReportPanelRazorControl extends BaseRazorControl<BaseRazorControlParams, TaskReportPanelRazorControlState> {
        protected createParams(): BaseRazorControlParams;
        mountRazorContent(razorContainer: HTMLElement): void;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Кнопки сохранения]{@link SavingButtons}.
     */
    class SavingButtonsParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Текст кнопки ОК */
        okButtonText: string;
        /** Текст кнопки Отмена */
        cancelButtonText: string;
        /** Выключена ли кнопка ОК */
        okButtonDisabled: boolean;
        /** Выключена ли кнопка Отмена */
        cancelButtonDisabled: boolean;
        /** Событие, возникающее перед нажатием на кнопку ОК или кнопку Отмена */
        clicking?: CancelableApiEvent<ISavingButtonClickEventArgs>;
        services?: $Layout;
    }
    /**
     * Класс элемента управления Кнопки сохранения
     *
     * Добавляет в web-разметку элемент управления для сохранения изменений карточки.
     */
    class SavingButtons extends BaseControl<SavingButtonsParams, SavingButtonsState> {
        constructor(props: SavingButtonsParams);
        /** @internal */
        protected createParams(): SavingButtonsParams;
        /** @internal */
        componentDidMount(): void;
        /** @internal */
        componentWillUnmount(): void;
        private readonly savingButtonsImpl;
        /** Выполнить сохранение */
        performSave(): JQueryDeferred<any>;
        /** Выполнить отмену */
        performCancel(): void;
        /** @internal */
        protected onCardSaving(): void;
        /** @internal */
        protected onCardSavedOrFailed(): void;
        /** @internal */
        protected createImpl(): SavingButtonsImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface SavingButtonsState extends SavingButtonsParams, BaseControlState {
        /** Выполнить сохранение */
        performSave: Function;
        /** Выполнить отмену */
        performCancel: Function;
        /** Сохраняется ли карточка в данный момент */
        cardIsSaving: boolean;
        savingHelper: RequestHelper;
    }
    /** @internal */
    type SavingButtonsImplState = SavingButtonsState;
    /** @internal */
    class SavingButtonsImpl extends BaseControlImpl<SavingButtonsParams, SavingButtonsState> {
        constructor(props: SavingButtonsParams, state: SavingButtonsState);
        protected handleClick(event: React.MouseEvent<any>): void;
        onSave(): void;
        onCancel(): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Состояние]{@link State}.
     */
    class StateParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Значение состояния. */
        value: GenModels.StateModel;
        /** Текст всплывающей подсказки. */
        tip: string;
        /** Текст метки. */
        labelText: string;
    }
    /**
     * Класс элемента управления Состояние
     *
     * Добавляет в web-разметку элемент управления для просмотра состояния карточки.
     */
    class State extends BaseControl<StateParams, StateState> {
        /** @internal */
        protected createParams(): StateParams;
        private binding;
        /** @internal */
        protected createImpl(): StateImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface StateState extends StateParams, BaseControlState {
    }
    /** @internal */
    type StateImplState = StateState;
    /** @internal */
    class StateImpl extends BaseControlImpl<StateParams, StateState> {
        constructor(props: StateParams, state: StateState);
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Автомат состояния]{@link StateButtons}.
     */
    class StateButtonsParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Список операций. */
        operations: GenModels.OperationDataModel[];
        /** Включена ли вертикальная ориентация. */
        verticalOrientation?: boolean;
        /** Ограничение количества отображаемых кнопок (остальные кнопки будут доступны по кнопке "..."). */
        buttonsLimit?: number;
        services?: $EditOperationStore;
    }
    /**
     * Класс элемента управления Автомат состояния
     *
     * Добавляет в web-разметку элемент управления для изменения состояния карточки.
     */
    class StateButtons extends BaseControl<StateButtonsParams, StateButtonsState> {
        /** @internal */
        protected createParams(): StateButtonsParams;
        /** @internal */
        protected createImpl(): StateButtonsImpl;
        private readonly stateButtonsImpl;
        private bindingStateButtons;
        /**
         * Показать меню со всеми кнопками.
         */
        showMenu(): void;
        /**
         * Скрыть меню со всеми кнопками.
         */
        hideMenu(): void;
        /**
         * Выполнить нажатие по кнопке с указанной операцией
         * @param operationId Идентификатор операции
         */
        performClick(operationId: string): void;
        /**
         * Добавить операцию.
         * @param operationData Данные об операции.
         */
        add(operationData: GenModels.OperationDataModel): void;
        /**
         * Удалить операцию.
         * @param operationId Идентификатор операции.
         */
        remove(operationId: string): void;
        /** @internal */
        protected processEditOperations(operationsData: GenModels.OperationDataModel[]): GenModels.OperationDataModel[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface StateButtonsState extends StateButtonsParams, BaseControlState {
        /** Изменяется ли в данный момент состояние. */
        isChanging: boolean;
    }
    /** @deprecated*/
    type StateButtonsImplState = StateButtonsState;
    /** @internal */
    class StateButtonsImpl extends BaseControlImpl<StateButtonsParams, StateButtonsState> {
        protected sidebar: RightSidebar;
        protected sidebarRoot: HTMLElement;
        constructor(props: StateButtonsParams, state: StateButtonsState);
        protected initSidebar(): void;
        componentDidMount(): void;
        componentWillUnmount(): void;
        showMenu(): void;
        hideMenu(): void;
        performClick(operationId: string): void;
        add(operationData: GenModels.OperationDataModel): void;
        remove(operationId: string): void;
        protected getStateButtons(): JSX.Element[];
        protected getSidebarButtons(): JSX.Element[];
        protected getCssClass(): string;
        protected getMenuButtonClassName(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Вкладки]{@link Tab}.
     */
    class TabParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Должны ли быть вкладки основными вкладками в мобильной вёрстке. */
        mainTabOnMobile: boolean;
        /** Индекс вкладки по умолчанию. */
        defaultPageIndex: number;
        /** Страницы вкладок. */
        tabPages: TabPageInfo[];
        /** Активная вкладка. */
        activeTabPage: TabPageInfo;
        /** Событие, возникающее после переключения активной вкладки. */
        activeTabChange: BasicApiEvent<IActiveTabChangeEventArgs>;
        /** Событие, возникающее после переключения активной вкладки. */
        activeTabChanging: CancelableApiEvent<IActiveTabChangeEventArgs>;
        services?: $LayoutCardController;
    }
    /**
     * Класс элемента управления Вкладки
     *
     * Добавляет в web-разметку элемент управления для отображения вкладок.
     */
    class Tab extends Panel<TabParams, TabState> {
        static activeTabs: {
            [key: string]: number;
        };
        /** @internal */
        protected createParams(): TabParams;
        private readonly tabImpl;
        /** @internal */
        protected childrenHandler: any[];
        /** @internal */
        activeTabPage: any;
        /**
         * Установка заголовка указанной вкладки
         * @param tab Вкладка
         * @param header Заголовок
         */
        setTabPageHeader(tab: TabPageInfo, header: string): void;
        /**
         * Загрузить содержимое указанной вкладки
         * @param tab Вкладка
         */
        loadTabPage(tab: TabPageInfo): JQueryDeferred<TabPageInfo>;
        /**
         * Открыть указанную вкладку
         * @param tabNumber Номер вкладки
         */
        openTabPage(tabNumber: number): JQueryDeferred<any>;
        /** @internal */
        protected createImpl(): TabImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TabState extends TabParams, PanelState {
        requestHelper: RequestHelper;
    }
    /** @internal */
    type TabImplProps = TabState;
    /** @internal */
    type TabImplState = TabState;
    /** @internal */
    class TabImpl extends PanelImpl<TabParams, TabState> {
        constructor(props: TabParams, state: TabState);
        openTab(tab: TabPageInfo): Promise<void>;
        loadTab(tab: TabPageInfo): JQueryDeferred<TabPageInfo>;
        protected parseTabs(): void;
        protected onTabClick(tab: TabPageInfo): void;
        protected activateTab(tab: TabPageInfo): JQueryDeferred<any>;
        protected updateMobileTab(tab: TabPageInfo): void;
        activeTabPage: TabPageInfo;
        renderNavPanelMobileTabs(): void;
        protected shouldTabsToBeMobile(): boolean;
        renderTabsPanel(): JSX.Element;
        renderControl(): JSX.Element;
        setTabPageHeader(tab: TabPageInfo, header: string): void;
        loadTabPage(tab: TabPageInfo): JQueryDeferred<TabPageInfo>;
        openTabPage(tabNumber: number): JQueryDeferred<any>;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Таблица]{@link Table}.
     */
    class TableParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Строки таблицы. */
        rows: string[];
        /** Текст всплывающей подсказки. */
        tip: string;
        /** Заголовок. */
        header: string;
        /** Режим редактирования. */
        editMode: EditMode;
        /** Имеются ли дополнительные неотображаемые строки. */
        hasMore: boolean;
        /** Столбцы таблицы. */
        columns: GenModels.LayoutTableColumnInfo[];
        /** Максимальное количество строк для отображения. */
        maxRowCount: number;
        /** Разрешено ли редактирование. */
        editAllowed: boolean;
        /** Имена дочерних контролов. */
        childControlsNames: string[];
        /** Можно ли сворачивать таблицу. */
        collapsible: boolean;
        /** Развёрнута ли таблица. */
        isExpanded: boolean;
        /** Прокручивать ли страницу при добавлении новой строки. */
        scrollIntoView: boolean;
        /** Событие, возникающее при добавлении строки. */
        rowAdding: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее после добавления строки. */
        rowAdded: BasicApiEvent<IRowEventArgs>;
        /** Событие, возникающее при удалении строки. */
        rowRemoving: CancelableApiEvent<IRowEventArgs>;
        /** Событие, возникающее после удаления строки. */
        rowRemoved: BasicApiEvent<IRowEventArgs>;
        /** Событие, возникающее перед сворачиванием. */
        collapsing: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее при сворачивании. */
        collapsed: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед разворачиванием. */
        expanding: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее при разворачивании. */
        expanded: BasicApiEvent<IEventArgs>;
        services?: $LayoutCardController & $Layout;
    }
    /**
     * Класс элемента управления Таблица
     *
     * Добавляет в web-разметку элемент управления для отображения таблицы.
     */
    class Table extends Panel<TableParams, TableState> {
        constructor(props: TableParams);
        /** @internal */
        protected createParams(): TableParams;
        /** @internal */
        componentDidMount(): void;
        /** @internal */
        componentWillUnmount(): void;
        /** @internal */
        protected getBindingResultData(): GenModels.LayoutTableBindingModel;
        /** @internal */
        protected isCollapsedSetter: boolean;
        /** @internal */
        protected getBindings(): IBindingResult<any>[];
        saveAndReload(): JQueryDeferred<GenModels.ControlModel>;
        /** @internal */
        protected saveTable(): JQueryDeferred<any>;
        private readonly tableImpl;
        private binding;
        /** Get list of row id, currently shown in the table */
        private readonly rows;
        private isCollapsed;
        private readonly columns;
        /**
         * Установка заголовка столбца таблицы.
         * @param columnNumber Номер столбца
         * @param header Новый заголовок
         */
        setColumnHeader(columnNumber: number, header: string): void;
        /**
         * Установка ширины столбца таблицы.
         * @param columnNumber Номер столбца
         * @param columnWidth Новая ширина (любые единицы измерения)
         */
        setColumnWidth(columnNumber: number, columnWidth: string): void;
        /**
         * Установка подсказки для столбца таблицы.
         * @param columnNumber Номер столбца
         * @param tip Новая подсказка
         */
        setColumnTip(columnNumber: number, tip: string): void;
        /**
         * Установка видимости для столбца таблицы.
         * @param columnNumber Номер столбца
         * @param visibility Виден ли или нет
         */
        setColumnVisibility(columnNumber: number, visibility: boolean): void;
        /**
         * Возвращает номер строки или -1, если строка не найдена.
         * @param rowId Идентификатор искомой строки
         */
        getRowIndex(rowId: string): number;
        /**
         * Добавить новую строку.
         */
        addRow(): JQueryDeferred<any>;
        /**
         * Удалить строку с указанным идентификатором
         * @param rowId Идентификатор удаляемой строки
         */
        removeRow(rowId: string): JQueryDeferred<any>;
        /** @internal */
        protected onCardSaving(sender: any, args: ICancelableEventArgs<GenModels.SaveControlDataModel>): void;
        /** @internal */
        protected onCardSaved(): void;
        /** @internal */
        protected createImpl(): TableImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TableState extends TableParams, PanelState {
        binding: IBindingResult<GenModels.LayoutTableBindingModel>;
        model: GenModels.LayoutTableBindingModel;
        saveAndReload: () => JQueryDeferred<GenModels.ControlModel>;
        saveTable: () => JQueryDeferred<any>;
        tableRows: IRowInfo[];
        newRowTemplate: IRowInfo;
        isExpanded: boolean;
        collapsible: boolean;
        addRowState: LoadingState;
        columnWrappers: TableColumnWrapper[];
        header: string;
        tip: string;
    }
    /** @internal */
    type TableImplState = TableState;
    /** @internal */
    class TableImpl extends PanelImpl<TableParams, TableState> {
        static BindingNotSpecifiedMetadataKey: string;
        constructor(props: TableParams, state: TableState);
        protected prepareChildren(): void;
        protected parseRows(children: GenModels.ControlModel[]): void;
        setColumnProperty(columnIndex: number, propertyName: string, propertyValue: any): void;
        protected readonly editMode: boolean;
        protected onDisclosureClick(): void;
        toggleCollapsed(): void;
        protected onCollapsed(): void;
        protected onExpanded(): void;
        protected canAddRows(): boolean;
        protected canRemoveRows(): boolean;
        protected bindingConfigured(): boolean;
        readonly rows: string[];
        isCollapsed: boolean;
        readonly columns: TableColumnWrapper[];
        addRowInternal(scroll?: boolean): JQueryDeferred<any>;
        protected onAddRowClick(ev: React.MouseEvent<any>): void;
        protected isElementInViewport(el: any): boolean;
        /** Проверяет, введены ли какие-либо значения пользователем в контролы указанной строки.
          * Функция может выдавать неверные результаты для нестандартных контролов, поэтому
          * следует использовать ее только там, где это не некритично.
          */
        protected checkRowIsEmpty(rowIndex: number): boolean;
        removeRowIntenral(rowIndex: number): JQueryDeferred<any>;
        protected onRemoveRowClick(row: IRowInfo): void;
        protected getCssClass(): string;
        renderControl(): JSX.Element;
        getRowIndex(rowId: string): number;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Отображение варианта завершения]{@link TaskCardCompletionOption}.
     */
    class TaskCardCompletionOptionParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /** Текст метки. Метка - текст отображаемый рядом (слева или вверху) с элементом управления. */
        labelText?: string;
        /** Значение элемента управления. */
        value?: GenModels.CompletionOption;
        services?: $EditOperationStore;
    }
    /**
     * Класс элемента управления Отображение варианта завершения.
     */
    class TaskCardCompletionOption extends BaseControl<TaskCardCompletionOptionParams, TaskCardCompletionOptionState> {
        /** @internal */
        protected createParams(): TaskCardCompletionOptionParams;
        private completionOptionBinding;
        private readonly myControlImpl;
        /** @internal */
        protected createImpl(): TaskCardCompletionOptionImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TaskCardCompletionOptionState extends TaskCardCompletionOptionParams, BaseControlState {
    }
    /** @internal */
    type TaskCardCompletionOptionImplState = TaskCardCompletionOptionState;
    /** @internal */
    class TaskCardCompletionOptionImpl extends BaseControlImpl<TaskCardCompletionOptionParams, TaskCardCompletionOptionState> {
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Задания]{@link Tasks}.
     */
    class TasksParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Список заданий. */
        tasks: GenModels.TaskDataModel[];
        /** Виды заданий для отображения. */
        viewKinds?: any;
        /** Виды заданий для создания. */
        tasksCreateInfo?: GenModels.CreateKindDataModel[];
        /** Можно ли создавать задания. */
        canCreateTask?: boolean;
        /** Можно ли создавать группы заданий. */
        canCreateTaskGroup?: boolean;
        /** Заголовок. */
        header?: string;
        /** Показывать ли дайджест представления заданий, когда контрол свёрнут. */
        digestView?: boolean;
        /** Развёрнут ли контрол с заданиями. */
        isExpanded: boolean;
        /** Разрешено ли добавление заданий. */
        addTaskAllowed?: boolean;
        /** Загружены ли задания. */
        tasksLoaded: boolean;
        /** Идентификатор карточки. */
        cardId: string;
        /** Режим. */
        mode: GenModels.TasksDisplayMode;
        /** Событие, возникающее перед сворачиванием. */
        collapsing?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее при сворачивании. */
        collapsed?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед разворачиванием. */
        expanding?: CancelableApiEvent<IEventArgs>;
        /** Событие, возникающее при разворачивании. */
        expanded?: BasicApiEvent<IEventArgs>;
        /** Событие, возникающее перед созданием задачи. */
        taskCreating?: CancelableApiEvent<ITaskCreatingEventArgs>;
        services?: $LayoutTasksController & $EditOperationStore;
    }
    /**
     * Класс элемента управления Задания
     *
     * Добавляет в web-разметку элемент управления для работы с заданиями.
     */
    class Tasks extends BaseControl<TasksParams, TasksState> {
        /** @internal */
        protected createParams(): TasksParams;
        private readonly tasksImpl;
        private binding;
        private createKindsBinding;
        /**
         * Добавление задания.
         * @param taskCreateInfoId Идентификатор добавляемого задания
         */
        addTask(taskCreateInfoId: string): void;
        /** @internal */
        protected createImpl(): TasksImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TasksState extends TasksParams, BaseControlState {
        availableKinds: string[];
        taskID: string;
        totalTasksCount: number;
        tasksLoadingHelper: RequestHelper;
        inAnimation: boolean;
    }
    /** @internal */
    type TasksImplState = TasksState;
    /** @internal */
    class TasksImpl extends BaseControlImpl<TasksParams, TasksState> {
        protected taskList: TaskListComponent;
        constructor(props: TasksParams, state: TasksState);
        componentDidMount(): void;
        canAddTask(): boolean;
        addTask(taskCreateInfoId: string): void;
        getCssClass(): string;
        protected handleHeaderClick(): void;
        protected handleCreateTask(item: GenModels.CreateKindDataModel): void;
        renderControl(): JSX.Element;
        isExpanded: boolean;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Дерево исполнения]{@link TasksTree}.
     */
    class TasksTreeParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Идентификатор списка заданий. */
        taskCardId?: string;
        /** Идентификатор карточки документа или задания */
        cardId?: string;
        /** Текст кнопки. */
        buttonText?: string;
        /** Операция показа полного дерева*/
        showFullTreeBinding?: string;
        /** Режим отображения. */
        displayMode?: GenModels.TasksTreeDisplayMode;
        /** Максимальное количество заданий группы */
        maxGroupTaskNumber: number;
        /** Режим отображения группы из одного задания. */
        taskGroupWithOneTaskDisplayMode: GenModels.TaskGroupWithOneTaskDisplayMode;
        /** Виды заданий для отображения. */
        viewKinds: string[];
        /** Сервис для управления резолверами задач. */
        nodeResolveService: TasksTreeNodeResolveService;
        /** Цвета. */
        colors: ITasksTreeColorMap;
        /** Группы. */
        groups: ITasksTreeGroupMap;
        /** Список опций для VIS.js. */
        options: vis.Options;
        services?: $FileController & $LayoutFileController & $RequestManager & $CardInfo & $EditOperationStore;
    }
    /**
     * Класс элемента управления Дерево исполнения
     *
     * Добавляет в web-разметку элемент управления для работы с деревом исполнения.
     */
    class TasksTree extends BaseControl<TasksTreeParams, ITasksTreeState> {
        constructor(props: TasksTreeParams);
        private binding;
        private showFullTreeBinding;
        private viewKindsBinding;
        /** @internal */
        protected createParams(): TasksTreeParams;
        private getDefaultVisOptions();
        /** @internal */
        protected createImpl(): TasksTreeImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeState extends TasksTreeParams, BaseControlState {
        isTreeVisible: boolean;
        isFullTreeLoaded: boolean;
        isCurrentTaskFocused: boolean;
        isOverdueFiltered: boolean;
        isImportantFiltered: boolean;
        isOnControlFiltered: boolean;
        isShowBranchFiltered: boolean;
        tasksTreeModel: GenModels.TasksTreeModel;
        loadVisJsHelper: RequestHelper;
        showFullTreeBindingAvailable: boolean;
    }
    /** @internal */
    type ITasksTreeImplState = ITasksTreeState;
    /** @internal */
    class TasksTreeImpl extends BaseControlImpl<TasksTreeParams, ITasksTreeState> {
        tasksTreeContainer: TasksTreeContainer;
        constructor(props: TasksTreeParams, state: ITasksTreeState);
        private loadFullTreeHandler();
        private loadCurrentTaskTreeHandler();
        componentDidMount(): void;
        private сurrentTaskFocusHandler();
        private overdueHandler();
        private importantHandler();
        private onControlHandler();
        private showBranchHandler();
        private collapseAllHandler();
        private expandAllHandler();
        private refreshHandler();
        private loadVisJS();
        private loadTasksTree(fullTree);
        private getTasksTree(fullTree);
        private onTasksTreeClick;
        private showTreeModal;
        private hideTreeModal;
        private hasParentCard();
        renderControl(): JSX.Element;
        private renderTreeModal();
        private renderTreeContent();
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeRibbon extends ITasksTreeImplState {
        onLoadFullTreeClick: () => void;
        onLoadCurrentTaskTreeClick: () => void;
        onCurrentTaskFocusClick: () => void;
        onOverdueClick: () => void;
        onImportantClick: () => void;
        onControlClick: () => void;
        onShowBranchClick: () => void;
        onCollapseAllClick: () => void;
        onExpandAllClick: () => void;
        onRefreshClick: () => void;
    }
    /** @internal */
    const TasksTreeRibbon: (props: ITasksTreeRibbon) => JSX.Element;
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства класса [TextControlBase]{@link TextControlBase}.
     */
    class TextControlBaseParams extends InputBasedControlParams<string> {
    }
    /**
     * Класс, позволяющий создавать на своей основе контролы для редактирования текстовой информации
     */
    abstract class TextControlBase<P extends TextControlBaseParams, S extends TextControlBaseState> extends InputBasedControl<string, P, S> {
        /** @internal */
        protected binding: IBindingResult<string>;
        /** В производных классах должен возвращать совместимый контейнер сервисов. */
        protected abstract getServices(): $LayoutInfo & $EditOperationStore;
        /** Использует свойства `this.state.binding` и параметр labelText. */
        protected getBindings(): IBindingResult<string>[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface TextControlBaseState extends TextControlBaseParams, InputBasedControlState<string> {
        binding: IBindingResult<string>;
    }
    type TextControlBaseImplState = TextControlBaseState;
    abstract class TextControlBaseImpl<PropsT extends TextControlBaseParams, StateT extends TextControlBaseState> extends InputBasedControlImpl<string, PropsT, StateT> {
        constructor(props: PropsT, state: StateT);
        protected abstract renderInto(props: TextControlBaseParams, container: HTMLElement): void;
        protected onInputChange(event: any): void;
        protected getTextValue(): string;
        protected getCssClass(): string;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Текст]{@link TextArea}.
     */
    class TextAreaParams extends TextControlBaseParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        services?: $LayoutInfo & $EditOperationStore;
    }
    /**
     * Класс элемента управления Текст
     *
     * Добавляет в web-разметку элемент управления для хранения текстовой информации.
     */
    class TextArea extends TextControlBase<TextAreaParams, TextAreaState> {
        protected createParams(): TextAreaParams;
        /** @internal */
        protected createImpl(): TextAreaImpl;
        /** @internal */
        protected getServices(): $LayoutInfo & $EditOperationStore;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TextAreaState extends TextAreaParams, TextControlBaseState {
    }
    /** @internal */
    type TextAreaImplState = TextAreaState;
    /** @internal */
    class TextAreaImpl extends TextControlBaseImpl<TextAreaParams, TextAreaState> {
        constructor(props: TextAreaParams, state: TextAreaState);
        setValue(value: string, redraw: boolean): void;
        protected renderInput(): JSX.Element;
        protected renderInto(props: TextAreaParams, container: HTMLElement): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<string, TextAreaParams, TextAreaState>>;
        protected attachInput(inputElem: any): void;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства класса [TextBox]{@link TextBox}.
     */
    class TextBoxParams extends TextControlBaseParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        services?: $LayoutInfo & $EditOperationStore;
    }
    /**
     * Вспомогательный контрол для редактирования текстовой информации.
     */
    class TextBox extends TextControlBase<TextBoxParams, TextBoxState> {
        /** @internal */
        protected createParams(): TextBoxParams;
        /** @internal */
        protected createImpl(): TextBoxImpl;
        /** @internal */
        protected getServices(): $LayoutInfo & $EditOperationStore;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TextBoxState extends TextBoxParams, TextControlBaseState {
    }
    /** @internal */
    type TextBoxImplState = TextBoxState;
    /** @internal */
    class TextBoxImpl extends TextControlBaseImpl<TextBoxParams, TextBoxState> {
        constructor(props: TextBoxParams, state: TextBoxState);
        protected renderInto(props: TextBoxParams, container: HTMLElement): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<InputBasedControl<string, TextBoxParams, TextBoxState>>;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Срок исполнения]{@link TimeOfPerfomance}.
    */
    class TimeOfPerfomanceParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Имя элемента управления {@link DateTimePicker}, содержащего дату начала периода */
        startDateControlName: string;
        /** Имя элемента управления {@link DateTimePicker}, содержащего дату завершения периода */
        endDateControlName: string;
        /** Имя элемента управления {@link NumberControl}, содержащего длительность периода */
        durationControlName: string;
        /** Настройка, определяющая как дочерние элементы должны быть расположены в пространстве - в строку или в столбец. */
        orientation?: GenModels.Orientation;
        /** Флаг, определяющий, что использовать для рассчета длительности и даты завершения - бизнес-календарь или обычный календарь.
          * Для заданий и групп заданий значение по умолчанию получается из настроек справочника видов.
          */
        useBusinessCalendar?: boolean;
        /** Параметр, определяющий, какой бизнес-календарь будет использован.
          * 1. Если значение не задано, то будет использован системный календарь
          *    (или настройки по умолчанию рабочий день с 9 до 18, пн-пт, если он не доступен).
          * 2. Если задан сотрудник или подразделение, то календарь настроенный для сотрудника или подразделения в справочнике сотрудников.
          *    Если в справочнике сотрдуников календарь не настрен, то см. пункт 1.
          * 3. Если задано несколько сотрудников одного подразделения, то календарь настроенный для этого подразделения. Иначе см. пункт 1.
          */
        businessClandarSources?: GenModels.BusinessCalendarSource[];
        /** Событие, возникающее перед получением длительности периода. */
        gettingDuration?: CancelableApiEvent<GenModels.CalendarDurationRequestModel>;
        /** Событие, возникающее после получения длительности периода. */
        gotDuration?: BasicApiEvent<number>;
        /** Событие, возникающее перед получением конца периода. */
        gettingEndDate: CancelableApiEvent<GenModels.CalendarEndDateRequestModel>;
        /** Событие, возникающее после получения конца периода. */
        gotEndDate: BasicApiEvent<Date>;
        services?: $BusinessCalendarController & $ControlStore;
    }
    /**
     * Класс элемента управления Срок исполнения.
     *
     * Добавляет в web-разметку блок с тремя контролами: дата начала, конец и длительность периода. При изменении значения каждого из контролов
     * автоматически обновляется значение других с учетом бизнес календаря (см. {@link useBusinessCalendar} и {@link businessClandarSources}). В частности:
     * 1. При изменении даты начала вычисляется дата заврешения
     * 2. При изменении даты завершения вычисляется длительность
     * 3. При изменении длительности вычисляется дата завершения
     */
    class TimeOfPerfomance extends Panel<TimeOfPerfomanceParams, TimeOfPerfomanceState> {
        /** @internal */
        protected createParams(): TimeOfPerfomanceParams;
        /** @internal */
        init(): void;
        /** @internal */
        protected useBusinessCalendarBinding: IBindingResult<boolean>;
        /**
         * Возвращает длительность периода на основе даты начала и конца.
         */
        getDuration(startDate: Date, endDate: Date): JQueryDeferred<number>;
        /**
         * Возвращает конец периода на основе даты начала и длительности.
         */
        getEndDate(startDate: Date, duration: number): JQueryDeferred<Date>;
        /** @internal */
        createImpl(): TimeOfPerfomanceImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TimeOfPerfomanceState extends TimeOfPerfomanceParams, PanelState {
        startDate: DateTimePicker;
        endDate: DateTimePicker;
        duration: NumberControl;
        initializationSuccess: boolean;
        lastCalculatedEndDate: Date;
        lastCalculatedDuration: number;
        startDateChangeDebouncer: Debouncer;
        endDateChangeDebouncer: Debouncer;
        durationChangeDebouncer: Debouncer;
    }
    /** @internal */
    class TimeOfPerfomanceImpl extends PanelImpl<TimeOfPerfomanceParams, TimeOfPerfomanceState> {
        constructor(props: TimeOfPerfomanceParams, state: TimeOfPerfomanceState);
        init(): void;
        onStartDateChanged: (sender: any, args: IDataChangedEventArgsEx<Date>) => Promise<void>;
        onEndDateChanged: (sender: any, args: IDataChangedEventArgsEx<Date>) => Promise<void>;
        onDurationChanged: (sender: any, args: IDataChangedEventArgsEx<number>) => Promise<void>;
        showLoader(conrol: LayoutControl): void;
        hideLoader(conrol: LayoutControl): void;
        getDuration(startDate: Date, endDate: Date): JQueryDeferred<number>;
        getEndDate(startDate: Date, duration: number): JQueryDeferred<Date>;
        getCssClass(): string;
        renderControl(): React.ReactNode[];
    }
}
declare namespace WebClient {
    /** @internal */
    function bubling(target: Object, propertyKey: string | symbol): void;
    /** @internal */
    function isBublingEvent(control: any, propertyKey: string): boolean;
}
declare namespace WebClient {
    /** Возвращает описатель собственного свойства, или свойства одного из родительских классов.  */
    function getPropertyDescriptor(control: Object, propertyKey: string): PropertyDescriptor;
    /** Возвращает метаданные, ассоциированные при помощи Reflect.metadata с собственным свойством, или свойством базового класса. */
    function getMetadataValue(obj: any, propertyKey: string, metadataKee: string): any;
    /** Добавляет в объект свойство со значением undefined. */
    function declareSimpleProperty(target: Object, propertyKey: string): void;
}
declare namespace WebClient {
    /** Декоратор, служащий для обозначения параметров описывающих события. */
    function apiEvent(target: Object, propertyKey: string | symbol): void;
    /** Определяет, было ли свойство объекта помечено через декоратор {@link apiEvent}. */
    function isEvent(params: any, propertyKey: string): boolean;
}
declare namespace WebClient {
    /** Декоратор, служащий для обозначения что данный метод доступа предназначен для реализации доступа к параметру элемента управления. */
    function handler(paramNameSpec: FieldSpec<any, any>): (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>) => TypedPropertyDescriptor<any>;
    /** Возвращает имя свойства, ассоциированное при помощи декоратора {@link handler}.  */
    function getHandlerProperty(control: any, propertyKey: string): string;
    /**
     * Используется для формирования объекта {@link FieldSpec} при вызове функции {@link getFieldName}.
     * Функция преобразует ссылку на имя класса в ссылку на объект класса. Это необходимо для получения
     * ссылки на свойство, понятное TypeScript.
     * @param typeName Имя класса
     */
    function at<T>(typeName: {
        new (): T;
    }): T;
}
declare namespace WebClient {
    /** Декоратор, который помечает параметр как доступны для только чтения. */
    function r(target: Object, propertyKey: string | symbol): void;
    /** Определяет, было ли свойство объекта помечено через декоратор {@link r}. */
    function isReadonly(control: any, propertyKey: string): boolean;
}
declare namespace WebClient {
    /** Декоратор, который помечает параметр как доступны для чтения и записи. */
    function rw(target: Object, propertyKey: string | symbol): void;
    /** Определяет, было ли свойство объекта помечено через декоратор {@link rw}. */
    function isReadWrite(control: any, propertyKey: string): boolean;
}
declare namespace WebClient {
    /** Хранилище информации о типах карточек. */
    class CardTypeResolver {
        protected CardTypeMap: ICardTypeMap;
        protected unknownCardType: {
            id: string;
            name: string;
            cssClass: string;
            caption: string;
        };
        /** Регистрирует новый тип карточки. */
        registerCardType(cardTypeInfo: ICardTypeInfo): void;
        /** Возвращает информацию об определенном типе карточки. */
        getCardTypeInfo(cardTypeId: string): ICardTypeInfo;
    }
}
declare var cardTypesRaw: WebClient.ICardTypeRawMap;
declare var cardTypeResolver: WebClient.CardTypeResolver;
declare namespace WebClient {
    /** Информация о типе карточки, необходимая для изменения внешнего вида Web-клиента при открытии карточек этого типа (цвет фона, заголовок). */
    interface ICardTypeInfo {
        /** Идентификатор типа карточки. */
        id: string;
        /** Имя типа карточки. */
        name: string;
        /** CSS-класс, содержащий стили для изменения внешнего вида Web-клиента (например, цвет фона шапки и меню). */
        cssClass: string;
        /** Заголовок, который будет отображен в шапке Web-клиента. */
        caption: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICardTypeMap {
        [id: string]: ICardTypeInfo;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICardTypeRaw {
        Name: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICardTypeRawMap {
        [id: string]: ICardTypeRaw;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IServerErrorResponse {
        ExceptionMessage?: string;
        ExceptionType?: string;
        Message?: string;
        StackTrace?: string;
    }
    /**
     * Стандартная серверная ошибка
     */
    class ServerError {
        message: string;
        type: string;
        stack: string;
        constructor(message: string, type: string, stack: string);
        static fromResponse(data: IServerErrorResponse): ServerError;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IProxyControl {
        isProxyControl: boolean;
        renderProxyChildren(): React.ReactNode[];
    }
}
declare namespace WebClient {
    /** @internal */
    enum BublingEventResult {
        Continue = 0,
        StopPropogation = 1,
    }
    /** @internal */
    interface IBublingEventInfo {
        name?: string;
        bubling: boolean;
    }
    /** @internal */
    type BublingEventCallback = (actualSender: ISupportEventBubling, args: IEventArgs) => BublingEventResult | void;
    /** @internal */
    interface ISupportEventBubling {
        supportEventBubling: boolean;
        getEventInfo<T>(event: IBasicEvent<T>): IBublingEventInfo;
        triggerBublingEvent<T>(eventName: string, actualSender: ISupportEventBubling, args: T): any;
        subscribteToBublingEvent(eventName: string, callback: BublingEventCallback): any;
        unsubscribteToBublingEvent(eventName: string, callback: BublingEventCallback): any;
    }
}
declare namespace WebClient {
    /** Хранилище контролов разметки, обеспечивающее доступ по имени. */
    class ControlStore {
        protected controlCollection: ControlWrapperMap;
        protected controlsList: LayoutControl[];
        /** Возвращает словарь контролов, где ключами выступают имена контролов, а значениями их экземпляры. */
        readonly controls: ControlWrapperMap;
        /** Добавляет контрол в словарь. */
        add(nameSrc: string, control: LayoutControl): LayoutControl;
        /** Удаляет контрол из словаря по имени. */
        remove(name: string): void;
        /** Удаляет контрол из словаря. */
        removeControl(control: LayoutControl): void;
        /** Вызывает методы onSaving в контролах. */
        onSaving(): JQueryDeferred<any>;
        /** Вызывает методы onSaved в контролах. */
        onSaved(): JQueryDeferred<any>;
        /** @internal */
        protected collectControlData(func: (control: LayoutControl) => void): void;
        /** @internal */
        protected callSaveCallbacks(beforeSave: boolean): JQueryDeferred<any>;
    }
}
declare namespace WebClient {
    /** @deprecated */
    type LayoutControlWrapper = ApiControlWrapper<any, any>;
    /** @deprecated */
    class ApiControlWrapper<P extends BaseControlParams, S extends BaseControlState> {
        control: BaseControl<P, S>;
    }
}
declare namespace WebClient {
    /** Словарь контролов с доступом по имени. */
    class ControlWrapperMap {
        [name: string]: any;
        get<T extends LayoutControl | LayoutControl[]>(name: string): T;
    }
}
declare namespace WebClient {
    /** @deprecated */
    interface IApiPropertyDescriptor {
        propertyName: string;
        get?(): any;
        set?(v: any): void;
    }
}
declare namespace WebClient {
    /** Словарь контролов с доступом по имени. */
    interface IControlMap {
        [name: string]: () => LayoutControlType;
    }
}
declare namespace WebClient {
    /** Словарь контролов с доступом по имени. */
    interface IControlWrapperMap {
        [name: string]: LayoutControl | LayoutControl[];
    }
}
declare namespace WebClient {
    /** @internal */
    class EditOperationStore implements IEditOperationStore {
        protected editOperations: IEditOperationMap;
        protected builtInEditOperations: IEditOperationMap;
        protected emptyGuidValue: string;
        add(editOpeation: IEditOperation): void;
        addRange(editOpeations: IEditOperation[]): void;
        remove(id: string): void;
        available(id: string): boolean;
        availableBuiltIn(builtInOperationId: string): boolean;
        get(id: string): IEditOperation;
        getAll(): IEditOperation[];
        protected prepareId(id: string): string;
    }
}
declare namespace WebClient {
    /**
    * Содержит данные операции редактирования, зарегистрированной в *Конструкторе состояний*.
    */
    interface IEditOperation {
        /** Идентификатор операции редактирования в *Конструкторе состояний*. */
        id: string;
        /** Идентификатор встроенной (в карточку) операции редактирования. */
        builtInId?: string;
        /** Отображаемое название операции редактирования. */
        caption: string;
        /** Флаг, указывающий, что операция доступна для текущего состояния карточки: true - доступна, false - не доступна. */
        available: boolean;
    }
}
declare namespace WebClient {
    /** Словарь операций редактирования с доступом по id. */
    interface IEditOperationMap {
        [id: string]: IEditOperation;
    }
}
declare namespace WebClient {
    /**
    * Содержит данные и методы хранилища операций редактирования.
    */
    interface IEditOperationStore {
        /**
        * Проверяет доступность операции редактирования.
        * @param id Идентификатор операции редактирования.
        * @returns true - операция доступна, false - операция не доступна.
        */
        available(id: string): boolean;
        /**
        * Проверяет доступность встроенной операции редактирования.
        * @param id Идентификатор встроенной операции редактирования.
        * @returns true - операция доступна, false - операция не доступна.
        */
        availableBuiltIn(builtInOperationId: string): boolean;
        /**
       * Возвращает операцию редактирования с указанным идентификатором.
       * @param id Идентификатор операции редактирования.
       * @returns Операция редактирования.
       */
        get(id: string): IEditOperation;
        /**
        * Возвращает все операции редактирования, зарегистрированные в *Конструкторе состояний* для текущего вида карточки.
        * @returns Массив операций редактирования.
        */
        getAll(): IEditOperation[];
    }
}
declare namespace WebClient {
    /** Системные операции редактирования. */
    class CommonBuiltInOperations {
        static Delete: string;
        static Write: string;
    }
}
declare namespace WebClient {
    /** Класс для управления клиентскими расширениями Web-клиента. */
    class ExtensionManager {
        private extensions;
        /** Регистрирует расширение. */
        registerExtension(extension: IExtension): void;
        /** Возвращает список зарегистрированных расширений. */
        readonly Extensions: IExtension[];
    }
}
declare var extensionManager: WebClient.ExtensionManager;
declare namespace WebClient {
    /** Интерфейс расширения Web-клиента. */
    interface IExtension extends IUrlCollection {
        /** Вызывается при регистрации расширения. */
        initialize(): any;
        /** Служит для добавления локализаций в {@link resources} */
        getLocalizations(): ILocalizationsMap;
    }
}
declare namespace WebClient {
    /** @deprecated */
    interface ILayoutBootstrapperParams {
        rootElementId: string;
    }
}
declare namespace WebClient {
    /** @deprecated */
    class LayoutBootstrapper {
        private readonly layoutBootstrapperParams;
        readonly rootElementId: string;
        readonly rootElement: HTMLElement;
        constructor(layoutBootstrapperParams: ILayoutBootstrapperParams);
        initilialize(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILayoutContainerMap {
        [name: string]: LayoutContainer;
    }
}
declare namespace WebClient {
    /** Параметры для создания экземпляра класса {@link LayoutContainer}. */
    interface ILayoutContainerParams {
        /** Идентификатор DOM-элемента, в котором необходимо расположить разметку. Вместо этого параметра можно передать сам элемент в {@link rootElement}. */
        rootElementId?: string;
        /** DOM-элемент, в котором необходимо расположить разметку. Вместо этого параметра можно передать id элемента в {@link rootElementId}. */
        rootElement?: HTMLElement;
        /** Уникальное имя разметки. */
        name: string;
        /** Название родительской разметки. */
        owner?: string;
        /** Список имён дочерних компонентов. */
        children: string[];
        /** Тип разметки (служит для идентификации файла разметки на сервере). */
        positionName: string;
        /** Вызывается перед выгрузкой разметки. */
        unmountCallback: (positionName: string) => void;
        /** Модель разметки, содержащая описание контролов. */
        layoutCardModel: GenModels.LayoutCardViewModel;
    }
}
declare namespace WebClient {
    /** Сервисный класс, обеспечивающий функционирование разметки. */
    class LayoutContainer {
        private readonly layoutContainerParams;
        private layoutResolver;
        private layoutServiceContainer;
        private initialized;
        /**
        * Возвращает разметку карточки.
        */
        readonly layout: Layout;
        /**
        * @deprecated Используйте свойство positionName.
        */
        readonly PositionName: string;
        /**
         * Возвращает наименование позиции разметки
         */
        readonly positionName: string;
        /**
         * Возвращает наименование разметки
         */
        readonly name: string;
        /**
         * Возвращает наименование родительской разметки
         */
        readonly owner: string;
        /**
         * Возвращает наименования дочерних разметок
         */
        /**
         * Устанавливает наименования дочерних разметок
         */
        children: string[];
        /**
        * Возвращает идентификатор корневого элемента, в котором расположена разметка.
        */
        readonly rootElementId: string;
        /**
        * Возвращает корневой элемент, в котором расположена разметка.
        */
        readonly rootElement: HTMLElement;
        /** Модель разметки, поступившая с сервера Web-клиента. */
        readonly layoutCardModel: GenModels.LayoutCardViewModel;
        constructor(layoutContainerParams: ILayoutContainerParams);
        /**
         * Уничтожение разметки.
         */
        destroy(): JQueryDeferred<any>;
        /**
         * Инициализация разметки.
         */
        initialize(deferred: JQueryDeferred<Layout>): void;
        /** @internal */
        protected mapLayout(layoutResolver: () => Layout): void;
        /** @internal */
        protected reactJsUnmount(): void;
        /** @internal */
        protected renderLayout(deferred: JQueryDeferred<Layout>): void;
        /** @internal */
        protected prepareModel(deferred: JQueryDeferred<Layout>): void;
        /** Обрабатывает параметры с суфиксом -res в имени, добавляя значение ресурса в соответствующий параметр. */
        protected processResParameters(layoutModel: GenModels.LayoutModel): void;
    }
}
declare namespace WebClient {
    /**
     * Стандартная модель ответа сервера.
     * @param ResponseModelT тип возвращаемых данных
     */
    interface ICommonResponse<ResponseModelT> {
        /**
         * Успешно ли завершился запрос.
        */
        success: boolean;
        /**
         * Временная метка карточки.
        */
        timestamp: number;
        /**
         * Идентификатор карточки, для которой возвращен {@link timestamp}
        */
        timestampCardId: string;
        /**
         * Сообщение об ошибке или предупреждение.
        */
        message: string;
        /**
         * Данные.
        */
        data: ResponseModelT;
    }
}
declare namespace WebClient {
    /** @deprecated */
    interface INotificationModel {
        type: ErrorNotificationType;
        text: string;
    }
}
declare namespace WebClient {
    /**
     * Класс для выполнения длительных операций, предотвращающий повторный запуск одной и той же операции.
     * Для каждой операции должен быть создан отдельный экземпляр класса.
    */
    class RequestHelper {
        private mLoadingState;
        private mLastQuery;
        private mStateChanged;
        private mLoaderDelay;
        private mPreventConcurentQueries;
        constructor(onStateChanged?: (state?: LoadingState) => void, loaderDelay?: number, preventConcurent?: boolean);
        /**
         * Вызывает sendFunc и обновляет {@link state} по мере выполнения запроса. Если предыдущий запрос не был завершен, вызов будет проигнорирован.
         * @param sendFunc Функция, выполняющая длительную операцию.
         * @param done Функция, которая будет вызвана в случае успешного завершения операции.
         * @param fail Функция, которая будет вызвана в случае ошибки.
         */
        send<T>(sendFunc: () => JQueryDeferred<T> | JQueryPromise<T>, done?: (data: T) => void, fail?: (err) => void): LoadingState;
        /**
         * Перегрузка {@link send}, на основе Promise.
         */
        sendEx<T>(sendFunc: () => Promise<T>, done?: (data: T) => void, fail?: (err) => void): LoadingState;
        /** Событие, возникающее при изменении статуса выполнения операции. */
        readonly stateChanged: IBasicEvent<LoadingState>;
        /** Текущее состояние операции. Может быть передано в {@link LoadingIcon} как параметр. */
        readonly state: LoadingState;
        /** Текущее состояние операции (равносильно state.status). */
        readonly status: LoadingStatus;
        /** Операция находится в процессе выполнения. */
        readonly loading: boolean;
        /** Операция завершилась с ошибкой. */
        readonly error: boolean;
        /** Операция завершилась успешно. */
        readonly done: boolean;
        /** @internal */
        readonly defered: JQueryDeferred<any>;
    }
}
declare namespace WebClient {
    /**
     * Класс для выполнения запросов к серверу.
     * Осуществляет стандартный механизм обработки ошибок, показа прогресса выполнения запроса и обновления timestamp карточки.
     */
    class RequestManager {
        private services;
        private lastQuery;
        constructor(services: $Layout);
        /**
         *  Выполняет GET запрос по указанному URL.
         *
          * Ожидается, что сервер должен вернуть {@link CommonResponse} модель.
          *
          * Пример использования:
          *
          *    async function load() {
          *         try {
          *             let data = await requestManager.get(url);
          *             this.loadLinksModel(data);
          *         }
          *             catch(err) {
          *             this.setState({ loadingError: true });
          *         }
          *    }
          */
        get<TResponse>(url: string, options?: RequestOptions): JQueryDeferred<TResponse>;
        /** Отправляет POST запрос по указанному адресу.
          * Аналогичен {@link RequestManager.get}.
          */
        post<TResponse>(url: string, data: string, options?: RequestOptions): JQueryDeferred<TResponse>;
        /** Отправляет запрос и представляет доступ к объекту XMLHttpRequest для чтения ответа.
         *
         * Осуществляет базовую обработку ошибок при помощи {@link processRequestComplete}.
         *
         * При необходимости, можно использовать {@link processRawResponse} передав responseText как параметр для выполнения стандартной логики обработки.
        */
        rawRequest(url: string, data: any, method: RequestMethods, routeChangeProtection?: boolean): JQueryDeferred<XMLHttpRequest>;
        /** В настоящий момент выполняется некоторый запрос. */
        readonly busy: boolean;
        /** Распознает {@link ICommonResponse} модель и вызывает and {@link RequestManager.processResponse}.
         */
        processRawResponse<T>(rawResponse: any, showSuccessNotification?: boolean): ICommonResponse<T>;
        /**
         * Обрабатывает ответ сервера и обновляет значение timestamp карточки в текущей разметке.
         */
        processResponse<T>(response: ICommonResponse<T>, showSuccessNotification?: boolean): void;
        /** @internal */
        showNotification(notification: INotificationModel, showSuccess?: boolean): any;
        /** Логика обработки запроса, завершившегося с ошибкой. */
        processErrorResponse(httpRequest: XMLHttpRequest): void;
        /** Логика обработки ответа сервера.
         * @param routeTimestamp - значение сервиса {@link App.RouteTimestamp}
         * для осуществления защиты от смены роута (после смены роута ответ игнорируется).
         */
        processRequestComplete(httpRequest: any, successCallback: any, routeTimestamp?: number): boolean;
        /**
         * Основной метод, выполняющий отправку запросов.
         */
        protected makeRequest<TResponse>(url: string, data: any, method: RequestMethods, routeChangeProtection?: boolean, options?: RequestOptions): JQueryDeferred<TResponse>;
    }
    /** Сервис для выполнения запросов к серверу. */
    type $RequestManager = {
        requestManager: RequestManager;
    };
}
declare var requestManager: WebClient.RequestManager;
declare namespace WebClient {
    /** См. {@link BasicExtension.getLocalizations}. */
    interface ILocalizationsMap {
        [id: string]: IResourcesMap;
    }
}
declare namespace WebClient {
    /** Словарь локализаций. */
    interface IResourcesMap {
        [id: string]: string;
    }
}
/** Локализации Web-клиента. */
declare var resources: WebClient.IResourcesMap;
declare namespace WebClient {
    /** @internal */
    function action(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>): TypedPropertyDescriptor<any>;
    /** @internal */
    function apiAction(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>): TypedPropertyDescriptor<any>;
    /** @internal */
    function controllerAction(url: string): (target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) => TypedPropertyDescriptor<any>;
    /** @internal */
    function arg(name: string): (target: Object, propertyKey: string, parameterIndex: number) => void;
    /** @internal */
    function postData(target: Object, propertyKey: string, parameterIndex: number): void;
    /** @internal */
    var ServiceActionPostDataArgumentName: string;
    /** @internal */
    function controller(name: string): (target: Object) => void;
}
declare namespace WebClient {
    /** @internal */
    enum RequestMethods {
        Post = 0,
        Get = 1,
    }
}
declare namespace WebClient {
    /** @internal */
    interface IServiceActionParameterInfo {
        index: number;
        name: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class IRequestInfo {
        url: string;
        data: any;
        method: RequestMethods;
    }
}
declare namespace WebClient {
    /** @internal */
    class ServiceActionMetaData {
        type: string;
        url: string;
        parametersInfo: [IServiceActionParameterInfo];
    }
    /** @internal */
    var ServiceActionMetaDataTypeName: string;
}
declare namespace WebClient {
    /** @deprecated */
    interface IUrlCollection {
        getUrls(urlResolver: UrlResolver): IUrlMap;
    }
}
declare namespace WebClient {
    /** @deprecated */
    interface IUrlMap {
        [id: string]: string;
    }
}
declare namespace WebClient {
    /** @deprecated */
    class UrlResolver {
        protected siteUrl: string;
        constructor(siteUrl: string);
        resolveUrlPart(urlPart: string): string;
        resolveUrl(action: string, controller: string, isApi?: boolean, relativePath?: boolean): string;
        resolveApiUrl(action: string, controller: string, relativePath?: boolean): string;
    }
}
declare namespace WebClient {
    /** @deprecated */
    class UrlStore {
        protected urls: IUrlMap;
        protected urlResolverField: UrlResolver;
        constructor(siteUrl: string);
        registerUrlCollection(urlCollection: IUrlCollection): void;
        readonly urlResolver: UrlResolver;
    }
}
declare var urls: WebClient.IUrlMap;
declare var urlStore: WebClient.UrlStore;
declare namespace WebClient {
    /** @review Свойства для {@link DevicesVisibility}  */
    interface IDevicesVisibilityProps {
        devices: GenModels.DeviceType[];
        children?: React.ReactNode;
    }
    /**
      * @review Позволяет показывать содержимое в зависимости от типа устройства.
      *
      * Пример использования:
      *
      *     <DevicesVisibility devices={[DeviceType.Desktop, DeviceType.Tablet]}>
      *         Содержимое
      *     </DevicesVisibility>
      *
      */
    const DevicesVisibility: (props: IDevicesVisibilityProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IAddCardModalDialogProps {
        model: GenModels.AddCardModalModel;
    }
    /** @internal */
    interface IAddCardModalDialogState {
        focusTrapDisabled: boolean;
    }
    /** @internal */
    class AddCardModalDialog extends React.Component<IAddCardModalDialogProps, IAddCardModalDialogState> {
        constructor(props: IAddCardModalDialogProps);
        /** Переключает режим focus trap (вкл/выкл) */
        protected toggleFocusTrap: () => void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAddCardModalDialogContentProps {
        model: GenModels.AddCardModalModel;
        onToggleFocusTrap?: () => void;
    }
    /** @internal */
    class AddCardModalDialogContent extends React.Component<IAddCardModalDialogContentProps, {}> {
        /** @internal */
        shouldComponentUpdate(): boolean;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAddCardModalDialogKindsTreeProps {
        kinds: CardKindTreeNodeModel[];
        onCardKindSelected: (kind: CardKindTreeNodeModel) => void;
        onDestroy?: () => void;
    }
    /** @internal */
    class AddCardModalDialogKindsTree extends React.Component<IAddCardModalDialogKindsTreeProps, {}> {
        componentWillUnmount(): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    namespace Breadcrumbs {
        /** @review Свойства для {@link ButtonItem}  */
        interface IBreadcrumbsItemProps {
            /** Дополнительный класс */
            className?: string;
            style?: React.CSSProperties;
            /** TabIndex элемента */
            tabIndex?: number;
            /** Содержимое */
            children?: React.ReactNode;
            /** При выборе элемента */
            onClick?: () => void;
            disabled?: boolean;
            /** Called on button focus */
            onFocus?: (ev?) => void;
            /** Called on button blur */
            onBlur?: (ev?) => void;
        }
        /**
          * @review Элемент хлебных крошек с произвольным обработчиком клика.
          *
          * Пример использования:
          *
          *     let Item = Breadcrumbs.ButtonItem;
          *     let ItemView = Breadcrumbs.LinkItemView;
          *     let Separator = Breadcrumbs.LinkSeparator;
          *
          *      <div className="padding-v-7">
          *           <Item onClick={() => console.log('Выбран Север')}>
          *               <ItemView>Север</ItemView>
          *           </Item>
          *           <Separator />
          *           <Item onClick={() => console.log('Выбрана Северная верфь')}>
          *               <ItemView>Северная верфь</ItemView>
          *           </Item>
          *      </div>
          *
          * Пример использования в случае, когда элементы заданы в виде массива:
          *
          *     let Item = Breadrcumbs.ButtonItem;
          *     let ItemView = Breadrcumbs.LinkItemView;
          *     let Separator = Breadcrumbs.LinkSeparator;
          *
          *     <div className="padding-v-7">
          *         {["Север", "Северная гавань"].map((item, index) =>
          *             <Item onClick={() => console.log('Выбран ' + item)} key={index}>
          *                 {index > 0 && < Separator />}
          *                 <ItemView>{item}</ItemView>
          *             </Item>
          *         )}
          *     </div>
          *
          */
        const ButtonItem: (props: IBreadcrumbsItemProps) => JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link ComboBoxBody} */
    interface IComboBoxBodyProps {
        /** Дополнительный класс */
        className?: string;
        /** Выключен ли комбобокс */
        disabled?: boolean;
        /** Раскрыт ли выпадающий список элементов или нет */
        expanded: boolean;
        /** Используется при закрытии по клику мышкой снаружи, разрешает клики внутри переданного контейнера (по умолчанию - корень этого компонента) */
        boundaryTarget?: HTMLElement | string;
        /** При закрытии выпадающего списка */
        onClose?: () => void;
    }
    /**
     * @internal Тело комбобокса.
     * Пример использования см. в {@link ComboBoxWrapper}
     */
    class ComboBoxBody extends React.Component<IComboBoxBodyProps, undefined> {
        onClose: () => void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link ComboBoxElement} */
    interface IComboBoxElementProps {
        /** Дополнительный класс */
        className?: string;
        /** Включен ли TabIndex у элемента */
        tabIndex?: boolean;
        /** Выключен ли элемент */
        disabled?: boolean;
        /** Выбран ли элемент */
        selected?: boolean;
        /** Имеет ли элемент фокус в данный момент */
        focused?: boolean;
        /** При выборе элемента */
        onSelect?: () => void;
        /** При фокусе элемента */
        onFocus?: (event: React.FocusEvent<any>) => void;
        /** При снятии фокуса элемента */
        onBlur?: (event: React.FocusEvent<any>) => void;
        /** При передачи фокуса следующему элементу */
        onFocusNext?: () => void;
        /** При передачи фокуса предыдущему элементу */
        onFocusPrev?: () => void;
    }
    /**
     * @internal Элемент выпадающего списка комбобокса.
     * Пример использования см. в {@link ComboBoxWrapper}
     */
    class ComboBoxElement extends React.Component<IComboBoxElementProps, undefined> {
        /**
         * Узел элемента
         */
        el: HTMLElement;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: IComboBoxElementProps): void;
        /**
         * При выборе элемента
         */
        protected onSelect: () => void;
        protected onKeyDown: (e: React.KeyboardEvent<any>) => void;
        readonly tabIndex: number;
        /**
         * Фокусирует элемент
         */
        focus: () => void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Информация о сброшенном элементе. См. {@link ComboBoxHelper} */
    interface IResetedElement {
        wasReset: boolean;
        element: IComboBoxElement;
    }
    /**
     * @internal Хелпер со вспомогательными функциями для пользователских реализаций комбобокса
     */
    class ComboBoxHelper {
        /**
         * Сбрасывает элемент, если он не существует в списке элементов
         * @param element Текущий элемент
         * @param elements Список элементов
         * @param allowEmpty Разрешить ли выбирать пустой элемент
         * @param emptyElement Пустой элемент для значения null
         */
        static resetElementIfNotExists(element: IComboBoxElement, elements: IComboBoxElement[], allowEmpty?: boolean, emptyElement?: IComboBoxElement): IResetedElement;
        /**
         * Возвращает элемент по умолчанию для сброса значения
         * @param elements Список элементов
         * @param allowEmpty Разрешить ли выбирать пустой элемент
         * @param emptyElement Пустой элемент для значения null
         */
        static resetElement(elements: IComboBoxElement[], allowEmpty?: boolean, emptyElement?: IComboBoxElement): IComboBoxElement;
        /**
         * Создаёт пустой элемент для значения null
         * @param defaultTitle Заголовок по умолчанию
         */
        static createEmptyElement: (defaultTitle?: string) => IComboBoxElement;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link ComboBoxTitle} */
    interface IComboBoxTitleProps {
        /** Дополнительный класс */
        className?: string;
        /** Выключен ли комбобокс */
        disabled?: boolean;
        /** Включен ли TabIndex у заголовка */
        tabIndex?: boolean;
        /** Раскрыт ли выпадающий список элементов или нет */
        expanded?: boolean;
        /** При клике на заголовок */
        onClick?: () => void;
        /** При фокусе заголовка */
        onFocus?: (event: React.FocusEvent<any>) => void;
        /** При снятии фокуса у заголовка */
        onBlur?: (event: React.FocusEvent<any>) => void;
    }
    /**
     * @internal Заголовок комбобокса.
     * Пример использования см. в {@link ComboBoxWrapper}
     */
    class ComboBoxTitle extends React.Component<IComboBoxTitleProps, undefined> {
        el: HTMLAnchorElement;
        /**
         * При клике на заголовок
         */
        protected onClick: () => void;
        protected onKeyDown: (e: React.KeyboardEvent<any>) => void;
        /** @internal */
        readonly tabIndex: number;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link ComboBoxWrapper} */
    interface IComboBoxWrapperProps {
        /** Дополнительный класс */
        className?: string;
        /** Выключен ли комбобокс */
        disabled?: boolean;
    }
    /**
     * @review
     * Обёртка для комбобокса (для комбобоксов существует готовая реализация для общих случаев - {@link CommonComboBox}).
     *
     * Пример использования:
     *
     *     constructor() {
     *         this.defaultTitle = 'Выберите элемент';
     *         this.el = null;
     *         this.emptyElement = {id: null, title: this.defaultTitle};
     *         this.focusedElement = null;
     *
     *         this.state.disabled = false;
     *         this.state.expanded = false;
     *         this.state.selectedElement = '2222';
     *         this.state.emptyAllowed = true;
     *         this.state.elements = [{id: '1111', title: 'Один'}, {id: '2222', title: 'Два'}];
     *     }
     *
     *
     *     protected onFocusElement = (element) => this.focusedElement = element;
     *
     *     protected onBlurElement = (element) => (this.focusedElement && this.focusedElement.id == element.id) && (this.focusedElement = null);
     *
     *     // навигация по стрелочкам
     *     protected onFocusSiblingElement = (element, mode: 'prev' | 'next') => {
     *         let elementPosition = this.state.elements.findIndex(el => el.id == element.id);
     *         if (elementPosition == -1 && !(this.state.emptyAllowed && element.id == null)) {
     *             return;
     *         }
     *
     *         elementPosition += (mode == 'prev') ? -1 : 1;
     *
     *         const siblingElement = (this.state.emptyAllowed && elementPosition == -1) ?
     *             this.emptyElement :
     *             this.state.elements[elementPosition];
     *
     *         if (siblingElement && (!this.focusedElement || this.focusedElement.id != siblingElement.id)) {
     *             this.focusedElement = siblingElement;
     *             this.forceUpdate();
     *         }
     *     }
     *
     *     render() {
     *         const title = <ComboBoxTitle disabled={this.state.disabled}
     *             expanded={this.state.expanded}
     *             tabIndex
     *             onClick={() => this.setState(prevState => ({ expanded: !prevState.expanded }))}>
     *             <ComboBoxTitleContent>
     *                 {this.state.elements[this.state.selectedElement] ? this.state.elements[this.state.selectedElement].title : this.defaultTitle}
     *             </ComboBoxTitleContent>
     *         </ComboBoxTitle>;
     *
     *         const body = <ComboBoxBody disabled={this.state.disabled}
     *             expanded={this.state.expanded}
     *             onClose={() => this.setState({ expanded: false })}
     *             boundaryTarget={this.el}>
     *             <Focusable selectorToFocus='.combobox-element-helper-selected'>
     *                 <ComboBoxBodyContent>
     *                     {this.state.emptyAllowed && <ComboBoxElement tabIndex
     *                         selected={this.state.selectedElement == null}
     *                         focused={this.focusedElement && this.focusedElement.id == null}
     *                         onSelect={() => this.setState({ selectedElement: null, expanded: false })}
     *                         onFocus={() => this.onFocusElement(this.emptyElement)}
     *                         onBlur={() => this.onBlurElement(this.emptyElement)}
     *                         onFocusNext={() => this.onFocusSiblingElement(this.emptyElement, 'next')}
     *                         onFocusPrev={() => this.onFocusSiblingElement(this.emptyElement, 'prev')}>
     *                             <ComboBoxElementContent>{this.defaultTitle}</ComboBoxElementContent>
     *                     </ComboBoxElement>}
     *
     *                     {this.state.elements.map((element) => {
     *                         return <ComboBoxElement key={element.id}
     *                             tabIndex
     *                             selected={element.id == this.state.selectedElement}
     *                             focused={this.focusedElement && this.focusedElement.id == element.id}
     *                             onSelect={() => this.setState({ selectedElement: element.id, expanded: false })}
     *                             onFocus={() => this.onFocusElement(element)}
     *                             onBlur={() => this.onBlurElement(element)}
     *                             onFocusNext={() => this.onFocusSiblingElement(element, 'next')}
     *                             onFocusPrev={() => this.onFocusSiblingElement(element, 'prev')}>
     *                                 <ComboBoxElementContent>{element.title}</ComboBoxElementContent>
     *                         </ComboBoxElement>;
     *                     })}
     *                 </ComboBoxBodyContent>
     *             </Focusable>
     *         </ComboBoxBody>;
     *
     *         return <div ref={el => this.el = el}>
     *             <ComboBoxWrapper disabled={this.state.disabled}>
     *                 <ComboBoxWrapperContent title={title} body={body}>
     *             </ComboBoxWrapper>
     *         </div>
     *     }
     *
     */
    class ComboBoxWrapper extends React.Component<IComboBoxWrapperProps, undefined> {
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link CommonComboBox}  */
    interface ICommonComboBoxProps {
        /** Список элементов (вариантов выбора в выпадающем списке) */
        elements: IComboBoxElement[];
        /** ИД выбранного элемента */
        selectedID?: string;
        /** Заголовок по умолчанию */
        defaultTitle?: string;
        /** Разрешить ли выбирать пустой элемент */
        allowEmpty?: boolean;
        strictMode?: boolean;
        /** Выключен ли комбобокс */
        disabled?: boolean;
        /** Раскрыто ли выпадающее меню по умолчанию */
        expanded?: boolean;
        /** Включен ли TabIndex у комбобокса */
        tabIndex?: boolean;
        /** Дополнительный класс */
        className?: string;
        /** При выборе нового элемента */
        onChange?: (element: IComboBoxElement) => void;
        /** Пользователская функция, позволяющая отрендерить обёртку */
        renderWrapper?: (title: React.ReactNode, body: React.ReactNode) => React.ReactNode;
        /** Пользователская функция, позволяющая отрендерить заголовок */
        renderTitle?: (element: IComboBoxElement) => React.ReactNode;
        /** Пользователская функция, позволяющая отрендерить список элементов */
        renderElementList?: (elements: React.ReactNode[]) => React.ReactNode | React.ReactNode[];
        /** Пользователская функция, позволяющая отрендерить элемент списка */
        renderElement?: (element: IComboBoxElement, selected: boolean) => React.ReactNode;
    }
    /** @internal */
    interface ICommonComboBoxState {
        /** Раскрыт ли выпадающий список элементов или нет */
        expanded: boolean;
    }
    /**
     * @review Хелпер для создания комбобокса (позволяет выбирать значение из выпадающего списка)
     *
     * Пример использования:
     *
     *     constructor() {
     *         this.state.elements = [
     *             { id: '1', title: 'Первый элемент' },
     *             { id: '2', title: 'Второй элемент' },
     *             { id: '3', title: 'Третий элемент', disabled: true },
     *             { id: '4', title: 'Четвёртый элемент' }
     *         ];
     *         this.state.selectedID = '2';
     *     }
     *
     *     render() {
     *         return <CommonComboBox elements={this.state.elements}
     *             allowEmpty={true}
     *             tabIndex
     *             selectedID={this.state.selectedID}
     *             defaultTitle="Выберите элемент из списка"
     *             onChange={(selectedElement: IComboBoxElement) => {
     *                 this.setState({ selectedID: selectedElement.id });
     *             }} />
     *     }
     *
     */
    class CommonComboBox extends React.Component<ICommonComboBoxProps, ICommonComboBoxState> {
        /**
         * Корневой узел combobox
         */
        el: HTMLElement;
        /**
         * Текущий сфокусированный элемент списка
         */
        focusedElement: IComboBoxElement;
        constructor(props: ICommonComboBoxProps);
        /** @internal */
        componentWillMount(): void;
        /** @internal */
        componentWillReceiveProps(nextProps: ICommonComboBoxProps): void;
        /**
         * При выборе элемента в выпадающем списке
         * @param selectedID ИД выбранного элемента
         */
        protected onElementSelected: (selectedID: string) => void;
        /**
         * Ищет элемент списка по его ИД
         * @param id ИД элемента
         * @param disableFallbackToEmptyElement Не создавать пустой элемент, если элемент не найден по ИД
         * @param props Пользовательские props
         */
        protected getElementByID: (id: string, disableFallbackToEmptyElement?: boolean, props?: ICommonComboBoxProps) => IComboBoxElement;
        /**
         * При фокусе элемента списка
         * @param element Текущий элемент
         */
        protected onFocusElement: (element: IComboBoxElement) => IComboBoxElement;
        /**
         * При снятии фокуса у элемента списка
         * @param element Текущий элемент
         */
        protected onBlurElement: (element: IComboBoxElement) => any;
        /**
         * При фокусе соседнего элемента в списке (навигация по стрелочкам)
         * @param element Текущий элемент
         * @param mode Какой из соседних элементов должен получить фокус (предыдущий или следующий)
         */
        protected onFocusSiblingElement: (element: IComboBoxElement, mode: "next" | "prev") => void;
        /**
         * Создаёт список элементов
         */
        protected createElementList(): React.ReactNode[];
        /**
         * Рендерит заголовок комбобокса
         */
        protected renderTitle(): JSX.Element;
        /**
         * Рендерит тело комбобокса
         */
        protected renderBody(): JSX.Element;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Представляет собой список элементов, которые могут схлопываться/раскрываться с использованием анимации.
      * Внутренние элементы должны использовать компонент CommandBarItem.
      *
      * Пример использования:
      *
      *     <CommandBar expanded={this.state.commandBarExpanded} >
      *         <CommandBarItem onClick={() => console.info("Command 1 clicked") } >
      *             Комманда 1
      *         </CommandBarItem>
      *         <CommandBarItem onClick={() => console.info("Command 2 clicked")} >
      *             Комманда 2
      *         </CommandBarItem>
      *     </CommandBar>
      *
      * См. также: {@link CommandBarButton}
      */
    class CommandBar extends React.Component<ICommandBarProps, ICommandBarState> {
        protected prevWidth: number;
        constructor(props: ICommandBarProps);
        /** @internal */
        componentDidMount(): void;
        /** @internal */
        componentDidUpdate(): void;
        /** @internal */
        componentWillReceiveProps(nextProps: ICommandBarProps, nextContext: any): void;
        protected initializeExpanded: () => void;
        protected getStyle(props?: ICommandBarProps): any;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link CommandBarItem} */
    interface ICommandBarItemProps {
        /** Tooltip of the command */
        title?: string;
        /** React.ReactNode that repersents command look */
        children?: React.ReactNode;
        /** Command action */
        onClick(event: React.MouseEvent<any>): void;
        /** Class "hide" will be added to command if visible = false */
        visible?: boolean;
        /** ReactJS key */
        key: string;
        /** Value of attribute data-button-name for autotesting purposes */
        name?: string;
    }
    /** @internal Элемент {@link CommandBar} */
    const CommandBarItem: (props: ICommandBarItemProps) => JSX.Element;
}
declare namespace WebClient {
    /** @review Свойства для {@link CommandBar}  */
    interface ICommandBarProps {
        /** Initial value (after control loaded) should be undefined,
          * then it should change to "true", then to "false" and etc.
          * If your control do not follow this convention correct animations are not guarantee.
          */
        expanded: boolean;
        /** Children tags, created by CommandBarItem */
        children?: React.ReactNode;
        /** Additional class */
        className?: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICommandBarState {
        expandInProgress: boolean;
    }
}
declare namespace WebClient {
    /**
     * @review Компонент для рендеринга контролов разметок. Например, при получении данных контрола с сервера при загрузке разметки.
     *
     * Пример использования:
     *
     *     render() {
     *         var componentInfo = getComponentInfo();
     *
     *         return <ControlSelector
     *             properties={componentInfo.properties}
     *             children={componentInfo.children}
     *             controlTypeName={componentInfo.controlTypeName}
     *             key={componentInfo.properties.name} />
     *     }
     *
     */
    class ControlSelector extends React.Component<IControlSelectorProps, any> {
        constructor(props: IControlSelectorProps);
        /** @internal */
        componentWillMount(): void;
        /** @internal */
        componentWillReceiveProps?(nextProps: IControlSelectorProps, nextContext: any): void;
        /** См. [документацию React](https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle) */
        componentDidCatch(error: any, info: any): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link ControlSelector}  */
    interface IControlSelectorProps {
        properties: any;
        children: IControlSelectorProps[];
        controlTypeName: string;
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link ControlSelector}  */
    interface IExtendedControlSelectorProps extends IControlSelectorProps {
        operations: IEditOperation[];
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeLevelIndent} */
    interface ICustomTreeLevelIndentProps {
        /** Уровень вложенности, на котором находится узел (начинается с 0) */
        level?: number;
        /** Размер отступа для уровня вложенности (px, em, etc) */
        levelIndent?: string;
    }
    /**
     * Отступ у узла дерева. Пример использования см. в {@link CustomTreeDefault}
     */
    class CustomTreeLevelIndent extends React.Component<ICustomTreeLevelIndentProps, undefined> {
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNode}  */
    interface ICustomTreeNodeProps {
        /** Включен ли TabIndex у узла элемента */
        tabIndex?: boolean;
        /** Выключен ли узел */
        disabled?: boolean;
        /** Уровень вложенности, на котором находится узел (начинается с 0) */
        level?: number;
        /** Размер отступа для уровня вложенности (px, em, etc) */
        levelIndent?: string;
        /** При клике на узел */
        onClick?: () => void;
        /** Содержимое */
        children?: React.ReactNode;
    }
    /**
     * Узел дерева. Пример использования см. в {@link CustomTreeDefault}
     */
    class CustomTreeNode extends React.Component<ICustomTreeNodeProps, undefined> {
        protected onClick: () => void;
        readonly tabIndex: number;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link DisclosureHead}  */
    interface IDisclosureProps {
        header: string;
        expanded: boolean;
        onClick(event: React.MouseEvent<any> | React.KeyboardEvent<any>): void;
        visible?: boolean;
        collapsible?: boolean;
        children?: any;
        style?: React.CSSProperties;
        className?: string;
    }
    /** @review Представляет заголовок сворачиваемое области. См. также {@link DisclosureBody}. */
    const DisclosureHead: (props: IDisclosureProps) => JSX.Element;
}
declare namespace WebClient {
    /**
     * @review Реализация {@link IAccessor} через обращение к свойству объекта по имени. Имя задается в конструкторе, при создании акссессора.
     */
    class FieldNameAccessor<NodeT, ValueT> implements IAccessor<NodeT, ValueT> {
        /**
         * Название свойства.
         */
        fieldName: string;
        /**
         * @param key Имя свойства. Может быть задано строкой (например, `myProperty`) или выржанием вида `() => obj.myProperty`.
         */
        constructor(key: FieldSpec<NodeT, ValueT>);
        /**
         * Получить значение свойства для указанного объекта.
         * @param node Объект.
         */
        get(node: NodeT): ValueT;
        /**
         * Установить значение свойства для указанного объекта.
         * @param node Объект.
         * @param value Значение.
         */
        set(node: NodeT, value: ValueT): void;
    }
}
declare namespace WebClient {
    /**
     * @review Реализация {@link IAccessor}, осуществляющая обращение к свойству через заданные функции.
     */
    class FuncAccessor<NodeT, ValueT> implements IAccessor<NodeT, ValueT> {
        private getter;
        private setter;
        /**
         * @param getter Функция, возвращающая значение свойства для указанного объекта.
         * @param setter Функция, устанавливающая значение свойства для указанного объекта.
         */
        constructor(getter: (node: NodeT) => ValueT, setter: (node: NodeT, value: ValueT) => void);
        /**
         * Получить значение свойства для указанного объекта.
         * @param node Объект.
         */
        get(node: NodeT): ValueT;
        /**
         * Установить значение свойства для указанного объекта.
         * @param node Объект.
         * @param value Значение.
         */
        set(node: NodeT, value: ValueT): void;
    }
}
declare namespace WebClient {
    /**
     * @review Представляет инструмент, при помощи которого можно обращаться к некоторому свойству объекта.
     *
     * Акссессоры удобны для реализации универсальных вспомогательных классов, таких как {@link RecursiveVisitor}.
     * То есть, в тех случаях, когда необходимо обращаться к свойству объекта,
     * но имя этого свойства не известно и зависит от контекста использования.
     *
     * @param NodeT Тип объектов, к которым планируется обращаться.
     * @param ValueT Тип значения свойства, к которому планируется обращаться.
     *
     * См. конкретные реализации: {@link FieldNameAccessor}, {@link FuncAccessor}, {@link MapMetaStore}.
     */
    interface IAccessor<NodeT, ValueT> extends IReadonlyAccessor<NodeT, ValueT> {
        /**
         * Получить значение свойства для указанного объекта.
         * @param node Объект.
         */
        get(node: NodeT): ValueT;
        /**
         * Установить значение свойства для указанного объекта.
         * @param node Объект.
         * @param value Значение.
         */
        set(node: NodeT, value: ValueT): void;
    }
}
declare namespace WebClient {
    /** @review Версия {@link IAccessor} с доступом только на чтение. */
    interface IReadonlyAccessor<NodeT, ValueT> {
        /**
         * Получить значение свойства для указанного объекта.
         * @param node Объект.
         */
        get(node: NodeT): ValueT;
    }
}
declare namespace WebClient {
    /**
    * @review Реализация {@link IAccessor}, которая хранит значение свойства во внурреннем объекте по строковому ключу.
    * Значение ключа получается через специальную функцию, передаваемую в конструкторе.
    */
    class MapMetaStore<NodeT, ValueT> implements IAccessor<NodeT, ValueT> {
        getId: (node: NodeT) => string;
        private store;
        /**
         * @param getId Функция, возвращающая уникальный ключ для указанного объекта.
         */
        constructor(getId: (node: NodeT) => string);
        /**
         * Получить значение свойства для указанного объекта.
         * @param node Объект.
         */
        get(node: NodeT): ValueT;
        /**
         * Установить значение свойства для указанного объекта.
         * @param node Объект.
         * @param value Значение.
         */
        set(node: NodeT, value: ValueT): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class TreeBase<TreeNodeDataT extends ITreeNodeData, TProps extends ITreeBaseProps<TreeNodeDataT>, TState extends ITreeBaseState> extends React.Component<TProps, TState> {
        nodeExpandedEvent: SimpleEvent<TreeNode>;
        nodeCollapsedEvent: SimpleEvent<TreeNode>;
        nodeSelectedEvent: SimpleEvent<TreeNode>;
        state: TState;
        constructor(props: TProps);
        componentDidMount(): void;
        setNewNodes(nodes: TreeNode[]): void;
        setNodes(nodesData: TreeNodeDataT[], parentNode?: TreeNode): void;
        addNodes(nodesData: TreeNodeDataT[], parentNode?: TreeNode): void;
        selectNode(node: TreeNode, resetOthers?: boolean): void;
        toggleNode(node: TreeNode, expand: boolean, raiseEvent?: boolean): void;
        clearSelection(): void;
        readonly nodes: TreeNode[];
        readonly selectedNodes: TreeNode[];
        readonly selectedNode: TreeNode;
        readonly nodeSelected: SimpleEvent<TreeNode>;
        readonly nodeExpanded: SimpleEvent<TreeNode>;
        readonly nodeCollapsed: SimpleEvent<TreeNode>;
        findNode(predicat: (node: TreeNode) => boolean): TreeNode;
        findNodes(predicat: (node: TreeNode) => boolean): TreeNode[];
        focusFirstNode(): void;
        protected findAllNodes(predicat: (node: TreeNode) => boolean, currentNodes: TreeNode[], result: TreeNode[]): void;
        protected onNodeSelected(node: TreeNode): void;
        protected onNodeAccepted(node: TreeNode): void;
        protected onNodeExpanded(node: TreeNode): void;
        protected onNodeCollapsed(node: TreeNode): void;
        protected readonly levelIdent: string;
        protected readonly expandedToggleMarkerClass: string;
        protected readonly collapsedToggleMarkerClass: string;
        protected readonly multiSelect: boolean;
        protected isNodeSelected(node: TreeNode): boolean;
        protected loadData(data: ITreeNodeData[], level: number, parent: TreeNode): TreeNode[];
        protected createNode(data: ITreeNodeData, level: number, parent: TreeNode, children?: TreeNode[]): TreeNode;
        protected onToggleClick(node: TreeNode, event: React.SyntheticEvent<any>): void;
        protected onNodeClick(node: TreeNode, event: React.MouseEvent<any>): void;
        protected onNodeDoubleClick(node: TreeNode, event: React.MouseEvent<any>): void;
        componentWillReceiveProps(nextProps: ITreeBaseProps<TreeNodeDataT>, nextContext: any): void;
        protected calcTree(): void;
        protected calcTreeItem(node: TreeNode): number;
        protected getNode(index: any, nodes: TreeNode[]): TreeNode;
        protected onNodeBlur(node: TreeNode): void;
        protected onNodeFocus(node: TreeNode): void;
        protected onNodeKeyDown(node: TreeNode, index: number, ev: React.KeyboardEvent<any>): void;
        protected renderToggleMarker(node: TreeNode): JSX.Element;
        protected renderNode(index: any, key: any): JSX.Element;
        getVirtualizationType(): string;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IDynamicTreeProps extends ITreeBaseProps<IDynamicTreeNodeData> {
        /** If parentNode specified, shoudl load child nodes, else root nodes */
        loadNodes: (parentNode?: ITreeNodeData) => JQueryDeferred<IDynamicTreeNodeData[]>;
        className?: string;
        expandedByDefault?: boolean;
    }
    /** @internal */
    interface IDynamicTreeState extends ITreeBaseState {
        tree?: Tree;
        rootLoading?: LoadingState;
    }
    /** @internal */
    class DynamicTree extends TreeBase<IDynamicTreeNodeData, IDynamicTreeProps, IDynamicTreeState> {
        constructor(props: IDynamicTreeProps);
        componentDidMount(): void;
        toggleNode(node: TreeNode, expand: boolean, raiseEvent?: boolean): void;
        protected createNode(data: ITreeNodeData, level: number, parent: TreeNode, children?: TreeNode[]): DynamicTreeNode;
        protected renderToggleMarker(node: TreeNode): JSX.Element;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class TreeNode {
        constructor(data: ITreeNodeData, level: number, parent: TreeNode, children?: TreeNode[]);
        visibleItemsCount: number;
        children: TreeNode[];
        data: ITreeNodeData;
        level: number;
        expanded: boolean;
        htmlEement: HTMLElement;
        parent: TreeNode;
        readonly displayName: React.ReactNode;
        readonly title: string;
        readonly uniqueId: string;
        readonly iconClass: string;
        readonly nodeClass: string;
        readonly disabled: boolean;
        readonly expandedByDefault: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class DynamicTreeNode extends TreeNode {
        loading: LoadingState;
        constructor(data: IDynamicTreeNodeData, level: number, parent: TreeNode, children?: TreeNode[]);
        readonly dynamicChildren: DynamicTreeNode[];
        childrenLoaded: boolean;
        readonly iconClass: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IDynamicTreeNodeData extends ITreeNodeData {
        childrenLoaded: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILoadNodesResult {
        nodes: ITreeNodeData[];
        /** How deep children was loaded. 1 - only nodes, 2 - nodes and its children, etc. */
        treeLevelDown: number;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link FileComment} */
    interface IFileCommentProps {
        /** Идентификатор комментария. */
        id: string;
        /** Автор комментария. */
        author: string;
        /** Дата комментария. */
        date: string;
        /** Текст комментария. */
        comment: string;
        /** Можно ли изменять комментарий. */
        canEdit?: boolean;
        /** Можно ли удалять комментарий. */
        canDelete?: boolean;
        /** При вызова изменения комментария. */
        onEdit?: () => void;
        /** При вызова удаления комментария. */
        onDelete?: () => void;
    }
    /**
     * Отображает содержимое комментария.
     */
    const FileComment: (props: IFileCommentProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal Свойства для {@link FileComments} */
    interface IFileCommentsProps {
        /** Идентификатор карточки файла. */
        fileCardId: string;
        /** Идентификатор версии файла */
        versionId: string;
        /** Можно ли создать новый комментарий. */
        canCreateComment?: () => boolean;
        /** Можно ли изменить последний комментарий. */
        canEditLastComment?: () => boolean;
        /** Можно ли удалить последний комментарий. */
        canDeleteLastComment?: () => boolean;
        /** Заголовок блока с комментариями. */
        title?: string;
        /** Своя функция отрисовки. */
        customRender?: (component: FileComments) => React.ReactNode;
        /** Перед добавлением комментария. */
        onAdding?: (commentText: string) => JQueryDeferred<any>;
        /** После добавления комментария. */
        onAdded?: (commentText: string) => void;
        /** Перед изменением комментария. */
        onEditing?: (commentId: string, commentText: string) => JQueryDeferred<any>;
        /** После изменения комментария. */
        onEdited?: (commentId: string, commentText: string) => void;
        /** Перед удалением комментария. */
        onDeleting?: (commentId: string) => JQueryDeferred<any>;
        /** После удаления комментария. */
        onDeleted?: (commentId: string) => void;
        services: $LayoutFileController;
        /** После любого изменения комментариев */
        onChaged?: (comments: GenModels.VersionedFileCommentModel[]) => void;
    }
    /** @internal */
    interface IFileCommentsState {
        /** Название файла. */
        fileName: string;
        /** Автор файла. */
        fileAuthor: string;
        /** Дата создания файла. */
        fileCreationDate: string;
        /** Версия файла. */
        version: string;
        /** Timestamp карточки файла. */
        timestamp?: number;
        /** Список комментариев. */
        comments: GenModels.VersionedFileCommentModel[];
        /** Содержимое поля ввода комментария. */
        commentInputText: string;
        /** Было ли изменено поле комментария после последней отправки. */
        isCommentInputDirty: boolean;
        /** Находилось ли поле комментария в фокусе хотя бы один раз после последнего сохранения/отмены комментария. */
        wasCommentInputFocused: boolean;
        /** Если указан, то в форме с комментарием мы редактируем существующий комментарий. Иначе - создаём новый. */
        editCommentId: string;
        /** Загружаются ли в данный момент данные для предпросмотра файла. */
        isLoading: boolean;
        /** Помощник для загрузки данных о списке комментариев. */
        loadingHelper: RequestHelper;
        deleteRequestHelper: RequestHelper;
    }
    class FileComments extends React.Component<IFileCommentsProps, IFileCommentsState> {
        protected commentsContainer: HTMLElement;
        protected commentInput: HTMLTextAreaElement;
        constructor(props: IFileCommentsProps);
        /** @internal */
        componentWillMount(): void;
        /** Устанавливает новое значение комментария. */
        setCommentInputText: (newText: string, options?: {
            trim?: boolean;
            notSetDirty?: boolean;
        }) => void;
        getFilteredCommentInputText: () => string;
        /** Загружаются ли комментарии в данный момент */
        readonly isLoading: boolean;
        protected availableBuiltIn(id: string): boolean;
        /** Можно ли создать новый комментарий. */
        protected canCreateComment(): boolean;
        /** Можно ли изменить последний комментарий. */
        protected canEditLastComment(): boolean;
        /** Можно ли удалить последний комментарий. */
        protected canDeleteLastComment(): boolean;
        /** Загрузить список комментариев. */
        protected load: () => JQueryDeferred<GenModels.VersionedFileCommentModel[]>;
        /** При изменении поля ввода комментария. */
        protected onCommentInputChange: (event: React.FormEvent<any>) => void;
        /** При фокусе поля ввода комментария. */
        protected onCommentInputFocus: (event: React.FocusEvent<any>) => void;
        /** При создании/изменении комментария. */
        protected onApplyComment: (event: React.FocusEvent<any>) => void;
        /** При изменении комментария. */
        protected onEditCommentButtonPress: (comment: GenModels.VersionedFileCommentModel) => void;
        /** Очищает поле для комментария. */
        protected clearCommentInput: () => void;
        /** При удалении комментария. */
        protected onDeleteComment: (comment: GenModels.VersionedFileCommentModel) => void;
        /** @internal Отрисовка заголовка блока с комментариями. */
        renderHeader(): JSX.Element;
        /** @internal Отрисовка блока с комментариями. */
        renderComments(): JSX.Element;
        /** @internal Отрисовка формы для создания/изменения комментария. */
        renderForm(): JSX.Element;
        /** @internal */
        render(): {};
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link FileCommentsModal} */
    interface IFileCommentsModalProps extends IFileCommentsProps {
        /** Вызывается при закрытии FileCommentsModal. */
        onClose?: () => void;
        services: $LayoutFileController;
    }
    /** @internal */
    interface IFileCommentsModalState {
        /** Показывается ли модальное окно. */
        isOpened: boolean;
    }
    /**
     * Модальное окно со списком комментариев.
     */
    class FileCommentsModal extends React.Component<IFileCommentsModalProps, IFileCommentsModalState> {
        constructor(props: IFileCommentsModalProps);
        /** Закрытие модального окна. */
        protected closeModal: () => void;
        /** Отрисовка блока с комментариями. */
        protected renderCommentsBody: (component: FileComments) => JSX.Element;
        /** Отрисовка информации о комментируемом файле. */
        protected renderFileInfo(component: FileComments): JSX.Element;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link FilePreview} */
    interface IFilePreviewProps {
        /** Идентификатор файла. */
        fileId: string;
        /** Идентификатор карточки файла. */
        fileCardId: string;
        ownerCardId?: string;
        /** Идентификатор версии файла */
        versionId: string;
        /** Текущий номер страницы (начинается с 1, по умолчанию - 1). */
        currentPage?: number;
        /** Уникальный идентификатор превью файла, нужный, если между открытиями одного и того же превью оно может поменяться, а браузер его кэширует. */
        fileCacheId?: string;
        /** Вызывается при закрытии FilePreview. */
        onClose?: () => void;
        /** Показывать ли комментарии */
        showComments?: boolean;
        /** Можно ли создать новый комментарий. */
        canCreateComment?: () => boolean;
        /** Можно ли изменить последний комментарий. */
        canEditLastComment?: () => boolean;
        /** Можно ли удалить последний комментарий. */
        canDeleteLastComment?: () => boolean;
        services: $FileController & $LayoutFileController;
    }
    /** @internal */
    interface IFilePreviewState {
        /** Информацию о файле и его превью. */
        preview: IFilePreviewModel;
        /** Содержит ли поле ввода страницу ошибку. */
        isPageInputError: boolean;
        /** Редактируется ли поле ввода страницы в данный момент. */
        isEditingPageInput: boolean;
        isEditingTop: boolean;
        /** Загружаются ли в данный момент данные для предпросмотра файла. */
        isLoading: boolean;
        /** Включено ли масштабирование. */
        isScaling: boolean;
        /** Текущий номер страницы (начинается с 1). */
        currentPage: number;
        pageInputValue: string;
        pageInput: HTMLInputElement;
    }
    class FilePreview extends React.Component<IFilePreviewProps, IFilePreviewState> {
        constructor(props: IFilePreviewProps);
        /** @internal */
        componentWillReceiveProps(nextProps: IFilePreviewProps): void;
        /** @internal */
        componentWillMount(): void;
        /**
         * Закрузить данные о файле для нужной страницы.
         * @param page Номер загружаемой страницы
         */
        protected load(page: number): JQueryDeferred<IFilePreviewModel>;
        /** При закрытии FilePreview. */
        protected onClose: () => void;
        /** URL изображения для текущей страницы. */
        protected getCurrentImageUrl: () => string;
        /** URL для скачивания файла. */
        protected getDownloadFileUrl: () => string;
        /** Перейти на первую страницу. */
        protected goToFirstPage: () => void;
        /** Перейти на последнюю страницу. */
        protected goToLastPage: () => void;
        /** Перейти на предыдущую страницу. */
        protected goToPrevPage: () => void;
        /** Перейти на следующую страницу. */
        protected goToNextPage: () => void;
        /**
         * Перейти на указанную страницу.
         * @param pageNumber Номер страницы для перехода
         */
        protected goToPage: (pageNumber: number) => void;
        /**
         * Можно ли перейти на указанную страницу.
         * @param pageNumber Номер страницы для перехода
         */
        protected canGoToPage: (pageNumber: number) => boolean;
        /**
         * Проверка на ввод только целочисленного номера страницы
         * @param event Событие клавиатуры
         */
        protected onPageInputKeyDown: (event: React.KeyboardEvent<any>) => void;
        /**
         * При изменении текущего номера страницы в текстовом поле ввода элемента управления
         * @param event Событие изменения
         */
        protected onPageInputChange: (event: React.FormEvent<any>) => void;
        /**
         * При потери фокуса элементом управления.
         * @param event Событие изменения фокуса
         */
        protected onPageInputBlur: (event: React.FocusEvent<any>) => void;
        /** Переключение режима масштабирования. */
        protected toggleScaleMode: () => void;
        protected selectInput: (input: HTMLInputElement) => void;
        /** Отрисовка заголовка предпросмотра файла. */
        protected renderHeader(): JSX.Element;
        /** Отрисовка элементов управления (навигация по страницам, скачивания и т.д.). */
        protected renderControls(top: boolean): JSX.Element;
        /** Отрисовка блока с комментариями. */
        protected renderComments(): JSX.Element;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Режим {@link Focusable} */
    interface IFocusableMode {
        /** Фокусировать ли при создании компонента */
        onMount?: boolean;
        /** Фокусировать ли при перерисовке компонента */
        onUpdate?: boolean;
    }
    /** @internal Свойства для {@link Focusable} */
    interface IFocusableProps {
        /** CSS-селектор элемента среди props.children, на котором нужно делать фокус. Если не задан, то ищется первый фокусируемый элемент */
        selectorToFocus?: string;
        /** CSS-селектор элемента, которому нужно вернуть фокус. Если не задан, то запоминается предыдущий фокус */
        selectorToReturnFocus?: string;
        /** Режим фокусирования */
        mode?: IFocusableMode;
        /** Не фокусировать */
        notFocusOnMount?: boolean;
        /** Выключен ли фокус */
        disabled?: boolean;
        /** Элементы, среди которых ищутся фокусируемые */
        children?: React.ReactNode;
        onFocus?: () => void;
    }
    /**
     * @internal Помогает с автоматической фокусировкой на своём содержимом
     * Ищет среди своих потомков фокусируемый элемент и передаёт фокус ему, запоминая прошлый сфокусированный элемент.
     *
     * Фокусирование внутреннего элемента происходит при создании компонента (при условии, что компонент виден на странице)
     * или при становлении его видимым (через css)
     * Возвращение фокуса происходит при уничтожении компонента или изменении его видимости на "невидимый" (пр. "display: none" в css)
     *
     * Пример использования:
     *
     *     <Focusable>
     *         <div tabindex={0}>Содержимое</div>
     *     </Focusable>
     */
    class Focusable extends React.Component<IFocusableProps, undefined> {
        /** Узел Focusable */
        el: HTMLElement;
        /** Элемент, имевший фокус до Focusable */
        prevFocusable: HTMLElement;
        /** Был ли виден Focusable в пердыдущем рендеринге */
        prevIsVisible: boolean;
        /** Был ли проинициализирован Focusable */
        isInitialFocused: boolean;
        /** Режим Focusable по умолчанию */
        static readonly DEFAULT_MODE: IFocusableMode;
        /** @internal */
        componentDidMount(): void;
        /** @internal */
        componentWillUnmount(): void;
        /** @internal */
        componentDidUpdate(): void;
        /** @internal */
        componentWillReceiveProps(nextProps: IFocusableProps): void;
        /**
         * Виден ли Focusable на странице
         */
        readonly isVisible: boolean;
        /**
         * Режим Focusable
         */
        readonly mode: IFocusableMode;
        /**
         * Ищет внутри себя элемент для передачи фокуса
         */
        protected findFocusable(): HTMLElement;
        /**
         * Находит текущий элемент с фокусом (нужно для возврата фокуса)
         */
        protected findCurrentFocusableElement(): HTMLElement;
        /**
         * Передать фокус элементу внутри
         */
        protected focus(force?: boolean): void;
        /**
         * Вернуть фокус исходному элементу
         */
        protected returnFocus(skipVisibleCheck?: boolean): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link FocusTrap} */
    interface IFocusTrapProps {
        /** Выключено ли отлавливание фокуса. */
        disabled?: boolean;
        /** Селектор родительского контейнера (будет использоваться в .closest()) */
        containerSelector?: string;
        /** Содержимое компонента. */
        children?: React.ReactNode;
    }
    class FocusTrapImpl {
        /** Узел FocusTrap. */
        protected container: HTMLElement;
        protected reactComponent: React.Component;
        /** Последний сфокусируемый элемент. */
        protected lastFocusedEl: HTMLElement;
        /** Активна ли ловушка */
        protected active: boolean;
        disabled: boolean;
        /** Список ловушек */
        protected static traps: FocusTrapImpl[];
        protected focusCounter: number;
        protected focusCounterResetInterval: any;
        /** @internal */
        initialize(container: HTMLElement, reactComponent: React.Component): void;
        /** @internal */
        deinitialize(): void;
        setDisabled(disabled: boolean): void;
        getDisabled(): boolean;
        /** Активна ли ловушка. */
        protected isActive: () => boolean;
        /** Получить контейнер. */
        protected getContainer: () => HTMLElement;
        /**
         * При смене фокуса повсюду в документе
         * @param e Событие фокуса
         */
        protected onDocumentFocus: (e: FocusEvent) => void;
        /**
         * При щелчке мышкой повсюду в документе
         * @param e Событие мышки
         */
        protected onDocumentClick: (e: MouseEvent) => void;
        /**
         * При нажатии клавиши повсюду в документе
         * @param e Событие клавиатуры
         */
        protected onDocumentKeydown: (e: KeyboardEvent) => void;
        /**
         * Обрабатываем нажатия tab или shift+tab
         * @param e Событие клавиатуры
         */
        protected handleTab: (e: KeyboardEvent) => void;
        /**
         * Фокусируем указанный элемент
         * @param el Элемент, который нужно зафокусить
         */
        protected focusEl: (el: HTMLElement) => void;
        /**
         * Ищет первый или последний фокусируемый элемент
         * @param mode Режим (поиск первого/последнего элемента)
         */
        protected findFocusable(mode: 'first' | 'last'): HTMLElement | null;
        /**
         * Находится ли элемент внутри FocusTrap.
         */
        protected isInnerEl(activeElement: HTMLElement): boolean;
        /**
         * Зафокусирован ли элемент внутри FocusTrap.
         */
        protected isInnerElFocused(activeElement: HTMLElement): boolean;
        protected isAbsoluteOrFixedPositioned(elem: HTMLElement, checkElementInBodyAndNotInContainer?: boolean): boolean;
    }
    /**
 * @internal Помогает с отлавливанием фокуса при попытке покинуть контейнер
 * Пример использования:
 *
 *     <FocusTrap>
 *         <div tabindex={0}>Содержимое</div>
 *     </FocusTrap>
 */
    class FocusTrap extends React.Component<IFocusTrapProps, {}> {
        container: HTMLElement;
        focusTrapImpl: FocusTrapImpl;
        componentDidMount(): void;
        componentWillUnmount(): void;
        componentWillReceiveProps(newProps: IFocusTrapProps): void;
        /** Получить контейнер. */
        protected getContainer: (props?: IFocusTrapProps) => HTMLElement;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Ищет в дереве элемент, который может получить фокус. */
    function findFocusableElement({container, mode, selectorToFocus}: {
        container: HTMLElement;
        mode: 'first' | 'last';
        selectorToFocus?: string;
    }): HTMLElement;
    /** Ищет в дереве элементы, которые могут получить фокус. */
    function findAllFocusableElements(container: HTMLElement): HTMLElement[];
    function isFocusable(el: HTMLElement): boolean;
}
declare namespace WebClient {
    interface IRenderFocusProps {
        focused: boolean;
        /** CSS-селектор элемента среди props.children, на котором нужно делать фокус. Если не задан, то ищется первый фокусируемый элемент */
        selectorToFocus?: string;
    }
    /** После отрисовки передает фокус первому дочернему элементу, который может принять фокус. */
    class RenderFocus extends React.Component<IRenderFocusProps, {}> {
        focusTarget: HTMLElement;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: IRenderFocusProps): void;
        render(): React.ReactNode;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link LoadingIcon} */
    interface ILoadingIconProps {
        state: LoadingState;
        className?: string;
        /** Css class, that adds loading icon as background
          * Default value: dv-ico icon-spin loader-animate
          */
        loadingIconClassName?: string;
        /** Css class, that adds error icon as background
          * Default value: dv-ico ico-approval-decision-cancellation
          */
        errorClassName?: string;
        /** Loading icon color */
        color?: LoadincIconColor;
    }
    /** @internal */
    interface ILoadingIconState {
    }
    /** @internal */
    enum LoadincIconColor {
        Blue = 0,
        White = 1,
        Black = 2,
    }
    /**
     * @internal Показывает иконку загрузки
     *
     * Пример использования:
     *
     *     constructor(props) {
     *         super(props);
     *
     *         this.state.requestHelper = new RequestHelper(() => this.forceUpdate());
     *         this.state.requestHelper.send(() => $.Deferred<{}>().resolve(), () => {
     *             console.log('Результаты загружены.');
     *         });
     *     }
     *
     *     render() {
     *         return <LoadingIcon state={this.state.requestHelper.state} />
     *     }
     *
     */
    class LoadingIcon extends React.Component<ILoadingIconProps, ILoadingIconState> {
        constructor(props: ILoadingIconProps);
        getLoadingIconClass(): string;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IAnimatedItemHideProps {
            level: number;
            children?: any;
        }
        interface IAnimatedItemHideState {
            hide: boolean;
            animatedHide: boolean;
            timeout: number;
        }
        /** @internal */
        class AnimatedItemHide extends React.Component<IAnimatedItemHideProps, IAnimatedItemHideState> {
            constructor(props: IAnimatedItemHideProps);
            componentWillReceiveProps(newProps: IAnimatedItemHideProps): void;
            render(): JSX.Element;
        }
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IBigItemBoxProps {
            children?: any;
        }
        /** @internal */
        const BigItemBox: (props: IBigItemBoxProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IBigSpaceGapProps {
            children?: any;
        }
        /** @internal */
        const BigSpaceGap: (props: IBigSpaceGapProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IItemProps {
            /** Button action */
            onClick: (event: React.MouseEvent<any>) => void;
            children?: any;
        }
        /** @internal Represents a button, that looks like small icon
          * Usage example:
          *  <IconButton name="open-dictionary" onClick={this.onOpenDictionaryClick}
          *      iconClassName="dv-ico dv-ico-dictionary" visible={ super.getEditAvailable()}
          *      title={resources.Numerator_GenerateNewNumberTooltip}  />
          */
        const Item: (props: IItemProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IItemContentProps {
            selected?: boolean;
            children?: any;
        }
        /** @internal */
        const ItemContent: (props: IItemContentProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IItemHideToggleProps {
            toggled: boolean;
            children?: any;
            onChange?: (ev: React.FormEvent<any>) => void;
        }
        /** @internal */
        const ItemHideToggle: (props: IItemHideToggleProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IItemIconProps {
            iconClass: string;
            children?: any;
        }
        /** @internal */
        const ItemIcon: (props: IItemIconProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IItemLevelIdentProps {
            level: number;
            children?: any;
        }
        /** @internal */
        const ItemLevelIdent: (props: IItemLevelIdentProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IItemSeparatorProps {
        }
        /** @internal */
        const ItemSeparator: (props: IItemSeparatorProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface IItemTextProps {
            configuredToHide?: boolean;
            children?: any;
        }
        /** @internal */
        const ItemText: (props: IItemTextProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface INavigationLinkProps {
            /**
             * Значение атрибута href для html-элемента `<a>`.
             * Для указания страницы Web-клиента используйте путь, начинающийся с `#`. Например, `#/Dashboard`.
             */
            href: string;
            /** Значение атрибута hreflang для html-элемента `<a>` */
            hrefLang?: string;
            /** Значение атрибута target для html-элемента `<a>` */
            target?: string;
            /** Значение атрибута accesskey для html-элемента `<a>` */
            accessKey?: string;
            /** Значение атрибута download для html-элемента `<a>` */
            download?: boolean;
            /** Значение атрибута type для html-элемента `<a>` */
            type?: string;
            tabIndex?: number;
            children?: any;
            onClick?: (ev: MouseEvent) => void;
            disabled?: boolean;
            className?: string;
        }
        /** @internal */
        class NavigationLink extends React.Component<INavigationLinkProps, any> {
            lastRouteTimestamp: number;
            static CHANGE_ROUTE_MAX_TIMEOUT: number;
            constructor(props: INavigationLinkProps);
            onNavigationLinkClick: (ev: MouseEvent, force: boolean) => void;
            attachRoot: (elem: HTMLElement) => void;
            render(): JSX.Element;
        }
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        enum OverlapPanelLocation {
            Above = 1,
            Below = 2,
        }
        /** @internal */
        enum OverlapPanelSize {
            Small = 1,
            Big = 2,
        }
        /** @internal */
        enum OverlapPanelSide {
            Left = 1,
            Right = 2,
        }
        /** @internal */
        interface IOverlapPanelProps {
            children?: any;
            location?: OverlapPanelLocation;
            size?: OverlapPanelSize;
            side?: OverlapPanelSide;
        }
        /** @internal */
        const OverlapPanel: (props: IOverlapPanelProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface ISmalltemBoxProps {
            children?: any;
        }
        /** @internal */
        const SmalltemBox: (props: ISmalltemBoxProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace MainMenuHelpers {
        /** @internal */
        interface ISpaceGapProps {
            children?: any;
        }
        /** @internal */
        const SpaceGap: (props: ISpaceGapProps) => JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAdaptiveMenuBarProps {
        expanded: boolean;
        children?: React.ReactNode;
        onClose?: () => void;
    }
    /** @internal */
    interface IAdaptiveMenuBarState {
        parentEl: HTMLElement;
    }
    /**
     * @internal Представляет собой адаптивное меню.
     *
     * Пример использования:
     *
     *     <AdaptiveMenuBar expanded={this.state.menuBarExpanded} >
     *         <AdaptiveMenuContent>
     *             <AdaptiveMenuItem onClick={() => console.info("Command 1 clicked") } >
     *                 Комманда 1
     *             </AdaptiveMenuBarItem>
     *             <AdaptiveMenuBarItem onClick={() => console.info("Command 2 clicked")} >
     *                 Комманда 2
     *             </AdaptiveMenuBarItem>
     *         </AdaptiveMenuContent>
     *     </AdaptiveMenuBar>
     *
     * См. также {@link AdaptiveMenuContent}, {@link AdaptiveMenuBarItem}
     */
    class AdaptiveMenuBar extends React.Component<IAdaptiveMenuBarProps, IAdaptiveMenuBarState> {
        popover: Popover;
        constructor(props: IAdaptiveMenuBarProps);
        onCloseMenu: () => void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAdaptiveMenuItemProps {
        /** Tooltip of the menu item */
        title?: string;
        /** React.ReactNode that repersents menu item look */
        children?: React.ReactNode;
        /** Command action */
        onClick?(): void;
        /** Class "hide" will be added to command if visible = false */
        visible?: boolean;
        /** should add padding to child */
        padding?: boolean;
        /** Name for autotest purposes */
        name: string;
    }
    /**
     * @internal Представляет собой адаптивный элемент для меню {@link AdaptiveMenuBar}.
     * См. также {@link AdaptiveMenuContent}
     */
    const AdaptiveMenuItem: (props: IAdaptiveMenuItemProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IDesktopMenuBarProps {
        expanded: boolean;
        children?: React.ReactNode;
    }
    /**
      * @internal Представляет собой панель с меню для настольной версии.
      */
    const DesktopMenuBar: (props: IDesktopMenuBarProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IDesktopMenuItemProps extends IAdaptiveMenuItemProps {
    }
    /** @internal */
    interface IDesktopMenuItemState {
    }
    /**
      * @internal Представляет собой элемент меню для настольной версии.
      */
    class DesktopMenuItem extends React.Component<IDesktopMenuItemProps, IDesktopMenuItemState> {
        protected onKeyDown: (event: React.KeyboardEvent<any>) => void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * @internal
     * @deprecated
     */
    interface IMenuBarItemProps {
        /** Tooltip of the menu item */
        title?: string;
        /** React.ReactNode that repersents menu item look */
        children?: React.ReactNode;
        /** Command action */
        onClick?(event: React.MouseEvent<any>): void;
        /** Class "hide" will be added to command if visible = false */
        visible?: boolean;
        /** Custom class for menu item */
        className?: string;
        /** ReactJS key */
        key: string;
        /** Name for autotest purposes */
        name: string;
    }
    /**
     * @internal
     * @deprecated
     */
    interface IMenuBarProps {
        expanded: boolean;
        /** Children tags, created by MenuBarItem */
        children?: React.ReactNode;
        className?: string;
    }
    /**
      * @internal
      * @deprecated
      */
    const MenuBar: (props: IMenuBarProps) => JSX.Element;
    /**
     * @internal
     * @deprecated
     */
    const MenuBarItem: (props: IMenuBarItemProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IMobileMenuBarProps {
        expanded: boolean;
        children?: React.ReactNode;
    }
    /**
      * @internal Представляет собой панель с меню для мобильной версии.
      */
    const MobileMenuBar: (props: IMobileMenuBarProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IMobileMenuItemProps extends IAdaptiveMenuItemProps {
    }
    /** @internal */
    interface IMobileMenuItemState {
    }
    /**
      * @internal Представляет собой элемент меню для мобильной версии.
      */
    class MobileMenuItem<P extends IMobileMenuItemProps, S extends IMobileMenuItemState> extends React.Component<P, S> {
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Предоставляет статические методы для отображения простых модальных окон.
     */
    class MessageBox {
        private static mMessageBoxContainerProvider;
        static lastError: HTMLElement;
        static getMessageBoxContainer(): BodyContainerProvider;
        /**
         * Показывает модальное окно с сообщением об ошибке.
         *
         * @param content Текст сообщения обо ошибке
         * @param customCaptionText Заголовок диалога
         * @returns JQueryDeferred объект, который перейдет в состояние "resolved" после закрытия диалога.
         *
         * Пример использования:
         *
         *    MessageBox.ShowError("Неправильное имя файла!").done(() => {
         *        console.info("Диалог закрыт");
         *    });
         *
         */
        static ShowError(content: React.ReactNode, customCaptionText?: React.ReactNode): JQueryDeferred<any>;
        /**
         * Показывает модальное окно с информационным сообщением.
         *
         * @param content Текст сообщения
         * @param customCaptionText Заголовок диалога
         * @returns JQueryDeferred объект, который перейдет в состояние "resolved" после закрытия диалога.
         *
         * Пример использования:
         *
         *    MessageBox.ShowInfo("Операция успешно выполнена!").done(() => {
         *        console.info("Диалог закрыт");
         *    });
         *
         */
        static ShowInfo(content: React.ReactNode, customCaptionText?: React.ReactNode): JQueryDeferred<any>;
        /**
         * Показывает модальное окно с предупреждением.
         *
         * @param content Текст предупреждения
         * @param customCaptionText Заголовок диалога
         * @returns JQueryDeferred объект, который перейдет в состояние "resolved" после закрытия диалога.
         *
         * Пример использования:
         *
         *    MessageBox.ShowWarning("Не все файлы были загружены!").done(() => {
         *        console.info("Диалог закрыт");
         *    });
         *
         */
        static ShowWarning(content: React.ReactNode, customCaptionText?: React.ReactNode): JQueryDeferred<any>;
        /**
         * Показывает модальное окно с запросом подтвердить какое-либо действие.
         *
         * @param content Текст запроса
         * @param customCaptionText Заголовок диалога
         * @returns JQueryDeferred объект, который перейдет в состояние "resolved" при согласии, и "rejected" при отказе.
         *
         * Пример использования:
         *
         *    MessageBox.ShowConfirmation("Вы действительно хотите удалить файл?").done(() => {
         *        this.removeFile();
         *    }).fail(() => {
         *        // Пользователь отменил удаление
         *    });
         *
         */
        static ShowConfirmation(content: React.ReactNode, customCaptionText?: React.ReactNode): JQueryDeferred<any>;
        /**
         * Показывает модальное окно с информацией об исключении
         *
         * @param exception Исключение
         * @returns JQueryDeferred объект, который перейдет в состояние "resolved" при согласии, и "rejected" при отказе.
         *
         * Пример использования:
         *
         *    try {
         *        throw new Error("Произошла неизвестная ошибка");
         *    } catch (e) {
         *        MessageBox.ShowException(e).done(() => {
         *            console.info("Диалог закрыт");
         *        });
         *    }
         * @internal
         */
        private static Show(content, msgType, customCaptionText?);
        private static renderModalHeader(caption, color, iconClass);
    }
}
declare namespace WebClient {
    /** Свойства для {@link ModalDialog} */
    interface IModalDialogProps {
        /** При смене значения на true модальное окно откроется, при смене в false - скроется. */
        isOpen: boolean;
        /** Содержимое панели */
        children?: React.ReactNode;
        /**
         * Если флаг установлен, то событие click внутри окна не поднимается к родителельскому элементу.
         * По умолчанию: true
         */
        stopClickPropogation?: boolean;
    }
    /**
     * Представляет всплывающее окно.
     *
     * Пример использования:
     *
     *     <ModalBackdrop onClick={() => this.setState({ dialogOpen: false })} />
     *         <ModalDialog expanded={this.state.dialogOpen} >
     *             <ModalDialogBox defaultWidth={true}>
     *                 <ModalDialogCloseButton onClick={() => this.setState({ dialogOpen: false })} />
     *                 <ModalDialogHeader>Dialog header</ModalDialogHeader>
     *                 <ModalDialogContent>Some content</ModalDialogContent>
     *                 <ModalDialogButtonPanel>
     *                     <Button onClick={() => this.setState({ dialogOpen: false })} key="cancel">
     *                         {resources.Navigator_ButtonClose}
     *                     </Button>
     *                     <Button disabled={!this.state.directoryDialogSelectedValue}
     *                         onClick={this.onDirectoryDialogSelectButtonClick} key="ok">
     *                         {resources.Navigator_ButtonSelect}
     *                     </Button>
     *                 </ModalDialogButtonPanel>
     *             </ModalDialogBox>
     *         </ModalDialog>
     *     </ModalBackdrop>
     */
    const ModalDialog: (props: IModalDialogProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalDialogBox} */
    interface IModalDialogBoxProps {
        children?: React.ReactNode;
        /**
         * Если значение истино, то устаналивается ширина окна 800px, иначе ширина соответствует ширине содержимого.
         * По умолчанию: false
         */
        defaultWidth?: boolean;
        /** Пользовательский CSS-класс */
        className?: string;
    }
    /**
     * Представляет полотно модального окна ({@link ModalDialog}).
     *
     * Пример использования:
     *
     *     <ModalBackdrop onClick={() => this.setState({ dialogOpen: false })} />
     *         <ModalDialog expanded={this.state.dialogOpen} >
     *             <ModalDialogBox defaultWidth={true}>
     *                 <ModalDialogCloseButton onClick={() => this.setState({ dialogOpen: false })} />
     *                 <ModalDialogHeader>Dialog header</ModalDialogHeader>
     *                 <ModalDialogContent>Some content</ModalDialogContent>
     *                 <ModalDialogButtonPanel>
     *                     <Button onClick={() => this.setState({ dialogOpen: false })} key="cancel">
     *                         {resources.Navigator_ButtonClose}
     *                     </Button>
     *                     <Button disabled={!this.state.directoryDialogSelectedValue}
     *                         onClick={this.onDirectoryDialogSelectButtonClick} key="ok">
     *                         {resources.Navigator_ButtonSelect}
     *                     </Button>
     *                 </ModalDialogButtonPanel>
     *             </ModalDialogBox>
     *         </ModalDialog>
     *     </ModalBackdrop>
     */
    const ModalDialogBox: (props: IModalDialogBoxProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalDialogButtonPanel} */
    interface IModalDialogButtonPanelProps {
        /** Содержимое панели */
        children?: React.ReactNode;
        /** Пользовательский CSS-класс */
        className?: string;
    }
    /**
     * Представляет панель кнопок модального диалога ({@link ModalDialog}).
     *
     * Пример использования:
     *
     *     <ModalDialog isOpen={this.state.dialogOpen}>
     *         <ModalDialogBox defaultWidth={true}>
     *             <ModalDialogButtonPanel>
     *                 <Button onClick={this.hideDictionary} key="cancel">
     *                     {resources.Navigator_ButtonClose}
     *                 </Button>
     *                 <Button disabled={!this.state.directoryDialogSelectedValue}
     *                     onClick={this.onDirectoryDialogSelectButtonClick} key="ok">
     *                     {resources.Navigator_ButtonSelect}
     *                 </Button>
     *             </ModalDialogButtonPanel>
     *         </ModalDialogBox>
     *     </ModalDialog>
     */
    const ModalDialogButtonPanel: (props: IModalDialogButtonPanelProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalSidebarCloseButton} */
    interface IModalDialogCloseButtonProps {
        /** Доступность кнопки. Значение по умолчанию: true */
        enabled?: boolean;
        /** Обработчик события click */
        onClick: (ev: React.MouseEvent<any>) => void;
    }
    /**
     * Представляет закрывающую кнопку в правой части выезжающей панели ({@link ModalDialog}).
     *
     * Пример использования:
     *
     *     <ModalDialog isOpen={this.state.dialogOpen} >
     *         <ModalDialogBox defaultWidth={true}>
     *             <ModalDialogCloseButton onClick={() => this.setState({ dialogOpen: false })} />
     *         </ModalDialogBox>
     *     </ModalDialog>
     */
    const ModalDialogCloseButton: (props: IModalSidebarCloseButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalDialogHeader} */
    interface IModalDialogHeaderProps {
        /** Содержимое заголовка */
        children?: React.ReactNode;
        /** Пользовательский класс заголовка */
        className?: string;
    }
    /** Добавляет отступы и некоторые другие стили, обеспечивающие аккуратное отображение заголовка в ({@link ModalDialogBox}).
      *
      * Пример использования:
      *
      *     <ModalDialog isOpen={this.state.dialogOpen} >
      *         <ModalDialogBox defaultWidth={true}>
      *             <ModalDialogHeader>Dialog header</ModalDialogHeader>
      *             <ModalDialogContent>Dialog content</ModalDialogContent>
      *         </ModalDialogBox>
      *     </ModalDialog>
      */
    const ModalDialogHeader: (props: IModalDialogHeaderProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalDialogTopBorder} */
    interface IModalDialogTopBorderProps {
        color: string;
    }
    /**
     * Добавляет цветную полосу в верхнюю часть модального окна ({@link ModalDialog}).
     *
     * Пример использования:
     *
     *     <ModalDialog isOpen={this.state.dialogOpen} >
     *         <ModalDialogBox defaultWidth={true}>
     *             <ModalDialogTopBorder color="red" />
     *         </ModalDialogBox>
     *     </ModalDialog>
     */
    const ModalDialogTopBorder: (props: IModalDialogTopBorderProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal
      * Свойства для { @link ScrollableModalDialog }
      */
    interface IScrollableModalAreaProps {
        maxHeight: string;
    }
    const ScrollableModalArea: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IScrollableModalAreaProps, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IScrollableModalAreaProps>;
}
declare namespace WebClient {
    /** Свойства для {@link ModalSidebar} */
    interface IModalSidebarProps {
        /** При смене значения на true модальное окно откроется, при смене в false - скроется. */
        isOpen: boolean;
        /** Содержимое панели */
        children?: React.ReactNode;
        /**
         * Если флаг установлен, то событие click внутри панели не поднимается к родителельскому элементу.
         * По умолчанию: true
         */
        stopClickPropogation?: boolean;
        /** Дополнительный css-класс. */
        className?: string;
        paddings?: boolean;
    }
    /**
     * Представляет выезжающую боковую панель.
     *
     * Пример использования:
     *
     *     <div>
     *         <ModalBackdrop onClick={() => this.setState({ sidebarOpen: false })}>
     *             <ModalSidebar isOpen={this.state.sidebarOpen} >
     *                 <ModalSidebarCloseButton onClick={() => this.setState({ sidebarOpen: false })} />
     *                 <ModalSidebarHeader>Some header</ModalSidebarHeader>
     *                 <div>Some content</div>
     *             </ModalSidebar>
     *         </ModalBackdrop>
     *     </div>
     *
     * Пример использование вне компонента:
     *
     *     let host: ModalHost = new ModalHost("time-sidebar", () => {
     *         return (
     *             <ModalBackdrop visible={true} onClick={() => host.unmount()} >
     *                 <ModalSidebar isOpen={true} >
     *                     <ModalSidebarCloseButton onClick={() => host.unmount()} />
     *                     <ModalSidebarHeader>Some header</ModalSidebarHeader>
     *                     <div>Current time {(new Date()).toTimeString()}</div>
     *                 </ModalSidebar>
     *             </ModalBackdrop>
     *         );
     *     });
     *     host.mount();
     *     setInterval(() => host.forceUpdate(), 1000);
     *
     */
    const ModalSidebar: (props: IModalSidebarProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalSidebarCloseButton} */
    interface IModalSidebarCloseButtonProps {
        /** Доступность кнопки. Значение по умолчанию: true */
        enabled?: boolean;
        /** Обработчик события click */
        onClick: (ev: React.MouseEvent<any>) => void;
    }
    /**
     * Представляет закрывающую кнопку в правой части выезжающей панели ({@link ModalSidebar}).
     *
     * Пример использования:
     *
     *     <ModalSidebar isOpen={this.state.sidebarOpen} >
     *         <ModalSidebarCloseButton onClick={() => this.setState({ sidebarOpen: false })} />
     *     </ModalSidebar>
     */
    const ModalSidebarCloseButton: (props: IModalSidebarCloseButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link ModalSidebarHeader} */
    interface IModalSidebarHeaderProps {
        /** Дополнительный класс */
        className?: string;
        /** Содержимое заголовка  */
        children?: React.ReactNode;
    }
    /**
     * Представляет заголовок выезжающей панели ({@link ModalSidebar}).
     *
     * Пример использования:
     *
     *     <ModalSidebar isOpen={this.state.menuBarExpanded} >
     *         <ModalSidebarHeader>{resources.MyHeaderText}</ModalSidebarHeader>
     *     </ModalSidebar>
     */
    const ModalSidebarHeader: (props: IModalSidebarHeaderProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal Свойства для {@link ClosePopoverListener} */
    interface IClosePopoverListenerProps {
        /** Дополнительный класс */
        className?: string;
        /** Используется при закрытии по клику мышкой снаружи, разрешает клики внутри переданного контейнера (по умолчанию - корень этого компонента) */
        boundaryTarget?: HTMLElement | string;
        /** При закрытии выпадающего списка */
        onClose?: () => void;
    }
    /**
     * @internal Панель, которая отслеживает события клика вне себя и нажатия клавиши Esc.
     */
    class ClosePopoverListener extends React.PureComponent<IClosePopoverListenerProps> {
        el: HTMLElement;
        componentDidMount(): void;
        componentWillUnmount(): void;
        /**
         * Закрытие выпадающего меню при клике снаружи
         */
        protected onDocumentClick: (event: MouseEvent) => void;
        protected onDocumentKeyDown: (e: any) => void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Свойства для  {@link Popover} */
    interface IInlineDropdownPopoverProps {
        /** Дополнительный класс */
        className?: string;
        innerElementRef?: (elem: HTMLElement) => void;
        topPlacementShift?: string;
    }
    /** @internal */
    interface IInlineDropdownPopoverState {
        locatedTop?: boolean;
        updateCount: number;
    }
    /**
     * Компонент, который обеспечивает абсолютное позиционирование всплывающего выпадающего списка снизу так, что левый край выровнен по левому краю родителя.
     * Если снизу оказывается недостаточно места, то панель показывается сверху.
     */
    class InlineDropdownPopover extends React.Component<IInlineDropdownPopoverProps, IInlineDropdownPopoverState> {
        private static mPopoversContainer;
        private static getPopoversContainer();
        private root;
        constructor(props: IInlineDropdownPopoverProps);
        componentWillReceiveProps(): void;
        componentDidUpdate(): void;
        componentDidMount(): void;
        componentWillUnmount(): void;
        private subscribeGlobalEvents();
        private unsubscribeGlobalEvents();
        private onPageScroll;
        private onWindowResize;
        /**
         * Перессчитать позицию всплывающего окна.
         */
        updatePositions(): void;
        attachRoot: (elem: HTMLElement) => void;
        static Wrapper: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IInlineDropdownPopoverState & IInlineDropdownPopoverProps & {
            className: string;
        }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IInlineDropdownPopoverState & IInlineDropdownPopoverProps>;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Свойства для  {@link Popover} */
    interface IPopoverProps {
        /** При смене значения на true всплывающее окно откроется, при смене в false - скроется. */
        isOpen: boolean;
        /** Контейнер целевого элемента, в котором будет отслеживаться скролл. */
        container?: HTMLElement;
        /**
         * Элемент, относительно которого всплывающее окно будет позиционироваться.
         *
         * Замечание: Popover не может корректно позиционироваться относительно элементов с display: inline.
         *
         * По умолчанию: ближайший не-inline родитель Popover.
         */
        target?: HTMLElement;
        /** Минимальная дистанция до границ экрана в пикселях. */
        screenPadding?: number;
        /**
         * Место относительно целевого элемента, где будет размещено вспылвающее окно.
         *
         * Замечение: если места сверху будет недостаточно (будут мешать границы экрана), то всплывающее окно
         * автоматически сместится вниз.
         *
         * По умолчанию: PopoverMode.Above
         */
        mode?: PopoverMode;
        /** Статичное смещение всплывающего окна от вычисленного положения по оси X в пикселях. */
        xShift?: number;
        /** Событие click вне всплывающего окна. */
        onClickOutside?: (ev: MouseEvent) => void;
        /** Событие нажатия Enter (срабатывает, даже когда фокус вне модального окна). */
        onEnterPressed?: (ev: KeyboardEvent) => void;
        /** Событие нажатия Esc (срабатывает, даже когда фокус вне модального окна). */
        onEscPressed?: (ev: KeyboardEvent) => void;
        /** Содержимое модального окна. Используйте {@link PopoverBox} для создания белой панели со скругленными краями. */
        children?: React.ReactNode;
        /** Дополнительный класс, который будет назначен на корневой элемент. */
        className?: string;
    }
    /** @internal */
    interface IPopoverState {
        currentTarget: HTMLElement;
        offScreenX: boolean;
        offScreenY: boolean;
        screenPadding: number;
        mode: PopoverMode;
        hideClassName: string;
        positionCalculated: boolean;
        renderReady: boolean;
    }
    /**
     * Режим Popover.
     */
    enum PopoverMode {
        /** Сверху по центру. Если сверху места нет, то показывается снизу. */
        Above = 0,
        /** Слева, выровненное вертикально по верхнему краю (верхний край окна совпадает с верхним краем целевого элемента).
         * Если снизу не хватает места, то смещается вверх ровно на столько, чтобы уместить на экране.
         * Если слева нет места, то смещается ровно на столько, чтобы уместить на экране.
         */
        LeftSide = 1,
        /** Снизу, выровненное так, что левый край окна соответствует левому краю целевого элемента. Если снизу нет места, то показывается сверху. */
        BottomDropdown = 2,
    }
    /**
     * Компонент, который обеспечивает позиционирование всплывающего модального окна.
     *
     * Замечание: при показе всплывающего окна создается элемент в body документа (или в указанном контейнере) с абсолютной позицией,
     * который при помощи свойств top и left размещается над целевым элементом. При этом, обновление координат происходит
     * при перерисовке компонента, при ресайзе и скроле окна, а также при скроле элемента-контейнера. Можно запустить перессчет
     * позиции вручную при помощи метода {@link updatePositions}. Предпочитительнее использовать этот метод, вместо перерисовки
     * компонента, т.к. данный метод только обновляет позицию, в то время как перерисовка запускает обновление содержимого
     * всплывающего окна (это критично, если нужно обновлять позицию в события, возникающих часто).
     *
     * Из принципа работы компонента также следует, что анимации при показе окна могут некорректно работать при смене значения isOpen,
     * т.к. при показе окна элемент каждый раз создается заново. Если нужно при показе только сменить css-класс (для выполнения анимации),
     * то следует держать значение isOpen всегда true, и скрывать только содержимое всплывающего окна при помощи css. Сам компонент
     * не создает никаких видимых артефактов на экране, поэтому данный сценарий допустим.
     *
     * Также следует отметить, что физически всплывающее окна располагается в другом месте DOM, не там где отрендерен элемент Popover.
     * Поэтому, наследование css-стилей не будет работать для содержимого вслывающего окна. При необходимости, можно задать
     * {@link IPopoverProps.container}, чтобы указать место в DOM, где должен размещаться элемент. Однако, в этом случае могут возникнуть
     * проблемы с перекрыванием содержимого с другими элементами на странице.
     *
     * Пример использования:
     *
     *     <div>
     *         <Popover isOpen={this.state.popoverOpen} onClickOutside={this.closePopover} onEscPressed={this.closePopover}>
     *             <PopoverBox>
     *                 <PopoverHead>
     *                     <PopoverTitle>Заголовок</PopoverTitle>
     *                 </PopoverHead>
     *                 <PopoverContent>
     *                     Содержимое
     *                 </PopoverContent>
     *             </PopoverBox>
     *         </Popover>
     *         <span>Элемент, около которого появится окно</span>
     *     </div>
     *
     *  См. также: {@link PopoverBox}, {@link PopoverHead}, {@link PopoverTitle},
     *  {@link PopoverCloseButton}, {@link PopoverAcceptButton}, {@link PopoverCancelButton}, {@link PopoverContent}
     */
    class Popover extends React.Component<IPopoverProps, IPopoverState> {
        private static mPopoversContainer;
        private static getPopoversContainer();
        private root;
        constructor(props: IPopoverProps);
        /** @internal */
        componentWillUnmount(): void;
        /** @internal */
        componentWillReceiveProps(nextProps: IPopoverProps, nextContext: any): void;
        /** @internal */
        componentDidUpdate(): void;
        /** @internal */
        componentDidMount(): void;
        private attachStub(elem);
        private onShow();
        private onHide();
        /** Скрывает всплывающее окна и очищает все занимаемые ресурсы. */
        dispose(): JQueryDeferred<any>;
        private onDocumentClick(event);
        private onDocumentKeyDown(ev);
        private subscribeGlobalEvents(keydown, click, position);
        private unsubscribeGlobalEvents(keydown, click, position);
        private onPageScroll();
        private onWindowResize();
        /**
         * Перессчитать позицию всплывающего окна.
         */
        updatePositions(): void;
        private updateTopPosition(target);
        private updateHorizontalPosition;
        private renderPopover();
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Свойства для {@link PopoverAcceptButton} */
    interface IPopoverAcceptButtonProps {
        /** Обработчик события click */
        onClick: (ev: React.MouseEvent<any>) => void;
    }
    /**
     * Представляет кнопку в виде иконки "принять".
     *
     * Пример использования:
     *
     *     <Popover isOpen={this.state.popoverOpen} onClickOutside={this.cancel} onEscPressed={this.cancel}>
     *         <PopoverBox>
     *             <PopoverHead>
     *                 <HorizontalStack>
     *                     <StackSpringItem>
     *                         <PopoverTitle>Заголовок</PopoverTitle>
     *                     </StackSpringItem>
     *                     <StackStaticItem>
     *                         <PopoverAcceptButton onClick={this.accept} />
     *                     </StackStaticItem>
     *                     <StackStaticItem>
     *                         <PopoverCancelButton onClick={this.cancel} />
     *                     </StackStaticItem>
     *                 </HorizontalStack>
     *             </PopoverHead>
     *             <PopoverContent>
     *                 Содержимое
     *             </PopoverContent>
     *         </PopoverBox>
     *     </Popover>
     *
     * См. также {@link Popover}
     */
    const PopoverAcceptButton: (props: IPopoverAcceptButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link PopoverBox} */
    interface IPopoverBoxProps {
        /** Содержимое PopoverBox */
        children?: React.ReactNode;
        className?: string;
        attributes?: Object;
    }
    /**
     * Представляет полотно {@link Popover}
     *
     * Пример использования:
     *
     *     <Popover isOpen={this.state.popoverOpen} >
     *         <PopoverBox>
     *             <div>Содержимое</div>
     *         </PopoverBox>
     *     </Popover>
     *
     * См. также {@link Popover}
     */
    const PopoverBox: (props: IPopoverBoxProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link PopoverCancelButton} */
    interface IPopoverCancelButtonProps {
        /** Обработчик события click */
        onClick: (ev: React.MouseEvent<any>) => void;
    }
    /**
     * Представляет кнопку в виде иконки "отменить".
     *
     * Пример использования:
     *
     *      <Popover isOpen={this.state.popoverOpen} onClickOutside={this.cancel} onEscPressed={this.cancel}>
     *          <PopoverBox>
     *              <PopoverHead>
     *                  <HorizontalStack>
     *                      <StackSpringItem>
     *                          <PopoverTitle>Заголовок</PopoverTitle>
     *                      </StackSpringItem>
     *                      <StackStaticItem>
     *                          <PopoverAcceptButton onClick={this.accept} />
     *                      </StackStaticItem>
     *                      <StackStaticItem>
     *                          <PopoverCancelButton onClick={this.cancel} />
     *                      </StackStaticItem>
     *                  </HorizontalStack>
     *              </PopoverHead>
     *              <PopoverContent>
     *                  Содержимое
     *              </PopoverContent>
     *         </PopoverBox>
     *      </Popover>
     *
     * См. также {@link Popover}
     */
    const PopoverCancelButton: (props: IPopoverCancelButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link PopoverCloseButton} */
    interface IPopoverCloseButtonProps {
        /** Обработчик события click */
        onClick: (ev: React.MouseEvent<any>) => void;
    }
    /**
     * Представляет кнопку в виде иконки "закрыть".
     *
     * Пример использования:
     *
     *      <Popover isOpen={this.state.popoverOpen} onClickOutside={this.closePopover} onEscPressed={this.closePopover}>
     *          <PopoverBox>
     *              <PopoverHead>
     *                  <HorizontalStack>
     *                      <StackSpringItem>
     *                          <PopoverTitle>Заголовок</PopoverTitle>
     *                      </StackSpringItem>
     *                      <StackStaticItem>
     *                          <PopoverCloseButton onClick={this.closePopover} />
     *                      </StackStaticItem>
     *                  </HorizontalStack>
     *              </PopoverHead>
     *              <PopoverContent>
     *                  Содержимое
     *              </PopoverContent>
     *         </PopoverBox>
     *      </Popover>
     *
     * См. также {@link Popover}
     */
    const PopoverCloseButton: (props: IPopoverCloseButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link PopoverContent} */
    interface IPopoverContentProps {
        /** Содержимое PopoverContent  */
        children?: React.ReactNode;
        /** Дополнительный класс */
        className?: string;
    }
    /**
     * Добавляет отступы и некоторые другие стили, обеспечивающие аккуратное отображение содержимого в {@link PopoverBox}
     *
     * Пример использования:
     *
     *     <div>
     *         <Popover isOpen={this.state.popoverOpen} >
     *             <PopoverBox>
     *                 <PopoverContent>
     *                     Содержимое
     *                 </PopoverContent>
     *             </PopoverBox>
     *         </Popover>
     *         <span>Элемент, около которого появится окно</span>
     *     </div>
     *
     * См. также {@link Popover}
     */
    const PopoverContent: (props: IPopoverContentProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link PopoverHead} */
    interface IPopoverHeadProps {
        /** Содержимое PopoverHead  */
        children?: React.ReactNode;
    }
    /**
     * Представляет блок с заголовком всплывающего окна в {@link PopoverBox}.
     *
     * Пример использования:
     *
     *     <div>
     *         <Popover isOpen={this.state.popoverOpen} >
     *             <PopoverBox>
     *                 <PopoverHead>
     *                     <PopoverTitle>Заголовок</PopoverTitle>
     *                 </PopoverHead>
     *                 <PopoverContent>
     *                     Содержимое
     *                 </PopoverContent>
     *             </PopoverBox>
     *         </Popover>
     *         <span>Элемент, около которого появится окно</span>
     *     </div>
     *
     * См. также {@link Popover}
     */
    const PopoverHead: (props: IPopoverHeadProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link PopoverOverflowContent} */
    interface IPopoverOverflowContentProps {
        /** Содержимое PopoverContent  */
        children?: React.ReactNode;
    }
    /**
     * Аналогичен {@link PopoverContent}, но с обеспечением видимости абсолютно спозиционированных элементов,
     * выдающихся за край содержимого. Данное поведение, в свою очередь, исключает появление прокрутки для большого содержимого.
     *
     *
     * Пример использования:
     *
     *       <div>
     *           <Popover isOpen={this.state.popoverOpen} >
     *               <PopoverBox>
     *                   <PopoverOverflowContent>
     *                       <Employee parent={this.state.wrapper} modalMode={true} />
     *                   </PopoverOverflowContent>
     *               </PopoverBox>
     *           </Popover>
     *           <span>Элемент, около которого появится окно</span>
     *       </div>
     *
     * См. также {@link Popover}
     */
    const PopoverOverflowContent: (props: IPopoverOverflowContentProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link PopoverTitle} */
    interface IPopoverTitleProps {
        /** Содержимое PopoverTitle */
        children?: React.ReactNode;
    }
    /**
     * Добавляет отступы и некоторые другие стили для аккуратного отображения заголовка всплывающего окна в {@link PopoverHead}.
     *
     * Пример использования:
     *
     *     <div>
     *         <Popover isOpen={this.state.popoverOpen} >
     *             <PopoverBox>
     *                 <PopoverHead>
     *                     <PopoverTitle>Заголовок</PopoverTitle>
     *                 </PopoverHead>
     *                 <PopoverContent>
     *                     Содержимое
     *                 </PopoverContent>
     *             </PopoverBox>
     *         </Popover>
     *         <span>Элемент, около которого появится окно</span>
     *     </div>
     *
     * См. также {@link Popover}
     */
    const PopoverTitle: (props: IPopoverTitleProps) => JSX.Element;
}
declare namespace WebClient {
    /**
     * @internal Тип ReactList.
     */
    const ReactListVirtualization: {
        simple: string;
        uniform: string;
        variable: string;
    };
    /**
     * @internal Свойства для {@link ReactList}
     */
    interface IReactListProps {
        /** Ось, по которой скроллится ReactList */
        axis?: string;
        /** Начальный индекс элемента */
        initialIndex?: number;
        /** Функция, возвращающая содержимое для отрисовки элемента с указанным индексом. */
        itemRenderer?: (index: number, key: number | string) => any;
        /**
         * Функция, которая получает индекс элемента и известные кэшированные размеры элементов и возвращает
         * примерный размер (высоту для вертикальных списков или ширину для горизонтальных) элемента в переданном индексе.
         * Используется только с типом variable, когда свойство itemSizeGetter не определено.
         * Используйте это свойство, если вы не знаете точный размер элемента перед его отрисовкой, но хотите, чтобы он всё-равно занимал место в списке.
         */
        itemSizeEstimator?: (index: number, cache: any) => any;
        /** Возвращает размер элемента с указанным индексом. Используется только с типом variable. */
        itemSizeGetter?: (index: number) => any;
        /**
         * Возвращает обёртку для отрисованных элементов. По умолчанию это обычный <div>.
         *
         * Примечание: вы должны установить ref={ref} на компоненте, который содержит элементы items,
         * чтобы можно было выполнить правильные вычисления размера элемента.
         */
        itemsRenderer?: (items: any, ref: any) => any;
        /** Количество элементов в списке. */
        length: number;
        /** Минимальное количество элементов в списке. Может использоваться для рендеринга элементов по умолчанию при рендеринге HTML на сервере. */
        minSize: number;
        /**
         * Количество элементов в группе для новой отрисовки.
         * Не используется с типом uniform, так как оптимальное количество элементов рассчитывается автоматически.
         */
        pageSize?: number;
        /**
         * Функция, которая возвращает DOM-узел или Window. Возвращённое значение будет рассматриваться как контейнер прокрутки для списка.
         * Может использоваться для тех случаев, когда в контейнере для скроллинга элементов по умолчанию отсутствует свойство overflow, включающее скроллинг;
         */
        scrollParentGetter?: any;
        /** Количество пикселей для буфера в начале и конце списка */
        threshold?: number;
        /** Тип ReactList (см. {@link ReactListVirtualization}). */
        type: string;
        /**
         * Установите в true, если размеры элементов никогда не изменятся (в результате изменения адаптивного макета и т.п.).
         * Используется только с типом uniform.
         * Данная оптимизация приведет к тому, что размер самого первого элемента будет всегда использоваться для всех остальных элементов.
         */
        useStaticSize?: boolean;
        /**
         * Установите в true, чтобы использовать CSS-свойство translate3d для позиционирования в списке.
         * Это может улучшить производительность на мобильных устройствах, но поддерживается меньшим количеством браузеров.
         */
        useTranslate3d?: boolean;
    }
    /**
     * Удобный список для отображения большого количества элементов.
     *
     * Ссылка на официальный репозиторий {@link https://github.com/orgsync/react-list}.
     */
    class ReactList extends React.Component<IReactListProps, any> {
        /** @internal */
        static displayName: string;
        /** @internal */
        cache: any;
        /** @internal */
        prevPrevState: any;
        /** @internal */
        unstable: boolean;
        /** @internal */
        updateCounter: number;
        /** @internal */
        updateCounterTimeoutId: any;
        /** @internal */
        items: any;
        /** @internal */
        scrollParent: any;
        /**
         * Значение свойств по умолчанию.
         */
        static defaultProps: Partial<IReactListProps>;
        constructor(props: any);
        /** @internal */
        componentWillReceiveProps(next: any): void;
        /** @internal */
        componentDidMount(): void;
        /** @internal */
        componentDidUpdate(): void;
        /** @internal */
        maybeSetState(b: any, cb: any): any;
        /** @internal */
        componentWillUnmount(): void;
        /** @internal */
        getOffset(el: any): any;
        /** @internal */
        getScrollParent(): any;
        /** @internal */
        getScroll(): number;
        /** @internal */
        setScroll(offset: any): void;
        /** @internal */
        getViewportSize(): any;
        /** @internal */
        getScrollSize(): any;
        /** @internal */
        hasDeterminateSize(): true | ((index: number) => any);
        /** @internal */
        getStartAndEnd(threshold?: number): {
            start: number;
            end: any;
        };
        /** @internal */
        getItemSizeAndItemsPerRow(): {
            itemSize: any;
            itemsPerRow: any;
        } | {
            itemSize?: undefined;
            itemsPerRow?: undefined;
        };
        /** @internal */
        updateFrame(cb: any): any;
        /** @internal */
        updateScrollParent(): void;
        /** @internal */
        updateSimpleFrame(cb: any): any;
        /** @internal */
        updateVariableFrame(cb: any): void;
        /** @internal */
        updateUniformFrame(cb: any): any;
        /** @internal */
        getSpaceBefore(index: any, cache?: {}): any;
        /** @internal */
        cacheSizes(): void;
        /** @internal */
        getSizeOf(index: any): any;
        /** @internal */
        constrain(from: any, size: any, itemsPerRow: any, {length, minSize, type}: {
            length: any;
            minSize: any;
            type: any;
        }): {
            from: any;
            size: any;
        };
        /** @internal */
        scrollTo(index: any): void;
        /** @internal */
        scrollAround(index: any): void;
        /** @internal */
        getVisibleRange(): any[];
        /** @internal */
        renderItems(): any;
        /** @internal */
        render(): any;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IReactListDynamicProps {
        /** Ось, по которой скроллится ReactList */
        axis?: string;
        /** Начальный индекс элемента */
        initialIndex?: number;
        /** Длина списка */
        length: number;
        /** Минимальный количество элементов для отрисовки */
        minSize?: number;
        /** Количество пикселей для буффера снизу и сверху списка */
        threshold?: number;
        /** Использовать css-свойство translate3d для скролла (работает чуть быстрее, меньше поддержка браузерами) */
        useTranslate3d?: boolean;
        /** Инлайн-стили для контейнера */
        style?: any;
        /** Название класса для контейнера */
        className?: string;
        /** Название класса для пустого элемента списка */
        emptyItemClassName?: string;
        /** Название класса для загрузки элемента списка */
        loadingItemClassName?: string;
        /** Скрыт ли ReactListDynamic */
        hidden?: boolean;
        /** Пользовательский элемент для контейнера */
        customContainer?: any;
        /** Загружать ли данные при первой инициализации компонента */
        notLoadOnInit?: boolean;
        /** Загрузчик элементов, просящий загрузить и передать в props.items элементы с указанными индексами */
        loadItems: (indexes: number[]) => void;
        /** Задержка перед загрузкой данных после остановки прокрутки */
        fetchThreshold?: number;
        /** Загружать дополнительно n элементов выше и ниже элементов в видимой области */
        itemsThreshold?: number;
        /** Высота элемента (допустимы значения в px, em и т.д.). Не нужна, если вы сами реализуете renderEmptyItem и renderLoadingItem. */
        itemHeight?: number | string;
        /** Элементы списка */
        items: any[];
        /** Рендеринг отдельного элемента списка */
        renderItem: (key: number | string, itemData: any, index: number) => React.ReactNode;
        /** Рендеринг пустого элемента списка */
        renderEmptyItem?: (index: number, key: number | string) => React.ReactNode;
        /** Рендеринг загружаемого элемента списка (когда начали загружать пустой элемент списка) */
        renderLoadingItem?: (index: number, key: number | string, state: LoadingState) => React.ReactNode;
    }
    interface IReactListDynamicState {
        /** Информация о загружаемых элементах списка */
        loading: {
            [index: number]: boolean;
        };
    }
    /**
     * @review
     * ReactList с возможностью динамической подгрузки результатов
     *
     * Если нужно задать высоту контейнера, то её необходимо задать через свойства
     * Если элемент списка не удалось загрузить динамически (к примеру, он отсутствует), то вместо него необходимо вернуть ReactListDynamic.UNDEFINED_ITEM
     *
     * Пример использования:
     *
     *     constructor(props) {
     *         super(props);
     *
     *         this.state = {
     *             items: []
     *         };
     *     }
     *
     *     itemsFetcher = (start: number, end: number) => {
     *         ...
     *     }
     *
     *     loadItems = (indexes: number[]) => {
     *         this.itemsFetcher(indexes).then(items => {
     *             indexes.forEach(index => this.state.items[index] = items[index]);
     *             this.forceUpdate();
     *         }, err => {
     *             indexes.forEach(index => this.state.items[index] = ReactListDynamic.EMPTY_ITEM);
     *             this.forceUpdate();
     *         });
     *     };
     *
     *     renderItem = (key: number, itemData: any) => {
     *         return <div key={key} style={{ height: 30 }}>{itemData.title}</div>;
     *     };
     *
     *     render() {
     *         return <ReactListDynamic style={{ height: 180, overflow: 'auto' }}
     *             itemsThreshold={3} length={50} itemHeight={30}
     *             items={this.state.items} loadItems={this.loadItems} renderItem={this.renderItem} />;
     *     }
     *
     */
    class ReactListDynamic extends React.Component<IReactListDynamicProps, IReactListDynamicState> {
        /** Задержка перед загрузкой элемента списка по умолчанию */
        static readonly FETCH_THRESHOLD: number;
        /** Элемент списка должен быть равен UNDEFINED_ITEM, если его по какой-то причине не удалось загрузить */
        static readonly UNDEFINED_ITEM: {};
        /** Контейнер по умолчанию */
        protected defaultContainer: any;
        /**
         * Экземпляр ReactList
         */
        protected reactList: ReactList;
        /**
         * Задержка перед загрузкой при прокрутке списка
         */
        protected thresholdTimeout: any;
        constructor(props: any);
        componentDidMount(): void;
        componentWillUnmount(): void;
        /**
         * Загружает список элементов
         */
        loadItems: () => void;
        /**
         * При скролле списка
         */
        protected onScroll: () => void;
        /**
         * Отрисовываем элемент списка
         */
        protected renderItem: (index: number, key: string | number) => {};
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IReactListInfiniteScrollProps {
        axis?: string;
        initialIndex?: number;
        itemRenderer?: any;
        itemSizeEstimator?: any;
        itemSizeGetter?: any;
        minSize?: number;
        pageSize?: number;
        scrollParentGetter?: any;
        type: string;
        useStaticSize?: boolean;
        useTranslate3d?: boolean;
        /** Инлайн-стили для контейнера */
        style?: any;
        /** Название класса для контейнера */
        className?: string;
        /** Пользовательский элемент для контейнера (может быть обычный компонент или styledComponent) */
        customContainer?: any;
        /** Элементы списка */
        items: any[];
        /** Дополнительный отступ снизу списка, доскролля до которого произойдёт загрузка следующей страницы */
        gap?: number;
        /** fillPage работает так - если высота начальных данных меньше высоты окна с бесконечным списком, то грузим данные, пока она не заполнится */
        notFillPage?: boolean;
        /** Загружать ли данные при первой инициализации компонента */
        notLoadOnInit?: boolean;
        /** Номер стартовой страницы, начиная с которой начнётся первая загрузка элементов */
        initialPage?: number;
        /** Загружает новую страницу и возвращает информацию о том, существуют ли ещё результаты или нет */
        loadPage: (pageNumber: number) => JQueryDeferred<{}>;
        /** Есть ли еще незагруженные данные. */
        nextPageExists: boolean;
    }
    /**
     * @review
     * ReactList с возможностью бесконечного скролла
     *
     * Если нужно задать высоту контейнера, то её необходимо задать через свойства
     *
     * Пример использования:
     *
     *     constructor(props) {
     *         super(props);
     *
     *         this.state = {
     *             items: []
     *         };
     *     }
     *
     *     getPage = (pageNumber: number) => {
     *         ...
     *     }
     *
     *     loadPage = (pageNumber: number) => {
     *         this.getPage(pageNumber).then(itemsPart => {
     *             this.setState(prevState => ({ items: prevState.items.concat(itemsPart) }));
     *         });
     *     };
     *
     *     renderItem = (index: number, key: number) => {
     *         return <div key={key}>{this.state.items[index].title}</div>;
     *     };
     *
     *     render() {
     *         return <ReactListInfiniteScroll customContainer={CustomTreeDefault} items={this.state.items}
     *             loadPage={this.loadPage} type={ReactListVirtualization.variable} itemRenderer={this.renderItem} />
     *     }
     *
     */
    class ReactListInfiniteScroll extends React.Component<IReactListInfiniteScrollProps, undefined> {
        static readonly DEFAULT_GAP: number;
        static readonly DEFAULT_CONTAINER: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
        /** Номер страницы */
        protected page: number;
        /** Текущий контейнер */
        protected container: any;
        /** Информация о загрузке */
        protected loading: LoadingState;
        constructor(props: any);
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: IReactListInfiniteScrollProps): void;
        protected attachContainer: (elem: any) => void;
        /**
         * Загружает список элементов
         */
        loadNextPage: () => void;
        /**
         * Подгружает результаты, пока видимая часть страницы полностью не заполнится
         */
        protected fillPage: () => void;
        protected onScroll: (e: React.SyntheticEvent<any>) => void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Свойства для {@link Ribbon} */
    interface IRibbonProps {
        className?: string;
        children?: React.ReactNode;
    }
    /**
     * Представляет собой "ленту", на которой могут располагаться группы и кнопки.
     */
    const Ribbon: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IRibbonProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IRibbonProps>;
}
declare namespace WebClient {
    /** Свойства для {@link RibbonButton} */
    interface IRibbonButtonProps {
        className?: string;
        children?: React.ReactNode;
        visible?: boolean;
        checked?: boolean;
        onClick?: () => void;
    }
    /**
     * Кнопка для {@link Ribbon ленты}.
     */
    const RibbonButton: (props: IRibbonButtonProps) => JSX.Element;
}
declare namespace WebClient {
    /** Свойства для {@link RibbonGroup} */
    interface IRibbonGroupProps {
        className?: string;
        children?: React.ReactNode;
    }
    /**
     * Группа для {@link Ribbon ленты}.
     */
    const RibbonGroup: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IRibbonGroupProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IRibbonGroupProps>;
}
declare namespace WebClient {
    /** Свойства для {@link SliderCheckBox} */
    interface SliderCheckBoxProps {
        /** Вызывается при изменении значения. */
        onChange?: (newValue: boolean) => void;
        /**
         * Флаг, определяющий возможность изменения значения переключателя:
         * true - разрешено (разрешена настроенная операция редактирования),
         * false - не разрешено.
         */
        canEdit?: boolean;
        /** Значение чекбокса. */
        value?: boolean;
        /** Стандартный CSS класс со стилями переключателя. */
        className?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /** Текст метки. */
        labelText?: string;
        /** Определяет, должен ли переключатель получать фокус при переходе по Tab: `true` - должен, `false` - не должен. */
        tabStop?: boolean;
    }
    /** @internal */
    interface SliderCheckBoxState {
    }
    /**
     * Вспомогательный класс для переключателя между двумя значениями.
     */
    class SliderCheckBox extends React.Component<SliderCheckBoxProps, SliderCheckBoxState> {
        constructor(props: SliderCheckBoxProps);
        protected readonly canEdit: boolean;
        protected handleCheckBoxClick(event: any): void;
        protected getTabIndex(): 0 | -1;
        protected getCssClass(): string;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal Свойства для {@link Sortable} */
    interface ISortableProps {
        /** дочерние элементы {@link SortableItem}, которые необходимо перемещать */
        items: ISortableItem<any>[];
        /** Вызывается при изменении порядка дочерних элементов */
        onReorder: (newOrder: string[], sortedItems: ISortableItem<any>[]) => void;
        /** Порядок следования элементов в виде упорядоченного массива их идентификаторов (идентификаторы элементов, отсортированные в нужном порядке) */
        order: string[];
        /** Ось сортировки {@link http://api.jqueryui.com/sortable/#option-axis} */
        axis?: 'x' | 'y';
        /** Указывает, какой блок выступает границами сортировки {@link http://api.jqueryui.com/sortable/#option-containment} */
        containment?: HTMLElement | JQuery | 'parent' | 'document' | 'window' | string;
        /** Стиль курсора во время изменения порядка элементов {@link http://api.jqueryui.com/sortable/#option-cursor} */
        cursor?: string;
        /** Стиль курсора во время изменения порядка элементов {@link http://api.jqueryui.com/sortable/#option-disabled} */
        disabled?: boolean;
        /** Должен ли хелпер иметь размер {@link http://api.jqueryui.com/sortable/#option-forceHelperSize} */
        forceHelperSize?: boolean;
        /** Должен ли плейсхолдер иметь размер {@link http://api.jqueryui.com/sortable/#option-forcePlaceholderSize} */
        forcePlaceholderSize?: boolean;
        /**
         * Указывает селектор внутри дочернего элемента, за который можно будет его таскать (по умолчанию таскается весь дочерний элемент)
         * {@link http://api.jqueryui.com/sortable/#option-handle}
         */
        handle?: string;
        /** Прозрачность перетаскиваемого элемента {@link http://api.jqueryui.com/sortable/#option-opacity} */
        opacity?: number;
        /** Если true, то страница скроллится, когда перетаскиваемый элемент на её краю {@link http://api.jqueryui.com/sortable/#option-scroll} */
        scroll?: boolean;
        /**
         * Как далеко должна быть мышка от края (в пикселях), чтобы при перетаскивании страница скролилась бы (см. scroll)
         * {@link http://api.jqueryui.com/sortable/#option-scrollSensitivity}
         */
        scrollSensitivity?: number;
        /** Скорость скролла окна при перетаскивании (см. scroll) {@link http://api.jqueryui.com/sortable/#option-scrollSpeed} */
        scrollSpeed?: number;
        /**
         * Указывает режим, который регулирует, передвинулся ли перетаскиваемый элемент за другой элемент или нет
         * {@link http://api.jqueryui.com/sortable/#option-tolerance}
         */
        tolerance?: 'intersect' | 'pointer';
        /** ZIndex перетаскиваемого элемента {@link http://api.jqueryui.com/sortable/#option-zIndex} */
        zIndex?: number;
    }
    /**
      * @review
      * @internal Помогает с сортировкой дочерних элементов, путём их перетаскивания.
      *
      * Пример использования:
      *
      *     interface IMyItem {
      *         id: string;
      *         value: string;
      *     }
      *
      *     ...
      *
      *     constructor() {
      *         this.state.myItems = [
      *             {id: '1', value: 'Первый элемент'},
      *             {id: '2', value: 'Второй элемент'}
      *         ];
      *         this.state.myOrder = undefined;
      *     }
      *
      *     render() {
      *         return <Sortable order={this.state.myOrder}
      *             onReorder={(newOrder: string[], sortedItems: ISortableItem<IMyValue>[]) => {
      *                 this.state.myOrder = newOrder;
      *                 this.forceUpdate();
      *             }} items={this.state.myItems.map(item => ({
      *                 id: item.id,
      *                 data: item,
      *                 render: (data) => <div>{data.value}</div>
      *             }))} />
      *     }
      *
      */
    class Sortable extends React.Component<ISortableProps, undefined> {
        /** Контейнер для элементов. */
        el: HTMLElement;
        /** Была ли отменена сортировка. */
        protected wasCancelled: boolean;
        /** Идентификатор элемента для JQuery-sortable */
        static readonly ITEM_ID: string;
        /** Значение по умолчанию для свойства {@link ISortableProps.axis} */
        static readonly DEFAULT_AXIS: string;
        /** Значение по умолчанию для свойства {@link ISortableProps.containment} */
        static readonly DEFAULT_CONTAINMENT: string;
        /** Значение по умолчанию для свойства {@link ISortableProps.cursor} */
        static readonly DEFAULT_CURSOR: string;
        /** Значение по умолчанию для свойства {@link ISortableProps.forceHelperSize} */
        static readonly DEFAULT_FORCE_HELPER_SIZE: boolean;
        /** Значение по умолчанию для свойства {@link ISortableProps.forcePlaceholderSize} */
        static readonly DEFAULT_FORCE_PLACEHOLDER_SIZE: boolean;
        /** Значение по умолчанию для свойства {@link ISortableProps.handle} */
        static readonly DEFAULT_HANDLE: boolean;
        /** Значение по умолчанию для свойства {@link ISortableProps.opacity} */
        static readonly DEFAULT_OPACITY: number;
        /** Значение по умолчанию для свойства {@link ISortableProps.scroll} */
        static readonly DEFAULT_SCROLL: boolean;
        /** Значение по умолчанию для свойства {@link ISortableProps.scrollSensitivity} */
        static readonly DEFAULT_SCROLL_SENSITIVITY: number;
        /** Значение по умолчанию для свойства {@link ISortableProps.scrollSpeed} */
        static readonly DEFAULT_SCROLL_SPEED: number;
        /** Значение по умолчанию для свойства {@link ISortableProps.tolerance} */
        static readonly DEFAULT_TOLERANCE: string;
        /** Значение по умолчанию для свойства {@link ISortableProps.zIndex} */
        static readonly DEFAULT_ZINDEX: number;
        /** @internal */
        componentDidMount(): void;
        /** @internal */
        componentWillReceiveProps(nextProps: ISortableProps): void;
        /** @internal */
        componentWillUnmount(): void;
        /** @internal */
        componentWillUpdate(nextProps: ISortableProps): void;
        /** @internal */
        componentDidUpdate(): void;
        /**
         * Эквивалентны ли списки элементов SortableItem
         * @param items1 Первый список
         * @param items2 Второй список
         * @returns Равны или нет
         */
        protected isItemsEqual(items1: ISortableItem<any>[], items2: ISortableItem<any>[]): boolean;
        /**
         * Заставляет пересчитать размер this.props.containment
         */
        protected updateContainmentSize(): void;
        /**
         * Получить опции для плагина
         * @param props Свойства компонента
         */
        protected getSortablePluginOptions(props: ISortableProps): {
            axis: "y" | "x";
            containment: string | HTMLElement | JQuery;
            cursor: string;
            disabled: boolean;
            forceHelperSize: boolean;
            forcePlaceholderSize: boolean;
            handle: string | boolean;
            opacity: number;
            scroll: boolean;
            scrollSensitivity: number;
            scrollSpeed: number;
            tolerance: "pointer" | "intersect";
            zIndex: number;
        };
        /**
         * Сортирует элементы по порядку
         * @param items Элементы
         * @param order Идентификаторы элементов, отсортированные в нужном порядке
         */
        protected sortItems(items: ISortableItem<any>[], order?: string[]): ISortableItem<any>[];
        /**
         * Возвращает отсортированных потомков
         */
        protected getChildren(): JSX.Element[];
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    namespace SvgIcons {
        /** Свойства для {@link RightArrowIcon} */
        interface LinksLoaderProps {
            className?: string;
            title?: string;
            nativeTitle?: string;
            wrapperClassName?: string;
            width: number;
            cropSvg?: boolean;
            useSvgAnimation?: boolean;
        }
        /**
         * Анимированная картинка-заглушка, показываемая во время загрузки заданий.
         */
        const LinksLoaderImage: (props: LinksLoaderProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace SvgIcons {
        /** @internal */
        const LoaderAdmimatedSvgGradient = "\n            <defs>\n                <linearGradient id=\"bouncy-gradient\" gradientTransform=\"rotate(0)\">\n                    <stop offset=\"0\" stop-color=\"#ddd\"></stop>\n           \n                    <stop offset=\"0\" stop-color=\"#fff\">\n                        <animate attributeName=\"offset\" dur=\"1s\" values=\"-.3;1;1\" repeatCount=\"indefinite\" />\n                    </stop>\n                    <stop offset=\"100\" stop-color=\"#ddd\">\n                        <animate attributeName=\"offset\" dur=\"1s\" values=\"1;1;0\" repeatCount=\"indefinite\" />\n                    </stop>\n                </linearGradient>\n            </defs>\n        ";
    }
}
declare namespace WebClient {
    namespace SvgIcons {
        /** Свойства для {@link RightArrowIcon} */
        interface IRightArrowIconProps {
            width?: string;
            height?: string;
            color?: string;
            tabIndex?: number;
            onClick?: (event: React.MouseEvent<any>) => void;
            className?: string;
            title?: string;
            nativeTitle?: string;
            /** Отображаемый элемент. */
            el?: string | React.Component;
        }
        /**
         * Иконка стрелочки вправо.
         */
        const RightArrowIcon: (props: IRightArrowIconProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace SvgIcons {
        /** Свойства для {@link SvgWrapper} */
        interface ISvgWrapperProps {
            /** SVG для отображения. */
            svg: string;
            /** TabIndex для навигации по tab. */
            tabIndex?: number;
            /** Отображаемый элемент. */
            el?: string | React.Component;
            /** Вызывается при клике. */
            onClick?: (event: React.MouseEvent<any>) => void;
            /** CSS класс со стилями. */
            className?: string;
            /** Всплывающая подсказка через плагин */
            title?: string;
            /** Всплывающая подсказка через атрибут "title" */
            nativeTitle?: string;
        }
        /**
         * Обёртка для отображения <svg> на странице.
         *
         * Пример использования:
         *
         *     <SvgWrapper className={classIfDefined(props.className)} tabIndex={props.tabIndex} onClick={props.onClick}
         *         title={props.title} nativeTitle={props.nativeTitle}
         *         svg={`
         *             <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
         *                 ...
         *             </svg>
         *         `} />
         */
        const SvgWrapper: (props: ISvgWrapperProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace SvgIcons {
        /** Свойства для {@link RightArrowIcon} */
        interface TasksDigesLoaderProps {
            className?: string;
            title?: string;
            nativeTitle?: string;
            wrapperClassName?: string;
            width: number;
            useSvgAnimation: boolean;
        }
        /**
         * Анимированная картинка-заглушка, показываемая во время загрузки заданий.
         */
        const TasksDigestLoaderImage: (props: TasksDigesLoaderProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace SvgIcons {
        /** Свойства для {@link RightArrowIcon} */
        interface TasksFullLoaderProps {
            className?: string;
            wrapperClassName?: string;
            title?: string;
            nativeTitle?: string;
            useSvgAnimation: boolean;
        }
        /**
         * Анимированная картинка-заглушка, показываемая во время загрузки заданий.
         */
        const TasksFullLoaderImage: (props: TasksFullLoaderProps) => JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITableHelperProps {
        mode: TableHelperMode;
        className?: string;
        /** Children tags, created by TableRow, TableHeaderRow */
        children?: React.ReactNode;
        /** Should row to be higlighted on hover. Default value: false */
        notHighlightOnHover?: boolean;
    }
    /** @internal */
    interface ITableHelperBodyProps {
        className?: string;
        /** Children tags, created by TableRow, TableHeaderRow */
        children?: React.ReactNode;
    }
    /** @internal */
    enum TableHelperMode {
        /** Use flex-box for layout. Width should be provided for all cells */
        Blocks = 0,
        /** Use display: table. */
        Table = 1,
    }
    /** @internal */
    const TableHelper: (props: ITableHelperProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface ITableHelperHeaderRowProps {
        className?: string;
        /** Children tags, created by TableRowCell */
        children?: React.ReactNode;
        /** Show header row only on hover. Default value: false */
        showOnHover?: boolean;
        key?: string;
        /** Value of data-row-name attribute for autotesting purposes */
        name?: string;
    }
    /** @internal */
    interface ITableHeaderCellHelperProps {
        /** Width in percent, pixel, as css calc() etc. */
        width?: string;
        className?: string;
        /** React.ReactNode that repersents cell content */
        children?: React.ReactNode;
        key: string;
        /** Tooltip */
        title?: string;
    }
    /** @internal */
    const TableHelperHeaderRow: (props: ITableHelperHeaderRowProps) => JSX.Element;
    /** @internal */
    const TableHelperHeaderCell: (props: ITableHeaderCellHelperProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface ITableRowHelperProps {
        className?: string;
        /** Children tags, created by TableRowCell */
        children?: React.ReactNode;
        /** Highlight row as selected. Default value: false */
        selected?: boolean;
        /** Fix row height to 50px. Default value: true */
        standardHeight?: boolean;
        key?: string;
        /** Value of data-row-name attribute for autotesting purposes */
        name?: string;
    }
    /** @internal */
    interface ITableRowCellHelperProps {
        /** Width in percent, pixel, as css calc() etc. */
        width?: string;
        className?: string;
        /** React.ReactNode that repersents cell content */
        children?: React.ReactNode;
        key: string;
    }
    /** @internal */
    const TableHelperRow: (props: ITableRowHelperProps) => JSX.Element;
    /** @internal */
    const TableHelperCell: (props: ITableRowCellHelperProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface ITreeBaseProps<TreeNodeDataT extends ITreeNodeData> {
        data?: TreeNodeDataT[];
        levelIdent?: string;
        expandedToggleMarkerClass?: string;
        collapsedToggleMarkerClass?: string;
        multiSelect?: boolean;
        className?: string;
        toggleOnDisabledNodesClick?: boolean;
        expandedByDefault?: boolean;
        /** Callback function, that called, when node selected */
        nodeSelected?: (node: TreeNode) => void;
        /** Callback function, that called, when node selected with double-click or enter. */
        nodeAccepted?: (node: TreeNode) => void;
        /** How virtual nodes will be processed. By default: Vairable */
        virtualizationType?: VirtualizationType;
        /** Callack function, that called when user press down/up arrows, and focus reached top or bottom of the node list. */
        focusOut?: (directionUp: boolean) => void;
        treeHeight: number;
    }
    /** See ReactList for help */
    enum VirtualizationType {
        Simple = 0,
        /** All rows has one height */
        Uniform = 1,
        /** Rows can have variadic height */
        Variable = 2,
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITreeBaseState {
        nodes: TreeNode[];
        selectedNodes: TreeNode[];
        count: number;
        focusedNode: TreeNode;
    }
}
declare namespace WebClient {
    /** @internal */
    class Tree extends TreeBase<ITreeNodeData, ITreeBaseProps<ITreeNodeData>, ITreeBaseState> {
        constructor(props: ITreeBaseProps<ITreeNodeData>);
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITypeaheadProps {
        /** Curreint input value. */
        searchText: string;
        /** Event, that translate input key down events */
        inputKeyDown: BasicEvent<React.KeyboardEvent<any>>;
        /** Function, that send search request to the server. */
        findItems: (query: ITypeaheadSearchQuery) => JQueryDeferred<ITypeaheadSearchResult>;
        /** User selected some variant. */
        onSelected: (selectedVariant: ITypeaheadVariant) => void;
        /** Makes control readonly */
        disabled?: boolean;
        /** Callback function, that should focus input. */
        focusInput?: Function;
        /** How many symbols should user enter, before search request will be sent. Default value: 3 */
        searchIndex?: number;
        /** How often should send search requests, while user entereing text. Time interval in ms. Default value: 500ms. */
        searchTimeout?: number;
        /** Count of items shown, before 'show more' clicked. Default value: 8 */
        firstPageSize?: number;
        /** Count of items, loaded when user clicked 'show more' button. Default value 15 */
        nextPageSize?: number;
        /** Show clear button, or not. Default value: true */
        clearButton?: boolean;
        /** Show 'show variants' button, or not. Default value: false */
        showVariantsButton?: boolean;
        /** Custom class for show variants button. Default value: dv-ico ico-arrow-down */
        showVariantsButtonIconClass?: string;
        /** Special text, that will be sent in search query when requested all available results. Default value: null */
        showAllSearchText?: string;
        /** Should send special text in search query when requested all available results (for example, down arrow keydown). Default value: false */
        showAllEnabled?: boolean;
        /** How loading queries should be performed. Default value: LoadOnlyNewItems */
        paginatorLoadLogic?: PaginatorLoadLogic;
        /** Some extra buttons info, that would be showed at the right side of the control */
        extraButtons?: IBoxWithButtonsButtonInfo[];
        /** Show buttons inside the box with absolute positioning. Defautl value: false */
        buttonsInside?: boolean;
        /** Tooltip */
        title?: string;
        /** Custom class for the control */
        className?: string;
        /** Custom class for the popover panel (wich is outside of the DOM). */
        popoverClassName?: string;
        /** Custom attributes for the popover panel (wich is outside of the DOM). */
        popoverAttributes?: Object;
        /** Control name, for the autotesting purposes */
        name?: string;
        /** External state for autorefresh cached data */
        externalState?: any;
        /** Called on open/close dropdown. */
        onDropdownStateChanged?: (sender: Typeahead) => void;
    }
    enum PaginatorLoadLogic {
        LoadOnlyNewItems = 0,
        LoadAllItems = 1,
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITypeaheadState {
        requestHelper: RequestHelper;
        variantsDropdownOpen: boolean;
        variants: TypeaheadItem[];
        hasMore: boolean;
        page: number;
        searchTimerHandle: number;
        loadingNextPage: boolean;
        focusedItem: TypeaheadItem;
        focusedShowMore: boolean;
        dropdownElem: HTMLElement;
        lastKeyDownProcessed: boolean;
        mounted: boolean;
        lastSearchPage: number;
        lastSearchText: string;
        lastExternalState: any;
        lastSearchResult: ITypeaheadSearchResult;
    }
}
declare namespace WebClient {
    /** @internal */
    class Typeahead extends React.Component<ITypeaheadProps, ITypeaheadState> {
        static FirstPageSize: number;
        static NextPageSize: number;
        static SearchTimeout: number;
        constructor(props: ITypeaheadProps);
        componentWillUnmount(): void;
        componentDidMount(): void;
        closeDropdown(): void;
        openDropdown(): void;
        variantsDropdownOpen: boolean;
        readonly variants: TypeaheadItem[];
        showAll(): void;
        protected onShowAll(): void;
        protected onClearValueClick(): void;
        componentWillReceiveProps(nextProps: ITypeaheadProps, nextContext: any): void;
        protected getTextValue(): string;
        protected getFirstPageSize(): number;
        protected getNextPageSize(): number;
        protected getSearchIndex(): number;
        protected createItem(data: ITypeaheadVariant): TypeaheadItem;
        protected onSelected(item: TypeaheadItem): void;
        protected select(item: TypeaheadItem): void;
        protected loadVariants(searchText: string, page: number): JQueryDeferred<ITypeaheadSearchResult>;
        protected readonly searchTimeout: number;
        protected onInputChange(newText: string): void;
        private documentClick(ev);
        protected onShowMore(): JQueryDeferred<ITypeaheadSearchResult>;
        protected onShowVariants(): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected onItemClick(ev: React.MouseEvent<any>, item: TypeaheadItem): void;
        /** Contains logic for keyboard navigation */
        protected onDropdownKeydown(ev: React.KeyboardEvent<any>): void;
        private rednerVariantText(item);
        protected renderVariant(x: TypeaheadItem): JSX.Element;
        protected attachDropdown(elem: HTMLElement): void;
        protected getFavoredVariants(): TypeaheadItem[];
        protected getUsualVariants(): TypeaheadItem[];
        protected getButtons(): IBoxWithButtonsButtonInfo[];
        render(): React.ReactNode;
    }
}
declare namespace WebClient {
    /** @internal */
    class AgreementSidebar {
        private static TemplateContentClassName;
        private static AgreementBtnClassName;
        private static CancelBtnClassName;
        private static TemplateSelectClassName;
        private traceProvider;
        private callbacks;
        private agreementStarted;
        SelectingCallbackFunc: (employeeData: IEmployeeItemData) => JQueryDeferred<any>;
        SelectedCallbackFunc: (employeeData: IEmployeeItemData) => void;
        DeletingCallbackFunc: (employeeId: string) => JQueryDeferred<any>;
        DeletedCallbackFunc: (employeeId: string) => void;
        private static SecondStepId;
        private static TemplateSpanId;
        private static SubmitBtnId;
        private rootElement;
        private agreementBtn;
        private templateSelect;
        private templateSpan;
        private sidebarElement;
        private templateContent;
        private submitBtn;
        private sidebar;
        private readonly SelectedTemplate;
        constructor(root: HTMLElement, callbacks?: IAgreementSidebarCallbacks);
        OpenSidebar(): void;
        private Init();
        private LoadTemplateContent();
        private ShowCreateBtn();
        private ParseAgreementParams(formData);
        private SubmitForm();
        private ValidateControls();
    }
}
declare namespace WebClient {
    /** @internal */
    class DocumentPanel {
        private static FileSettingsCssClass;
        private static FileLinkCssClass;
        private static FileDocumentLinkCssClass;
        private static DocumentUnLinkCssClass;
        private static FileIconCssClass;
        private static AdditionalFileCssClass;
        private static FileOperationCssClass;
        private static VersionCommentCssClass;
        private static Placeholder;
        private documentPanel;
        private cardId;
        private downloadContentUrl;
        private currentSettings;
        private traceProvider;
        constructor(documentPanelId: string, downloadContentUrl: string);
        private Initialize();
        private initFilesHandlers();
        private readonly GetDocumentItems;
        private FileOperationWithoutDialog(item);
        private AddFileCommentEventHandler(item);
        private SettingEventHandler(documentItem);
        private DetachDocumentFromTask(documentItem);
        private ShowFileSettingsEventClick(item);
        private ShowFileSettings(item, show?);
        private WrapperEventHandler();
        private SuppressEvents(e);
        private PreviewFileEventHandler(item);
        private FileDocumentEventHandler(item);
    }
}
declare namespace WebClient {
    /** @internal */
    class FilePanel {
        private static FileVersionCssClass;
        private static FileSettingsCssClass;
        private static CommandExpandCssClass;
        private static CommandBarCssClass;
        private static FileDeleteOperationCssClass;
        private static FileOperationCssClass;
        private static FileLinkCssClass;
        private static VersionCommentCssClass;
        private static FileOpenCssClass;
        private fileSign;
        private filePanel;
        private selectedElement;
        private currentCommandBar;
        private currentSettings;
        private traceProvider;
        constructor(filePanelId: string);
        private Initialize();
        private PreviewFileEventHandler(item);
        private VersionEventHandler(fileItem);
        private SettingEventHandler(fileItem);
        private ToggleCommandBar(selectedCommandBar?);
        private ClearAllAnimation(commands);
        private CommandExpandEventHandler(item);
        private readonly GetFileItems;
        private SelectEventClick(item);
        private ShowVersions(item, show?);
        private RestoreVersionsExpandedInfo();
        private StoreVersionsExpandedInfo(item, show, append);
        private ResetVersionsExpandedInfo();
        private GetVersionsExpandedInfo();
        private SaveVersionsExpandedInfo(data);
        private GetLocalStorageId();
        private ShowFileSettingsEventClick(item);
        private ShowFileSettings(item, show?);
        private DeleteFileEventHandler(item);
        private FileOperationWithoutDialog(item);
        private AddFileCommentEventHandler(item);
        private WrapperEventHandler();
        private OpenEventHandler(item);
        private SuppressEvents(e);
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderTree {
        static DefaultContainerClassName: string;
        protected TreeContainerClassName: string;
        protected url: string;
        protected ExpandFolderFunction: Function;
        protected OpenFolderFunction: Function;
        protected AfterFolderSelect: Function;
        protected ExludeSearchParamFoldes: boolean;
        private lastSelectedFolder;
        constructor();
        protected SelectTreeFolder(element: HTMLElement, expand: boolean): void;
        protected UnselectTreeFolder(element: HTMLElement): void;
        protected TreeFolderSelected(element: HTMLElement): Boolean;
        protected ExpandFolder(element: HTMLElement): void;
        protected LoadData(requestData: any, callback: Function): void;
        protected ClearSelectedFolders(): void;
        protected GetSelectedFolders(): NodeListOf<Element>;
        protected GetAllVisibleFolders(): NodeListOf<Element>;
        protected AddExpandFolderButtonEventClick(elements: NodeListOf<Element>): void;
        protected AddOpenFolderButtonEventClick(elements: NodeListOf<Element>): void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAgreementSidebarCallbacks {
        approvingPathChanging: (newAgreementTemplateId: string, newAgreementTemplateDisplayName: string) => JQueryDeferred<any>;
        approverAdding: (selectingEmployeeData: IEmployeeItemData) => JQueryDeferred<any>;
        approverDeleting: (deletingEmployeeId: string) => JQueryDeferred<any>;
        approvingStartCancelling: () => JQueryDeferred<any>;
        approvingStarting: (params: IAgreementParams) => JQueryDeferred<any>;
        approvingPanelOpening: () => JQueryDeferred<any>;
        approvingPathChanged: (agreementTemplateId: string, agreementTemplateDisplayName: string) => void;
        approverAdded: (addedEmployeeId: IEmployeeItemData) => void;
        approverDeleted: (deletedEmployeeId: string) => void;
        approvingStartCancelled: () => void;
        approvingPanelOpened: () => void;
    }
}
declare namespace WebClient {
    /** @internal */
    class LinkControl {
        private linkControl;
        private static DeleteLinkCssClass;
        private static AddExistingCardCssClass;
        private static AddNewFileCssClass;
        private static AddNewCardCssClass;
        private static SelectCardDlgClass;
        private static SelectCardDlgWidth;
        private static FileLinkCssClass;
        private static Placeholder;
        private cardId;
        private isReportMode;
        private selectCardModal;
        private traceProvider;
        BeforeAddNewCardFunc: Function;
        BeforeAddExistedCardFunc: Function;
        static CommandExpandCssClass: string;
        constructor(rootElementId: string);
        IsReportMode: boolean;
        AddFileLink(documentIds: any): void;
        private Init();
        private initFilesHandlers();
        private InitAttachFileLink();
        private CommandAddExistingCard(item);
        private CommandAddNewCard(item);
        protected GetLayoutCardCreateLink(cardId: string, timestamp: string, cardTypeId: string, kindId: string): string;
        private AttachLink(url, formData, onSuccess);
        private CommandDeleteLink(item);
        private DeleteLink(url);
        private RefreshLinks(response?);
        private CommandExpandEventHandler(item);
        private PreviewFileEventHandler(item);
    }
    class FolderTreeElement extends FolderTree {
        constructor();
        AfterOpenFolderFunction: Function;
        private AddOpenOverride(elements);
        LoadTreeToContainer(container: HTMLElement): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class RightSidebar {
        rootElement: HTMLElement;
        private closeButton;
        private content;
        private overlay;
        private useOverlay;
        private destroyOnClose;
        private title;
        private onCloseCallback;
        private onClosingCallback;
        constructor(title?: string);
        OnCloseCallback: Function;
        OnClosingCallback: () => JQueryDeferred<any>;
        UseOverlay: boolean;
        DestroyOnClose: boolean;
        Content: string;
        readonly IsOpened: boolean;
        AppendToContent(element: HTMLElement): void;
        SetClassName(className: string): void;
        Open(callback?: Function): void;
        Close(): void;
        private Initialize();
    }
}
declare namespace WebClient {
    /** @internal */
    class SearchDropdown {
        private dropdown;
        private optionList;
        private options;
        private selectedText;
        private selectedElement;
        private selectedValue;
        private callback;
        private DROP_DOWN_ICO;
        constructor(dropdown: HTMLElement, callback: (oldVal?: GenModels.SearchContextOption, newVal?: GenModels.SearchContextOption) => void);
        UpdateDropDownVisibility(): void;
        ShowOptions(selectedOption: string, displayOptions?: Array<GenModels.SearchContextOption>): void;
        Hide(): void;
        readonly SearchContext: string;
        readonly Element: HTMLElement;
        private Initialize();
        Show(): void;
        private AddDropdownMissClickEvent();
        private AddDropdownClickEvent();
        private AddOptionListClickEvent();
        private UpdateSelectedOption();
    }
}
declare namespace WebClient {
    /** @internal */
    class SelectCardLinkDialog {
        private selectCardModal;
        private container;
        private searchInput;
        private sourceCardId;
        private selectedFolder;
        private loader;
        private nextPageLoader;
        private cardsScrollContainer;
        private cardsTableItemsContainer;
        private allowedCardTypesField;
        private wrapRows;
        private sortingColumnName;
        private sortDescending;
        private searchMode;
        private currentPageNumber;
        private lastQueryTimestamp;
        private columnHeaders;
        private modalClosed;
        private requestFinished;
        constructor();
        private readonly firstPage;
        allowedCardTypes: string[];
        ShowDialog(sourceCardId: string, allowedLinkTypes: string[], okCallback: (window: ModalWindow) => void, shownCallback?: (window: ModalWindow) => void, closingCallback?: () => JQueryDeferred<any>, closeCallback?: () => void): void;
        private InitDialog();
        private UpdateShortcuts(resetPageIndex);
        private InitCardRow(item);
        private ButtonOkEnabled;
        private LoadFolder(folder, resetPageIndex);
        private LoadSearch(resetPageIndex);
        private GetServerResults(folderRoot);
        private LoaderLogic();
        private GetResultsFromServer(data);
        private ClearCardsTableItems();
        private SetSorting(colName, descending, loadRows?);
        private SetRowWrapMode(wrap, compactRowsSwitch, wrapRowsSwitch);
        private OnSearchInputKeyDown(ev);
        private onCardsScroll(ev);
    }
}
declare namespace WebClient {
    /** @internal */
    class SelectFolderModalDialog extends FolderTree {
        private static DialogContainerClassName;
        private onClose;
        private dialog;
        constructor(onClose?: (folders: string[]) => void);
        ShowDialog(): void;
        private AttachFolder();
        protected ClearSelectedFolders(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    type DocumentKindSelectedCallback = (window: ModalWindow, cardTypeId: string, kindId: string) => void;
    /** @internal */
    class SelectNewDocumentDialog {
        private createDocumentModal;
        private container;
        private selectedNode;
        private dialogOkButton;
        private ExpadedToggleMarkerClass;
        private CollapsedToggleMarkerClass;
        constructor();
        readonly SelectedKindId: string;
        readonly SelectedCardTypeId: string;
        ShowDialog(title: string, okCallback: DocumentKindSelectedCallback, shownCallback?: (window: ModalWindow) => void, closedCallback?: Function): void;
        private InitDialog();
        private onOkButtonClick(callback);
        private selectNode(node);
    }
}
declare namespace WebClient {
    /** @internal */
    class SelectUserFolderModalDialog extends FolderTree {
        private dialog;
        private rootElement;
        private input;
        private button;
        private clearBtn;
        constructor(element: HTMLElement);
        private Initialize();
        ShowDialog(): void;
        private SelectFolder();
        private UpdateFolder();
        private AddExpandOverride(elements);
        private AddOpenOverride(elements);
        private AddShowDialogButtonEventClick();
        private AddClearButtonEventClick();
    }
}
declare namespace WebClient {
    /** Тип параметра, содержащего событие контрола. */
    type BasicApiEvent<T> = IBasicEvent<T> | (Partial<IBasicEvent<T>> & BasicEventHandler<T>);
    /** Тип параметра, содержащего отменяемое событие контрола. */
    type CancelableApiEvent<T> = ICancelableEvent<T> | (Partial<ICancelableEvent<T>> & BasicEventHandler<T>);
}
declare namespace WebClient {
    /** Отменяемое событие. */
    class CancelableEvent<T> extends BasicEvent<ICancelableEventArgs<T>> {
        private deferred;
        constructor(sender?: any, subscribers?: {
            (sender: any, args?: ICancelableEventArgs<T>): void;
        }[]);
        /** @internal */
        protected triggerAll(sender?: any, data?: ICancelableEventArgs<T>): void;
        /** Уведомляет подписчиков о событии с передачей объекта {@link ICancelableEventArgs}.  */
        triggerWithArgs(sender: any, argsP: ICancelableEventArgs<T>): void;
        /** Уведомляет подписчиков о событии с передачей данных и отправителя. */
        triggerWith(sender: any, data?: T): CancelableEventArgs<T>;
        /** Уведомляет подписчиков о событии с передачей данных и отправителя, указанного при создании события. */
        trigger(data?: T): CancelableEventArgs<T>;
        /** Конструирует объект параметров. */
        createArgs(data?: T): CancelableEventArgs<T>;
        /** Преобразует тип события к {@link CancelableEvent}. */
        static cast<T>(event: ICancelableEvent<T> | CancelableApiEvent<T> | string): CancelableEvent<T> & BasicEventHandler<T>;
        /** Создает экземпляр {@link CancelableEvent}. */
        static Create<T>(sender: any, subscriberFunc?: CancelableApiEvent<T> | string): CancelableEvent<T> & BasicEventHandler<T>;
    }
}
declare namespace WebClient {
    /**
     * Представляет собой событие для действий, подписчики которого могут его отменить.
     * Заметка: подписчики события могут выполнять долговременные асинхронные операции перед продолжением или отменой действий событий.
     * Пример использования:
     *
     *    this.cardOpening = CancelableEvent.Create(this.state.wrapper);
     *    ...
     *    this.cardOpening.trigger({
     *      cardModel: model
     *    })
     *    .canceled(this.back)
     *    .accepted(() => callback(model));
     *
     * Заметка: подписчики события должны использовать только интерфейс ICancelableEventArgs<T> публичного API,
     * поскольку интерфейс CancelableEventArgs<T> только для внутреннего использования инициаторов событий.
     */
    class CancelableEventArgs<T> implements ICancelableEventArgs<T> {
        private dataField;
        private deferredObj;
        private autoAcceptSetting;
        /**
         * Создаёт экземпляр CancelableEventArgs<T>
         * @param data данные события
         * @param callbackAccepted смотрите метод {@link accepted}
         * @param callbackCanceled смотрите метод {@link canceled}
         */
        constructor(data?: T, callbackAccepted?: (data?: T) => void, callbackCanceled?: (data?: T) => void);
        /**
         * Коллбэк, который будет вызван, если подписчики события разрешили продолжить выполнение действий
         */
        accepted(callback: (data?: T) => void): CancelableEventArgs<T>;
        /**
         * Коллбэк, который будет вызван, если подписчики события отменили выполнение действий
         */
        canceled(callback: (data?: T) => void): CancelableEventArgs<T>;
        /**
         * См. {@link ICancelableEventArgs<T>.cancel}
         */
        cancel(): void;
        /**
         * См. {@link ICancelableEventArgs<T>.accept}
         */
        accept(): void;
        /**
         * См. {@link ICancelableEventArgs<T>.wait}
         */
        wait(): void;
        /**
         * См. {@link ICancelableEventArgs<T>.data}
         */
        readonly data: T;
        /**
         * См. {@link ICancelableEventArgs<T>.autoAcceptEnabled}
         */
        /**
         * См. {@link ICancelableEventArgs<T>.autoAcceptEnabled}
         */
        autoAcceptEnabled: boolean;
        /**
         * Возвращает текущее состояние объекта события.
         * Состояние может изменяться вызовом методов accept() или cancel() (они обычно используются подписчиками событий)
         * См. также: autoAcceptEnabled
         */
        readonly state: CancelableEventState;
        readonly deferred: JQueryDeferred<T>;
        /** @deprecated */
        private readonly deffered;
    }
}
declare namespace WebClient {
    /** Состояние отменяемого события. */
    enum CancelableEventState {
        /** В процессе вызова обработчиков. */
        Pending = 0,
        /** Событие одобрено. */
        Accepted = 1,
        /** Событие отменено. */
        Canceled = 2,
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderViews {
        private selectViewBtnId;
        private viewsContainerId;
        private selectViewListId;
        private folderId;
        private viewSourceId;
        private searchId;
        private currentViewId;
        private currentViewName;
        private views;
        private viewFolderId;
        private isListOpened;
        private traceProvider;
        private readonly SelectViewBtn;
        private readonly SelectViewList;
        private readonly SelectViewContainer;
        constructor(viewsContainerId: string, selectViewsBtnId: string, selectViewListId: string);
        readonly HasViews: boolean;
        Build(folderId: string, viewSourceId: string, searchId: string, currentViewId?: string, currentViewName?: string): void;
        Destroy(): void;
        private Initialize();
        private BuildViewsList();
        private static GetViewsListForFolder(folderId);
        private SetCurrentView(currentView);
        private selectView(element);
        private checkExternalClick(e);
    }
    /** @internal */
    type $FolderViews = {
        folderViews: FolderViews;
    };
}
declare namespace WebClient {
    /** @internal */
    enum ColumnType {
        Int = 0,
        String = 1,
        Double = 2,
        DateTime = 3,
        Image = 4,
        Boolean = 5,
        Html = 6,
    }
}
declare namespace WebClient {
    /** @internal */
    const filterSidePanel: (host: ModalHost, applyFunc: (host: ModalHost) => void, gridFilter: string) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    enum FormFactor {
        Desktop = 1,
        Mobile = 2,
    }
}
declare namespace WebClient {
    /** @internal */
    class GridOptions {
        tableClass: string;
        wrapRow: boolean;
        currentPage: number;
        enablePaging: boolean;
        enableSorting: boolean;
        enableGrouping: boolean;
        enableFiltering: boolean;
        enableItemDetails: boolean;
        enableMobileFormat: boolean;
        isMobileFormat: boolean;
        currentMobilePage: number;
        urlGetItemsList: string;
        urlGetItemsListSilent: string;
        cardSourceId: string;
        folderId: string;
        searchFilter: string;
        folderHeader: string;
        dataLoader: (requestData: any, isMobile: boolean) => JQueryDeferred<any>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IGridHtmlBuilder {
        getModel: () => any;
        refreshed: SimpleEvent<void>;
        modelChanged: SimpleEvent<any>;
        buildTableBody(options: GridOptions, tableBodyContainer: HTMLElement, callback?: (model: any) => void): void;
        buildTableHeader(options: GridOptions, tableHeaderContainer: HTMLElement, callback?: (model: any) => void): void;
        buildGridFooter(options: GridOptions, gridFooterContainer: HTMLElement, callback?: (model: any) => void): void;
        buildFilters(options: GridOptions): void;
        buildMobileGrid(options: GridOptions, rootElement: HTMLElement): void;
        applyGridFilter(): void;
        buildHeader(options: GridOptions, targetElement: HTMLElement, rootElement: HTMLElement): any;
        getChanges(): Promise<any>;
        showUpdateRequest(show: boolean): any;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ISortingColumn {
        Name: string;
        isDesc: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class MainCardGridHtmlBuilder implements IGridHtmlBuilder {
        private folderId;
        private viewId;
        private allowRowResize;
        private pageSize;
        private dateMinWidth;
        private tableHeaderContainer;
        private tableBodyContainer;
        private gridFooterContainer;
        private mobileGridContainer;
        private refreshButton;
        private loader;
        private filterLoader;
        private rootElement;
        private options;
        private selectedCards;
        private colspanValue;
        private groupColumnList;
        private employeeId;
        private cardShowLink;
        private popupNotification;
        /** getModel property is getting overrided by parent grid class */
        getModel: () => GenModels.GridViewModel;
        refreshed: SimpleEvent<void>;
        modelChanged: SimpleEvent<any>;
        filterLayout: GenModels.LayoutViewModel;
        static RowDefaultHeight: string;
        static DefaultForeColor: string;
        static DefaultBackColor: string;
        static FilterSettingsName: string;
        private traceProvider;
        private services;
        constructor();
        buildMobileGrid(options: GridOptions, rootElement: HTMLElement): void;
        getCurrentPage(): number | null;
        private AddDisclosureEvent(arrow, content);
        private AddShowCardMobileEvent(rowEl);
        private destroyMobileGrid();
        private destroyGrid();
        private buildMobilePaging();
        private destroyMobilePaging();
        private AddLoadMoreClick(element);
        private AddPage(model);
        private countNotClosable(model, i, createRowElement?);
        buildTableHeader(options: GridOptions, tableHeaderContainer: HTMLElement, callback?: (model: GenModels.GridViewModel) => void): void;
        private shouldBuildHeader(columns, headerElements);
        private getColumnMinWidth(column, headerCell);
        private getColumnWidth(column, isEven, visibleColumsCount);
        /**
         * Равномерна ли ширина столбцов
         */
        private areColumnsEven(columns);
        private removeLoader();
        private addLoader();
        private removeFilterLoader(rowSwitcher);
        private addFilterLoader(rowSwitcher);
        buildTableBody(options: GridOptions, tableBodyContainer: HTMLElement, callback?: (model: GenModels.GridViewModel) => void): void;
        buildHeader(options: GridOptions, targetElement: HTMLElement, rootElement: HTMLElement): void;
        private saveFolderSettings();
        private buildRow(model, i);
        private buildColumn(model, itemRow, i, j);
        private isGroupColumn;
        private createEmptyTableRow();
        private buildSwitcher(compact, wrap, model, rootElement);
        buildGridFooter(options: GridOptions, gridFooterContainer: HTMLElement, callback?: (model: GenModels.GridViewModel) => void): void;
        static destroyFilters(): void;
        buildFilters(options: GridOptions): void;
        private checkExternalClick(e);
        private updateFilters(element, title);
        applyGridFilter(): void;
        private getDateMinWidth();
        private initHeaderCell(cell);
        private getDataFromServer(params, callback, isMobile?, silent?);
        private desktopCallback;
        private getSelectedFiltersData();
        private getValueByKey(gridItem, key, itemType?);
        private getSortedModel(model, sortingColumnName, isDescending, columnType?);
        private divide(values, groupingColumnName, columnType);
        private getGroups(group, columnNames, columns, level?);
        private buildGroupingBody(body, groups, colspanValue, visibleStringGroupIDs?, groupId?, groupLevelIndent?, groupNamesChain?, isOpen?, groupStorage?);
        private buildGroupingColumns(body, itemRow, groups, i);
        private updateGroupCSS(groupingTd, groupingImg, groupingRow, {marginLeft, localOpen});
        private createGroupRow(model, groups, body, isOpen, groupId, i);
        private initGroupingElement(element);
        private dotDotDotInit();
        private updateHtmlRowReadStatus(itemID, setRead);
        private iniItemSelector(element, itemID);
        private buildPageNavigator(pageCount, currentPage, itemCount, model);
        private initPageLink(element);
        private activateOneStep(element, isNext);
        private activateCounter(element, pageCount);
        private getPageData(pageNumber, instanceId, model, cb, silent?);
        private getParams();
        private getPage(pageNumber, refresh?);
        getChanges(): Promise<GenModels.GridViewModel>;
        private getSortingColumn();
        private saveGridState();
        private onRefresh();
        /**
         * Визуальное уведомление о необходимости обновить грид
         */
        showUpdateRequest(show?: boolean): void;
        private initRowClick(cardID, element);
    }
}
declare namespace WebClient {
    /** @deprecated Используйте {@link Helpers.ShowFileComments} */
    class CommentVersionDialog {
        FormActionUrl: string;
        DeleteUrl: string;
        AddCommentsEnabled: boolean;
        OnClosedCallback: (dialog: CommentVersionDialog) => void;
        CommentsChanged: boolean;
        ShowDialog(item: Element): void;
        ShowDialogEx(isPreview: string, cardId: string, fileCardId: string, timestamp: string, versionId: string, callbacks?: IFileCommentCallbacks): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class NavBar {
        private TabsMobileContainerId;
        private NavBarId;
        private NavBarButtonsId;
        private mode;
        private modeLock;
        SetMode(navBarMode: NavBarMode): void;
        GetMode(): NavBarMode;
        readonly ModeLocked: string;
        LockMode(lockComment: string): void;
        ReleaseModeLock(): void;
        AddMobileTabs(tabsElement: HTMLElement): void;
        HideBackButton(): void;
        ShowBackButton(): void;
        OnDashboardLoad(): void;
        OnGoToRoute(): void;
    }
    /** @internal */
    type $NavBar = {
        navBar: NavBar;
    };
}
declare namespace WebClient {
    /** @internal */
    enum NavBarMode {
        /** Default mode - Create and Back buttons, breadcrumb */
        NavButtons = 0,
        /** In mobile mode in nav bar showed search area (current folder, anywhere, etc.) */
        SearchMobile = 1,
        /** In mobile version in card view tabs (main, approoval history, history etc.) showed in nav bar. */
        TabsMobile = 2,
        /** See FolderViews class */
        SelectView = 3,
    }
}
declare namespace WebClient {
    /** @internal */
    class IncomingLocalStorageCommunicationChanel {
        private services;
        protected localStorageKey: string;
        protected chanelType: string;
        protected chanelId: string;
        protected receivedMessages: IRealTimeCommunicationMessage<any>[];
        protected _tabId: string;
        protected subscribers: {
            [messageType: string]: RealtimeSubscriber<any>[];
        };
        protected subscribersToAll: RealtimeSubscriber<any>[];
        protected serverMessageSubscribers: {
            [messageType: string]: RealtimeSubscriber<any>[];
        };
        protected lastMessage: Date;
        constructor(type: string, id: string, tabId: string, services: $LocalStorage & $CurrentEmployeeId);
        readonly tabId: string;
        enableStorageMonitoring(): void;
        disableStorageMonitoring(): void;
        readonly type: string;
        readonly id: string;
        subscribe<T>(messageType: string, callback: RealtimeSubscriber<T>): void;
        hasSubscribers(messageType: string): boolean;
        unsubscribe<T>(messageType: string, callback: RealtimeSubscriber<T>): void;
        subscribeToAll<T>(callback: RealtimeSubscriber<T>): void;
        unsubscribeFromAll<T>(callback: RealtimeSubscriber<T>): void;
        subscribeToServerMessages<T>(messageType: string, callback: RealtimeSubscriber<T>): void;
        unsubscribeFromServerMessages<T>(messageType: string, callback: RealtimeSubscriber<T>): void;
        processMessage<T>(item: IRealTimeCommunicationMessage<T>): void;
        lastActivity: Date;
        dispose(): void;
        removeStorageItem(): void;
        protected onStorageChanged: () => void;
        protected processIncomingMessage<T>(received: IRealTimeCommunicationMessage<T>): void;
        protected onReceivedMessage<T>(item: IRealTimeCommunicationMessage<T>, forServer: boolean): void;
        protected getQueue(): IRealTimeCommunicationMessage<any>[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface IRealtimeCommunicationHub {
        client: IRealtimeCommunicationHubClient;
        server: IRealtimeCommunicationHubServer;
    }
    /** @internal */
    interface IRealtimeCommunicationHubServer {
        register(employeeId: string, employeeAcccountName: string, sessionId: string): Promise<any>;
        sendMessage(message: IRealTimeCommunicationMessage<string>): Promise<any>;
    }
    /** @internal */
    interface IRealtimeCommunicationHubClient {
        sendMessage<T>(message: IRealTimeCommunicationMessage<T>): any;
    }
}
declare namespace WebClient {
    /** Сообщение обмена данными с сервером и между вкладками в режиме реального времени. */
    interface IRealTimeCommunicationMessage<T> {
        /** Данные сообщения. */
        Data?: T;
        /** Уникальный идентификатор типа сообщения. */
        MessageType: string;
        /** Уникальный идентификатор экземпляра сообщения. */
        MessageId?: string;
        /** Идентификаторы вкладок получателей, или null если сообщение адресовано всем вкладкам. */
        TargetTabs?: string[];
        /** Сообщение  направлено к серверу. */
        TargetServer?: boolean;
        /** Идентификатор отправленного события. Если сообщение от сервера, то null. */
        SenderTab?: string;
        /** Временная метка создания сообщения. */
        Timestamp?: Date;
    }
}
declare namespace WebClient {
    /** @internal */
    class OutcomingLocalStorageCommunicationChanel {
        protected services: $LocalStorage & $CurrentEmployeeId;
        protected localStorageKey: string;
        protected tabId: string;
        protected maxMessageLife: number;
        protected pingTimer: any;
        protected relatedIncoming: IncomingLocalStorageCommunicationChanel;
        constructor(type: string, id: string, tabId: string, services: $LocalStorage & $CurrentEmployeeId);
        sendMessage<T>(message: IRealTimeCommunicationMessage<T>, sync?: boolean): void;
        startPing(intervalMs: number): void;
        stopPing(): void;
        dublicateMessagesTo: IncomingLocalStorageCommunicationChanel;
        removeStorageItem(): void;
        protected setQueue(data: IRealTimeCommunicationMessage<any>[]): void;
        protected getQueue(): IRealTimeCommunicationMessage<any>[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface IRealtimeMasterTabInfo {
        masterTabId?: string;
        connectionId?: string;
        masterLastSeen?: Date;
        tabs: string[];
    }
    /** @internal */
    interface IReceivedRealtimeMessageQueueItem {
        message: IRealTimeCommunicationMessage<any>;
        receivedTime: Date;
        targetTabs?: string[];
    }
    /** @internal */
    interface ISendRealtimeMessageQueueItem {
        message: IRealTimeCommunicationMessage<any>;
        senderTabId: string;
    }
    /** @internal */
    interface ITabClosedData {
        isMaster: boolean;
        tabId: string;
    }
    /** Интерфейс подписчика на сообщение для обмена данными в режиме реального времени, используемый в {@link RealtimeCommunicationService} */
    type RealtimeSubscriber<T> = (message: IRealTimeCommunicationMessage<T>, receivedTime?: Date) => void;
    /** @deprecated Use RealtimeSubscriber instead. */
    type RealtimeSubsriber<T> = RealtimeSubscriber<T>;
    /** Интерфейс отправителя сообщений к серверу в режиме реального времени, используемый в {@link RealtimeCommunicationService}*/
    type RealtimeServerSender<T> = (messageItem: IRealTimeCommunicationMessage<T>, hub?: IRealtimeCommunicationHub) => JQueryDeferred<any> | Promise<any>;
    /** Сервис обмена сообщениям с сервером и между вкладками в режиме реального времени. */
    class RealtimeCommunicationService {
        private services;
        private static MasterChanelType;
        private static TabChanelType;
        private static RegisterTabChanel;
        private static RegisterTabMessage;
        private static TabRegisteredMessage;
        private static TabUnregisteredMessage;
        /** Тип сообщения об установлении соединения с сервером. */
        static ConnectedMessage: string;
        /** Тип сообщения о потере соединения с сервером. */
        static DisconnectedMessage: string;
        /** @internal Timeout to try reconnect after connection completely lost (server is unavablable more then 30 sec). */
        static ReconnectTimeout: number;
        /** Тип сообщения о закрытии вкладки. */
        static TabClosed: string;
        private mainLocalStorageKey;
        private messagesFromMaster;
        private messagesFromTabs;
        private messagesToMaster;
        private masterBroadcast;
        private registerTabChanel;
        private customSenders;
        private tabId;
        private masterTabMonitorTimer;
        private masterTabMonitorInterval;
        private tabChanelTimeToDead;
        private hub;
        private lastMasterTabId;
        private registeredAsSlave;
        /** Закрывается ли эта вкладка в данный момент */
        private isClosing;
        private reconnectTimeout;
        private pendingMessagesToServer;
        /** @internal */
        constructor(services: $CurrentEmployeeId & $LocalStorage);
        /** Идентификатор текущей пользовательской сессии. */
        readonly sessionId: string;
        /** Отправить сообщение на сервер. */
        sendToServer<T>(message: IRealTimeCommunicationMessage<T>): void;
        /** Отправить сообщение между вкладками. */
        sendBetweenTabs<T>(message: IRealTimeCommunicationMessage<T>, targetTabs?: string[], sync?: boolean): void;
        /** Отправить сообщение конкретной вкладке. */
        sendToTab<T>(tabId: string, message: IRealTimeCommunicationMessage<T>): void;
        /** Отправить сообщение вкладке, которая осуществляет взаимодействие с сервером. */
        sendToMasterTab<T>(message: IRealTimeCommunicationMessage<T>): void;
        /** Существуют ли подписчики данного сообщения в текущей вкладке. */
        hasSubscribers(messageType: string): boolean;
        /** Подписаться на сообщения определенного типа. */
        subscribe<T>(messageType: string, callback: RealtimeSubscriber<T>): void;
        /** Отписаться от сообщений определенного типа. */
        unsubscribe<T>(messageType: string, callback: RealtimeSubscriber<T>): void;
        /** Подменяет способ отправки сообщений на сервер для определенного типа сообщений. */
        setServerSender(messageType: string, processor: RealtimeServerSender<any>): void;
        /** Возвращает объект, заданный в {@link setServerSender}. */
        getServerSender(messageType: string): RealtimeServerSender<any>;
        /** Возвращает информацию о том, был ли сервис инициализирован и готов ли он к работе. */
        initialized(): boolean;
        /** Осуществляет ли текущая вкладка взаимодействие с сервером. */
        readonly isMasterTab: boolean;
        /** Идентификатор текущей вкладки. */
        readonly currentTabId: string;
        /** Идентификатор вкладки, осуществляющей взаимодействие с сервером. */
        readonly masterTabId: string;
        /** @internal */
        protected onMonitorMasterTabTimerTick: () => void;
        /** @internal */
        protected onInitializeSlaveTab(info: IRealtimeMasterTabInfo): void;
        /** @internal */
        protected onRegisteredAsSlave: (message: IRealTimeCommunicationMessage<string>) => void;
        /** @internal */
        protected onUnregisteredAsSlave: (message: IRealTimeCommunicationMessage<string>) => void;
        /** @internal */
        protected onInitializeMasterTab(info: IRealtimeMasterTabInfo): void;
        /** @internal */
        protected ensureDeinitializedMaster(): void;
        /** @internal */
        protected onHubMessage: (message: IRealTimeCommunicationMessage<any>) => void;
        /** @internal */
        protected onMessageToServer: (message: IRealTimeCommunicationMessage<any>) => Promise<void>;
        /** @internal */
        protected onMessageToTabs(item: IRealTimeCommunicationMessage<any>, sync?: boolean): void;
        /** @internal */
        protected onTabOpened: (message: IRealTimeCommunicationMessage<string>) => void;
        /** @internal */
        protected onCurrentTabClose: () => void;
        /** @internal */
        protected onTabClose: (message: IRealTimeCommunicationMessage<ITabClosedData>) => void;
        /** @internal */
        protected closeChanelFromTab(tabId: string): void;
        /** @internal */
        protected openChanelFromTab(tabId: string): void;
        /** @internal */
        protected getMasterTabInfo(): IRealtimeMasterTabInfo;
        /** @internal */
        protected setMasterTabInfo(data: IRealtimeMasterTabInfo): void;
        /** @internal */
        protected getCurrentEmployee(): string;
        /** @internal */
        protected getCurrentEmployeeAccountName(): string;
        /** Возвращает значение настройки из web-конфигурации. */
        static readonly EnableSignalRLogging: boolean;
        /** Возвращает настройку из web-конфигурации - таймаут перед инициализацией соединения с сервером,
         * для уменьшения нагрузки на сетевой канал при открытии приложения. */
        static readonly SignalRInitTimeout: number;
        /** @internal */
        static log(msg: string): void;
        /** @internal */
        static logMessage(caption: string, message: IRealTimeCommunicationMessage<any>): void;
    }
    /** Сервис взаимодействия с сервером и другими вкладками в режиме реального времени. */
    type $RealtimeCommunicationService = {
        realtimeCommunicationService: RealtimeCommunicationService;
    };
}
declare namespace WebClient {
    /** Обработчик роута, который собирает и загружает данные роута, а также отображает содержимое в UI.
     *
     * При реализации его методов следует учитывать следующие ньюансы:
     *
     * 1. Прежде читать значения каких-либо свойств в RouteData, необходимо проверить, что они там есть.
     * Если их нет (и они критичны для работы хандлера), то следует вернуть RouteHandleResults.MissingRequiredData. Например:
     *
     *         if (RouteHelpers.someIsUndefined(routeData.gridModel)) {
     *             return RouteHandleResults.MissingRequiredData;
     *         }
     *
     * 2. Прежде чем вычислять и записывать какие-то значения в RouteData, необходимо проверить, нет ли их там. Если они уже есть, то нужно ничего не делать.
     *    Это связано с тем, что хандлер может вызываться многократно, и он не должен выполнять работу, которая уже выполнена.
     *    Например, у нас уже загружено содержимое грида папки, и мы хотим только поменять заголовок.
     *    В этом случае запустятся все хандлеры, но загружать данные папки нет необходимости.
     *    Если нам понадобится обновить содержимое грида, то следует очистить соответствующее свойство в информации о роуте и вызвать setCurrentRoute.
     *    Тогда соответствующий хандлер увидит, что свойство пустое и заново загрузит эти данные.
     * 3. Хандлер должен выполнять только одну, как можно меньшую задачу.
     *    Должно быть легко сформулировать эту задачу в двух словах, она должна быть понятна из названия.
     *
     * Регистрируются хандлеры после объявления класса следующим образом:
     *
     *       export class MyRouteHandler implements IRouteHandler<IFolderRouteData> {
     *            ...
     *       }
     *
     *       SammyHelper.RouterInitialization.subscribe((sammy: SammyHelper) => {
     *           sammy.addHandler(StandardRoutes.AllRoutes, new MyRouteHandler());
     *       });
     *
     * @param T Тип данных роута. Например, {@link IFolderRouteData}.
     */
    interface IRouteHandler<T> {
        /** Имя хандлера для отладочных целей. */
        name: string;
        /** Подготавливает информацию, которая необходима для загрузки основной информации роута.
          * Например, при открытии папки в этом обработчике собирается информация о представлении, фильтре, сортировке и т.д.
          */
        prepareRouteDataLoad?(routeData: Partial<T>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        /** Загружает основную информацию роута. */
        loadRouteData?(routeData: Partial<T>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        /** Делает предварительную обработку загруженной информации, перед тем как ее отображать. */
        prepareRouteMount?(routeData: T, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        /** Отображает содержимое роута в UI. */
        mountRoute?(data: T, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        /** Очищает UI от содержимого роута, освобождает все занятые ресурсы (таймеры, подписки на события и т.д.). */
        unmountRoute?(data: T, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /** Информация о роута и его оперативные данные. */
    interface IRouteInfo<T> {
        /** Уникальный идентификатор тип роута. */
        routeType: RouteType;
        /**
          * Значение, которое позволяет отличить один роут от другого при одном и том же routeType.
          * Значение представляет собой некоторую строку, которая вычисляется на основе
          * существенных параметров роута. Например, в роуте папки существенным параметром
          * является id папки, т.к. при его смене необходимо закрыть текущую папку и открыть другую.
          */
        identity: string;
        /** Оперативные данные роута. */
        data: T;
    }
}
declare namespace WebClient {
    /** Интерфейс для классов, сопоставляющий url на тип роута. Для регистрации маппера используется метод {@link SammyHelper.addRouteTypeMapper} */
    interface IRouteTypeMapper<T> {
        /** Должно возвращать описание [пути роута для SammyJS](http://sammyjs.org/docs/routes).
         *
         * При реализации можно использовать методы класса {@link RouteHelpers}, например:
         *
         *      // В результате получится #/Folder/:FolderId
         *      hashPattern = RouteHelpers.makeHashPattern('#/Folder/', [FolderRouteParameters.FolderId]);
         *
         */
        hashPattern: string;
        /** При реализации должен анализировать параметры роута и формировать начальный RouteData объект.
          * Допустим, если у нас роут папки, то мы извлекаем из url id папки, проверяем
          * что это корректный id, и возвращаем объект {@link IFolderRouteData} с заполненным `folderId`.
          * @param path Путь текущего роута, включая имя приложения, хэш, и query-параметры.
          * Например: `/DocsvisionWebClient/#/Folder/5bf0fb94-23fa-4212-80c3-c598e9859901?Color=folder-default`
          * @param parameters Объединяют в себе как параметры указанные через двоеточие в hashPattern,
          * так и query-параметры, добавленные через знак вопроса (после #).
          */
        resolve(path: string, parameters: {
            [id: string]: string;
        }): JQueryDeferred<IRouteInfo<T>>;
        /** Используется в том случае, если мы вызываем SammyHelper.setCurrentRoute для того, чтобы обновить url в браузере. */
        tryGetUrl(route: IRouteInfo<T>): string | undefined;
    }
}
declare namespace WebClient {
    /** Результат работы обработчика роута. */
    enum RouteHandleResults {
        /** Обработчик ожидает новых данных, которые должны быть поставлены другими обработчиками. */
        MissingRequiredData = 0,
        /** Обработчик завершил работу. */
        Done = 1,
    }
    /** Возвращаемый тип обработчика роута. */
    type RouteHandleResult = RouteHandleResults | void;
}
declare namespace WebClient {
    class RouteHelpers {
        /**
         * Формирует хэш-паттерн для роутера.
         * @param path Статическая часть пути (без параметров)
         * @param parameters Имена параметров
         *
         * Пример использования:
         *
         *      let hashPattern = RouteHelpers.makeHashPattern('#/Folder/', ["FolderId"]);
         */
        static makeHashPattern(path: string, parameters: string[]): string;
        /** Формирует URL на основе хэш-паттерна и значений параметров.
         *
         * Например, при передаче `#/CardView/:CardID` и `{ name: "CardID", value: "db7ed65b-f088-4f3a-9846-cd7f9a993d6a"}` будет возвращено
         * `#/CardView/db7ed65b-f088-4f3a-9846-cd7f9a993d6a`.
         */
        static makeUrlFromHashPattern(hashPattern: string, parameters: {
            name: string;
            value: string;
        }[], queryParameters?: {
            name: string;
            value: string;
        }[]): string;
        /** Одно из значений не определено. */
        static someIsUndefined(...args: any[]): boolean;
        /** Присваивает свойство объекта target, если оно не задано. */
        static assignIfUndefined<SourceT, TargetT>(target: TargetT, map?: {
            value: FieldSpec<SourceT, any>;
            field: FieldSpec<TargetT, any>;
        }[]): void;
        /** Формирует идентификатор роута на основе переданных значений. */
        static makeIdentity(...values: any[]): string;
    }
}
declare namespace WebClient {
    /** @internal */
    class SearchPanel {
        private services;
        private isNotOpened;
        private fullTextSearchEnabled;
        private dropdown;
        private isMobile;
        private timer;
        private traceProvider;
        private hidden;
        private prevNavBarMode;
        private searchText;
        constructor(services: $DeviceType);
        ShouldResetInstanceBeforeSearch: boolean;
        /** @obsolete */
        readonly DeviceType: GenModels.DeviceType;
        readonly IsDashboard: boolean;
        readonly IsSearchResults: boolean;
        readonly Dropdown: SearchDropdown;
        readonly IsNotOpened: boolean;
        readonly FullTextSearchEnabled: boolean;
        Hide(): void;
        Expand(): void;
        Show(): void;
        SearchText: string;
        SearchTextFromInput: string;
        Search(refresh?: boolean): void;
        Reset(): void;
        Clear(): void;
        Rebuild(): void;
        private buildSearchRequestParams(searchText, refresh);
        /** Called when search expanded */
        private OnExpaned();
        /** Called when search collapsed or hidden */
        private OnClosed();
        private readonly SearchButton;
        readonly SearchInput: HTMLElement;
        readonly SearchTextInput: HTMLInputElement;
        private readonly SearchClearButton;
        private Initialize();
        private onSearchAreaSelected(oldVal, newVal);
        private AddSearchInputClickEvent();
        private AddSearchInputMissClickEvent();
        private AddSearchButtonClickEvent();
        private readonly Expanded;
        private Toggle();
        private UpdateCaption();
        private AddClearButtonClickEvent();
        private AddOnTextInputEvent();
        private ToggleClearButton();
        private CheckFullTextSearchAvailability();
    }
    /** @internal */
    type $SearchPanel = {
        searchPanel: SearchPanel;
    };
}
declare namespace WebClient {
    /** @internal */
    interface IFoldersToCountData {
        folders: IFolderToCount[];
    }
    /** @internal */
    interface IFolderToCount {
        id: string;
        /** Control or someone, that requested the counter */
        sourceId: string;
        forceVirtualFolderSearch?: boolean;
        refreshTimeout: number;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFolderToCountOptions {
        forceVirtualFolderSearch?: boolean;
        refreshTimeout: number;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILocalCounter {
        localCount?: number;
        localCountTimestamp?: number;
    }
    /** @internal */
    interface ILocalCounterData {
        folderId: string;
        counter: ILocalCounter;
    }
}
declare namespace WebClient {
    /** @internal */
    type IUnreadCountersData = {
        [folderId: string]: IUnreadCounter;
    };
    /** @internal */
    interface IUnreadCounter extends ILocalCounter {
        count: number;
        timestamp?: number;
    }
}
declare namespace WebClient {
    /** @internal */
    class UnreadCounter {
        private updateTimeout;
        private realtimeCommunicationService;
        private globalTabsFolders;
        private sessionStorageKey;
        private foldersToCountData;
        private foldersToCountChangedEvent;
        private unreadCountersData;
        private unreadCountersDataChangedEvent;
        private static CurrentUnreadCountersMessage;
        private static RequestCurrentCountersMessage;
        static SendLocalCountsMessage: string;
        constructor(services: $RealtimeCommunicationService);
        foldersToCount: IFoldersToCountData;
        readonly foldersToCountChanged: IBasicEvent<IFoldersToCountData>;
        addFolderToCount(folderId: string, sourceId: string, options: IFolderToCountOptions): void;
        removeFolderToCount(folderId: string, sourceId: string): void;
        unreadCardCounters: IUnreadCountersData;
        readonly unreadCardCountersChanged: IBasicEvent<IUnreadCountersData>;
        /**
         * Устанавливает локальное значение счётчика
         * @param folderId ИД Папки
         * @param value Значение
         * @param timestamp Если имеется существующий timestamp для локального значения и мы хотим использовать его
         * @param shouldNotify Нужно ли оповещать другие вкладки об изменении
         */
        setLocalCount(folderId: string, value: number, timestamp?: number, shouldNotify?: boolean): void;
        protected onUpdateLocalCounts: (message: IRealTimeCommunicationMessage<ILocalCounterData>) => void;
        incrementLocalCount(folderId: string, timestamp?: number, shouldNotify?: boolean): void;
        decrementLocalCount(folderId: string, timestamp?: number, shouldNotify?: boolean): void;
        getUnreadCardsCount(folderId: string): number | undefined;
        protected Initialize(): void;
        protected readonly serverResponseMessage: string;
        protected onFoldersToCountChanged(): void;
        protected sendCurrentCountersToOtherTab: (messageItem: IRealTimeCommunicationMessage<string>) => void;
        protected onReceivedCurrentCounters: (message: IRealTimeCommunicationMessage<IUnreadCountersData>) => void;
        protected onConnected: (message: IRealTimeCommunicationMessage<any>) => void;
        protected sendFoldersToService(): void;
        protected sendFoldersToServer: (message: IRealTimeCommunicationMessage<any>, hub: IRealtimeCommunicationHub) => Promise<void>;
        protected processResponse: (response: IRealTimeCommunicationMessage<UnreadCountersResponse>) => void;
        protected getCurrentEmployee(): string;
    }
    /** @internal */
    type $UnreadCounter = {
        unreadCounter: UnreadCounter;
    };
    class UnreadCountersRequest {
        EmployeeId: string;
        RealtimeSessionId: string;
        PartialRequest: boolean;
        ClientFolders: Array<IUnreadCountersFolderInfo>;
    }
    class UnreadCountersResponse {
        EmployeeId: string;
        RealtimeSessionId: string;
        ClientFolders: Array<ClientFolderCounter>;
    }
    class ClientFolderCounter {
        FolderId: string;
        Counter?: number;
        ForceVirtualFolderSearch?: boolean;
    }
    class IUnreadCountersFolderInfo {
        FolderId: string;
        ForceVirtualFolderSearch?: boolean;
        RefreshTimeout: number;
    }
}
declare namespace WebClient {
    /** @internal */
    class CustomHtmlPageRouteConstants {
        static UrlParameter: string;
        static HeaderParameter: string;
        static ColorParameter: string;
        static HashPattern: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class CustomHtmlPageRouteHandler implements IRouteHandler<ICustomHtmlPageRouteData> {
        name: string;
        mountRoute(data: ICustomHtmlPageRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: ICustomHtmlPageRouteData, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /** @internal */
    class CustomHtmlPageRouteHelpers {
        static makeRouteUrl(url: string, header: string, color: string): string;
        static openCustomWebPage(folderUrl: string, headerText: string, color: string): JQueryDeferred<void>;
    }
}
declare namespace WebClient {
    /** @internal */
    class CustomHtmlPageRouteTypeMapper implements IRouteTypeMapper<ICustomHtmlPageRouteData> {
        hashPattern: string;
        resolve(path: string, parameters: {
            [id: string]: string;
        }): JQueryDeferred<IRouteInfo<ICustomHtmlPageRouteData>>;
        tryGetUrl(route: IRouteInfo<ICustomHtmlPageRouteData>): string | undefined;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICustomHtmlPageRouteData {
        header?: string;
        color?: string;
        url?: string;
    }
}
declare namespace WebClient {
    /** Вспомогательные функции для работы с роутом домашней страницы. */
    class DashboardRouteHelpers {
        /** Перейти на роут домашней страницы. */
        static goToDashboard(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class DashboardRouteTypeMapper implements IRouteTypeMapper<ILayoutPageRouteData> {
        private dashboardPosition;
        hashPattern: string;
        resolve(path: string, parameters: {
            [id: string]: string;
        }): JQueryDeferred<IRouteInfo<ILayoutPageRouteData>>;
        tryGetUrl(route: IRouteInfo<ILayoutPageRouteData>): string | undefined;
    }
}
declare namespace WebClient {
    /** @internal */
    class DefaultFolderRouteHandler implements IRouteHandler<IFolderRouteData> {
        name: string;
        prepareRouteDataLoad(knownRouteData: Partial<IFolderRouteData>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        loadRouteData(knownRouteData: Partial<IFolderRouteData>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        mountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<{}>;
        /**
         * Load filter and filter settings
         * @param folderInfo Folder info
         * @param folderView  Folder view
         */
        private loadFilter(folderInfo, folderView);
        /**
         * Load viewId and view settings
         * @param folderInfo Folder info
         * @param folderView  Folder view
         */
        private loadViewSettings(folderInfo, folderView);
        /**
         * Load search parameters stuff
         * @param folderInfo Folder info
         * @param folderView  Folder view
         */
        private loadSearchParametres(searchId, layout?);
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderAsWebPageRouteHandler implements IRouteHandler<IFolderRouteData> {
        name: string;
        mountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderCountersRouteHandler implements IRouteHandler<IFolderRouteData> {
        protected services: $RealtimeCommunicationService;
        name: string;
        protected timer: any;
        protected grid: Grid;
        protected isNotificating: boolean;
        protected sessionSuspended: boolean;
        /** @deprecated Use {@link SessionExpiredHandler.SuspednedMessageType} */
        static readonly SuspednedMessageType: string;
        /** @deprecated Use {@link SessionExpiredHandler.AwokenMessageType} */
        static readonly AwokenMessageType: string;
        /** @deprecated Use {@link SessionExpiredHandler.DisposedMessageType} */
        static readonly DisposedMessageType: string;
        /** @deprecated Use {@link SessionExpiredHandler.CreatedMessageType} */
        static readonly CreatedMessageType: string;
        constructor(services: $RealtimeCommunicationService);
        mountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<{}>;
        protected createTimer(gridModel: any, refreshTimeout: number): number;
        protected clearTimer(): void;
        protected onSessionAwokenOrCreated: () => void;
        protected onSessionSuspendedOrDisposed: () => void;
        protected onGridRefresh: () => void;
        protected onCountersChanged: (message: IRealTimeCommunicationMessage<any>) => void;
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderRouteHelpers {
        static openFolder(folderId: string, color?: string): void;
        static makeFolderUrl(folderId: string, color?: string): string;
        static getRecentCardsUrl(): string;
        static makeFolderRouteData(folderId?: string, color?: string): IFolderRouteData;
        static mountGrid(gridModel: GenModels.CardListViewModel, options?: Partial<GridOptions>): JQueryDeferred<{}>;
        static mountGridTo(gridModel: GenModels.CardListViewModel, gridContainer: HTMLElement, options?: Partial<GridOptions>): void;
        static getGridContainer(id?: string): Grid;
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderRouteParameters {
        static FolderId: string;
        static Color: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderRouteTypeMapper implements IRouteTypeMapper<IFolderRouteData> {
        static SearchResultsId: string;
        static RecentCardsId: string;
        hashPattern: string;
        resolve(path: string, parameters: {
            [id: string]: string;
        }): JQueryDeferred<IRouteInfo<IFolderRouteData>>;
        tryGetUrl(route: IRouteInfo<IFolderRouteData>): string | undefined;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICommonFolderInfo {
        folderId?: string;
        folderName?: string;
        folderColor?: string;
        hasSubfolders?: boolean;
        folderType?: GenModels.FolderNodeType;
        defaultStyle?: GenModels.FolderNodeStyle;
        defaultViewId?: string;
        url?: string;
        parentFolders?: string[];
        refreshTimeout?: number;
        forceVirtualFolderSearch?: boolean;
        folderUri?: string;
        navigatorFolderType?: NavigatorFolderType;
        sourceType?: string;
        queryId?: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICommonFolderViewInfo {
        viewId?: string;
        searchContextOption?: string;
        fullTextFilter?: string;
        filter?: any;
        currentPage?: any;
        sortingColumn?: any;
        sortIsDesc?: any;
        parameters?: any;
        deviceType?: GenModels.DeviceType;
        oldStoreId?: string;
        viewSourceId?: string;
        querySearchId?: string;
        searchId?: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFolderRouteData {
        gridModel?: GenModels.CardListViewModel;
        folderInfo?: ICommonFolderInfo;
        folderViewInfo?: ICommonFolderViewInfo;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILayoutPageRouteData {
        header?: string;
        color?: string;
        position?: string;
        layoutModel?: GenModels.LayoutViewModel;
    }
}
declare namespace WebClient {
    /** @internal */
    class LayoutPageRouteConstants {
        static PositionParameter: string;
        static HeaderParameter: string;
        static ColorParameter: string;
        static HashPattern: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class LayoutPageRouteHandler implements IRouteHandler<ILayoutPageRouteData> {
        name: string;
        loadRouteData(knownRouteData: Partial<ILayoutPageRouteData>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        mountRoute(data: ILayoutPageRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: ILayoutPageRouteData, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /** @internal */
    class LayoutPageRouteHelpers {
        static makeRouteUrl(position: string, header: string, color: string): string;
        static loadLayout(position: string): JQueryDeferred<GenModels.LayoutViewModel>;
    }
}
declare namespace WebClient {
    /** @internal */
    class LayoutPageRouteTypeMapper implements IRouteTypeMapper<ILayoutPageRouteData> {
        hashPattern: string;
        resolve(path: string, parameters: {
            [id: string]: string;
        }): JQueryDeferred<IRouteInfo<ILayoutPageRouteData>>;
        tryGetUrl(route: IRouteInfo<ILayoutPageRouteData>): string | undefined;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IRecentCardsRouteData {
        searchContextOption?: string;
        searchText?: string;
        gridModel?: GenModels.CardListViewModel;
    }
}
declare namespace WebClient {
    /** @internal */
    class RecentCardsRouteHandler implements IRouteHandler<IRecentCardsRouteData> {
        name: string;
        protected gridModelLoader: (requestData: any, isMobile: boolean) => JQueryDeferred<GenModels.GridViewModel>;
        loadRouteData(knownRouteData: Partial<IRecentCardsRouteData>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        mountRoute(data: IRecentCardsRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: IRecentCardsRouteData, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ISearchRouteData {
        searchContextOption?: string;
        searchText?: string;
        fullTextFilter?: string;
        deviceType?: GenModels.DeviceType;
        oldStoreId?: string;
        currentPage?: any;
        sortingColumn?: any;
        sortIsDesc?: any;
        gridModel?: GenModels.CardListViewModel;
    }
}
declare namespace WebClient {
    /** @internal */
    class SearchRouteHandler implements IRouteHandler<ISearchRouteData> {
        name: string;
        prepareRouteDataLoad(routeData: Partial<ISearchRouteData>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        loadRouteData(routeData: Partial<ISearchRouteData>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        mountRoute(data: ISearchRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: ISearchRouteData, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    interface ISignatureDataModel {
        labels: ISignatureLabel[];
        timestamp: number;
        cardid: string;
        signFields?: boolean;
        signAttachments?: boolean;
        thumbprint: string;
    }
}
declare namespace WebClient {
    interface ISignatureLabel {
        /** Идентификатор метки подписи. */
        id: string;
        /** Название метки. */
        name: string;
        encodedId: string;
    }
}
declare namespace WebClient {
    interface ISignatureListDataModel {
        Signatures: ISignatureListItemDataModel[];
    }
}
declare namespace WebClient {
    interface ISignatureListItemAuthorDataModel {
        EmployeeId: string;
        DisplayName: string;
        FistName: string;
        LastName: string;
        MiddleName: string;
        Email: string;
        Position: string;
        AccountName: string;
        Unit: any;
        DeputyDisplayName: string;
        IsFavoritePerformer: boolean;
    }
}
declare namespace WebClient {
    interface ISignatureListItemDataModel {
        Id: string;
        Author: any;
        CreationDate: string;
        LabelDisplayName: string;
        SignatureStatus: string;
        ValidationState: ValidationState;
        CertificateThumbprint: string;
        IsSimpleSign: boolean;
        SignatureDetails: ISignatureListItemDetailDataModel[];
        HasSignedAttributItem: boolean;
    }
}
declare namespace WebClient {
    interface ISignatureListItemDetailDataModel {
        Status: string;
        FileVersionNumber: string;
        FileName: string;
        FileId: string;
        SignData: string;
        CertificateThumbprint: string;
        IsSignedWithCertificate: boolean;
        ErorrMessage: string;
        SignatureItemType: SignatureItemType;
        Description?: string;
        PartItems?: string[];
        Timestamp: string;
    }
}
declare namespace WebClient {
    enum SignatureVerificationStatus {
        NotSigned = 0,
        Valid = 1,
        Invalid = 2,
        PartiallyValid = 3,
        UnableToVerify = 4,
        CertificateRevoked = 5,
        CertificateExpired = 6,
        CertificateCanNotValidated = 7,
    }
}
declare namespace WebClient {
    enum ValidationState {
        Valid = 0,
        Invalid = 1,
        PartiallyValid = 2,
        СonditionallyValid = 3,
    }
}
declare namespace WebClient {
    interface IFindEmployeeResult {
        employees: GenModels.EmployeeModel[];
        hasMore: boolean;
    }
}
declare namespace WebClient {
    interface IFileInfo {
        /** Идентификатор файла. */
        fileId: string;
        /** Идентификатор карточки файла. */
        fileCardId: string;
        /** Идентификатор версии файла. */
        versionId: string;
        /** Идентификатор карточки-владельца. */
        ownerCardId: string;
        /** Информация об изображении для превью. */
        imageInfo: IImageInfo;
    }
}
declare namespace WebClient {
    interface IFileModel {
        /** Идентификатор файла. */
        fileId: string;
        /** Название файла. */
        name: string;
        /** Размер файла. */
        size: number;
        /** Локализованное название единиц измерения размера файла. */
        localizedDisplaySizeName: string;
        changeDate: Date;
    }
}
declare namespace WebClient {
    interface IFilePreviewModel {
        /** Информация о файле. */
        fileInfo: IFileInfo;
        /** Информация о модели файла. */
        fileModel: IFileModel;
        /** Текущий номер страницы. */
        pageIndex: number;
        /** Общее количество страниц. */
        pageCount: number;
        /** Включено ли изменение размеров превью. */
        enableScaling: boolean;
    }
}
declare namespace WebClient {
    interface IImageInfo {
        scale: number;
        resolution: number;
        width: number;
        height: number;
        format: string;
        quality: number;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovalCycleInfoProps extends GenModels.ApprovalHistoryCycleModel {
        services: $FileController;
    }
    /** @internal */
    class ApprovalCycleInfo extends React.Component<IApprovalCycleInfoProps, any> {
        constructor(props: any);
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class ApprovalCycleList extends React.Component<ApprovalCycleListProps, any> {
        constructor(props: ApprovalCycleListProps);
        private renderItem(item);
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ApprovalCycleListProps {
        cycles: GenModels.ApprovalHistoryCycleModel[];
        currentCycle: any;
        onCycleClick: Function;
    }
}
declare namespace WebClient {
    /** @internal */
    class ApprovalHistoryFullStageInfo extends React.Component<any, any> {
        /** @internal */
        constructor(props: any);
        /** @internal */
        render(): JSX.Element;
        /** ������������ �����������. */
        renderComment(): JSX.Element;
        /** ������������ ���� �����������. */
        renderCommentFile(): JSX.Element;
        /** ������������ ������. */
        renderCorrections(): JSX.Element;
        protected handleCorrectionFileClick(file: any): void;
        protected hanldeCommentFileClick(e: any): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class ApprovalHistoryTable extends React.Component<IApprovalHistoryTableProps, IApprovalHistoryTableState> {
        /** @internal */
        constructor(props: IApprovalHistoryTableProps);
        /** @internal */
        componentWillReceiveProps(nextProps: IApprovalHistoryTableProps, nextContext: any): void;
        /** При клике на цикл. */
        protected handleCycleClick(cycleNumber: any): void;
        /**
         * Загрузка данных о цикле.
         * @param cycleNumber Номер цикла
         */
        protected loadCycleData(cycleNumber: any): void;
        /** При клике на обновление. */
        protected onRefreshClick(): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovalHistoryTableProps {
        data: GenModels.ApprovalHistoryViewModel;
        approvingReportRefreshing: CancelableEvent<IApprovingReportRefreshingEventArgs>;
        approvingReportRefreshed: SimpleEvent<IApprovingReportRefreshedEventArgs>;
        refreshRequested: Function;
        inline?: boolean;
        services: $FileController;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovalHistoryTableState {
        currentCycle: number;
        cycleData: GenModels.ApprovalHistoryCycleModel;
    }
}
declare namespace WebClient {
    /** @internal */
    class ApprovalStageInfo extends React.Component<any, any> {
        /** @internal */
        constructor(props: any);
        /** При клике на заголовок. */
        protected handleHeaderClick(event: React.MouseEvent<any>): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovalStageItemCommentProps extends GenModels.ApprovalHistoryStageItemModel {
        services: $FileController & $LayoutFileController;
    }
    /** @internal */
    class ApprovalStageItemComment extends React.Component<IApprovalStageItemCommentProps, any> {
        /** @internal */
        constructor(props: any);
        /** При клике на файл комментария. */
        protected hanldeCommentFileClick(e: any): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class ApprovalStageItemRow extends React.Component<IApprovalStageItemRowProps, any> {
        /** @internal */
        constructor(props: any);
        /** ����� �������. */
        private readonly decisionText;
        /** ����� ������� */
        private readonly decisionClass;
        /** ���������� �� ������� ��� ���. */
        private readonly waitingForDecision;
        /** ��� ����� �� �����������. */
        protected handleCommentClick(): void;
        /**
         * ��� ����� �� ����� � ��������.
         * @param file ���� � ��������
         */
        protected handleCorrectionFileClick(file: GenModels.ApprovalHistoryFileModel): void;
        /** ��� ����� �� ������� �����. */
        protected handleStageRowClick(): void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovalStageItemRowProps {
        stageItem: GenModels.ApprovalHistoryStageItemModel;
        ownerCardId: string;
        services: $FileController & $LayoutFileController;
    }
}
declare namespace WebClient {
    /** @internal */
    class AgreementListContent extends React.Component<IAgreementListContentProps, IAgreementListContentState> {
        rootElem: HTMLElement;
        constructor(props: IAgreementListContentProps);
        readonly onRender: IBasicEvent<IAgreementListRenderEventArgs>;
        readonly root: HTMLElement;
        columns: IAgreementListTableColumn[];
        commentColumn: IAgreementListTableColumn;
        protected preRenderPrepareColumns(columns: IAgreementListTableColumn[]): IAgreementListTableColumn[];
        protected calculateWidths(columns: IAgreementListTableColumn[]): void;
        protected renderTable(columnsParam: IAgreementListTableColumn[]): JSX.Element;
        protected renderHeader(columns: IAgreementListTableColumn[]): JSX.Element;
        protected renderRow(item: GenModels.AgreementListItemModel, columns: IAgreementListTableColumn[]): JSX.Element;
        protected getCaption(): string;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAgreementListContentProps {
        data: GenModels.AgreementListModel;
        documentNumber: string;
        documentName: string;
        title: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAgreementListContentState {
        columns: IAgreementListTableColumn[];
        commentColumn: IAgreementListTableColumn;
        onRender: IBasicEvent<IAgreementListRenderEventArgs>;
    }
}
declare namespace WebClient {
    /** @internal */
    class AgreementStage extends React.Component<AgreementStageProps, AgreementStageState> {
        approvalTypeIcons: {
            [key: number]: string;
        };
        approvalStageSemanticStyle: {
            [key: number]: string;
        };
        constructor(props: AgreementStageProps);
        onToggleClick(ev: React.MouseEvent<any>): void;
        onStageCheckChange(val: boolean): void;
        onDeleteApproverClick(id: string): Promise<void>;
        onExcludeCheckChange(event: any, id: string): void;
        onEmployeeChanged(sender: any, args: IDataChangedEventArgs): Promise<void>;
        onDurationChanged(sender: any, args: IDataChangedEventArgs): void;
        onDurationTypeSelect(selectedType: IComboBoxElement): void;
        onReconcileTypeSelect(selectedType: IComboBoxElement): void;
        onInterruptStageClick(event: any): void;
        attachApprover(control: Employee): void;
        getButtonName(operationKind: GenModels.AgreementManagementOperations): string;
        getReconcileTypeElements(): {
            elements: IComboBoxElement[];
        };
        getReconcileDurationTypeElements(): {
            elements: IComboBoxElement[];
        };
        getSematicStyle(stage: StageModelWithChange): string;
        renderComboboxTitleWithIcon: (element: IComboBoxElement) => JSX.Element;
        renderComboboxElementWithIcon: (element: IComboBoxElement, selected: boolean) => JSX.Element;
        renderApprover(approver: GenModels.ApproverEmployeeModel): JSX.Element;
        renderApproversList(approvers: GenModels.ApproverModel[], editable: any, hasBusinessProc: any, excluded: any): JSX.Element;
        renderOtherSettings(stage: StageModelWithChange): JSX.Element;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class AgreementStageEmployeesLoader extends GenControllers.LayoutStaffController {
        private employeesToFilter;
        protected loaderServices: $LayoutStaffController;
        constructor(employeesToFilter: string[], services: $LayoutStaffController);
        findEmployees(request: GenModels.FindEmployeesRequest, options?: RequestOptions): JQueryDeferred<GenModels.FindEmployeesResponse>;
    }
}
declare namespace WebClient {
    /**
     @internal
     */
    class AgreementStageProps {
        stage: StageModelWithChange;
        approverViewType: GenModels.ApproverViewType;
        className?: string;
        editMode?: boolean;
        getButtonName?: (operationKind: GenModels.AgreementManagementOperations) => string;
        canIterruptCurrent?: boolean;
        onInterruptClick?: Function;
        services: $LayoutStaffController & $EditOperationStore & $LayoutInfo & $LocalStorage;
        /** Событие возникает при добавлении нового согласующего. */
        approverAdding: CancelableApiEvent<IApproverEventArgs>;
        /** Событие возникает при удалении согласующего. */
        approverDeleting: CancelableApiEvent<IApproverDeletionEventArgs>;
        /** Событие возникает после добавления нового согласующего. */
        approverAdded: BasicApiEvent<IApproverEventArgs>;
        /** Событие возникает после удаления согласующего. */
        approverDeleted: BasicApiEvent<IApproverDeletionEventArgs>;
    }
}
declare namespace WebClient {
    /** @internal */
    class AgreementStageState {
        stageExpanded: boolean;
        approversOrder: string[];
        approverSelect: Employee;
        durationType: ReconcileDurationType;
        stage: StageModelWithChange;
    }
}
declare namespace WebClient {
    type StageModelWithChange = GenModels.StageModel & Optional<GenModels.StageChangeModel>;
}
declare namespace WebClient {
    enum CheckboxHideMode {
        UndefinedValue = 0,
        YesValue = 1,
        NoValue = 2,
        NotHide = 3,
    }
}
declare namespace WebClient {
    interface ImageModel {
        imageData: string;
        fileName: string;
    }
}
declare namespace WebClient {
    interface IAddCommentProps {
        className?: string;
        text: string;
        placeHolder: string;
        onTextChange: (newValue) => void;
        onAddComment: () => void;
        onCancelAddComment: () => void;
    }
    const AddComment: (props: IAddCommentProps) => JSX.Element;
}
declare namespace WebClient {
    interface ICommentProps {
        className?: string;
        data: GenModels.Comment;
        currentEmployeeId: string;
        isShowDate: boolean;
        canEditSelf: boolean;
        canEditAll: boolean;
        editComment: (comment: GenModels.Comment) => void;
        deleteComment: (comment: GenModels.Comment) => void;
    }
    const Comment: (props: ICommentProps) => JSX.Element;
}
declare namespace WebClient {
    const CommentActionsPanelStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    interface ICommentBodyProps {
        isCommentAuthor: boolean;
    }
    const CommentBodyStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentBodyProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentBodyProps>;
}
declare namespace WebClient {
    interface ICommentBodyTriangleProps {
        isCommentAuthor: boolean;
    }
    const CommentBodyTriangleStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentBodyTriangleProps, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentBodyTriangleProps>;
}
declare namespace WebClient {
    const CommentButtonsContainerStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    const CommentButtonStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>>;
}
declare namespace WebClient {
    const CommentDateStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    const CommentDeleteIcon: () => JSX.Element;
}
declare namespace WebClient {
    const CommentEditIcon: () => JSX.Element;
}
declare namespace WebClient {
    const CommentHeaderDateStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    const CommentIconContainerStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    const CommentInfoStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    interface ICommentInputTextAreaProps {
        className?: string;
        text: string;
        placeHolder: string;
        onTextChange: (newValue) => void;
    }
    const CommentInputTextArea: (props: ICommentInputTextAreaProps) => JSX.Element;
}
declare namespace WebClient {
    interface ICommentStyleProps {
        isAddCommentBlock: boolean;
    }
    const CommentStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentStyleProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentStyleProps>;
}
declare namespace WebClient {
    const CommentTextStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLPreElement> & React.HTMLAttributes<HTMLPreElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLPreElement>, HTMLPreElement>>;
}
declare namespace WebClient {
    interface ICommentUserContainer {
        isCommentAuthor: boolean;
    }
    const CommentUserContainerStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentUserContainer & {
        className: string;
    }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & ICommentUserContainer>;
}
declare namespace WebClient {
    const CommentUserDisplayNameStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLSpanElement> & React.HTMLAttributes<HTMLSpanElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>>;
}
declare namespace WebClient {
    const CommentUserIconStyle: styled.StyledComponentClass<React.SVGProps<SVGSVGElement> & {
        className: string;
    }, any, React.SVGProps<SVGSVGElement>>;
    const CommentUserIcon: () => JSX.Element;
}
declare namespace WebClient {
    interface IShowPreviousCommentsProps {
        className?: string;
        allCommentsCount: number;
        currentLoadedCommentsCount: number;
        onClick: () => void;
    }
    const ShowPreviousCommentsStyle: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const ShowPreviousCommentsTextStyle: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>>;
    const ShowPreviousComments: (props: IShowPreviousCommentsProps) => JSX.Element;
}
declare namespace WebClient {
    /**
     * @internal
     * Содержит публичные свойства элемента управления [DashboardContainer]{@link DashboardContainer}.
     */
    class DashboardContainerParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
    }
    /** @internal */
    class DashboardContainer extends Panel<DashboardContainerParams, DashboardContainerState> {
        protected createParams(): DashboardContainerParams;
        protected createImpl(): DashboardContainerImpl<Readonly<{
            children?: React.ReactNode;
        }> & Readonly<DashboardContainerParams>, DashboardContainerState>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface DashboardContainerState extends DashboardContainerParams, PanelState {
    }
    /** @deprecated */
    type DashboardContainerImplState = DashboardContainerState;
    /** @internal */
    class DashboardContainerImpl<PropsT extends DashboardContainerParams, StateT extends DashboardContainerState> extends PanelImpl<PropsT, StateT> {
        constructor(props: PropsT, state: StateT);
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * @internal
     * Содержит публичные свойства элемента управления [FolderDashboardWidget]{@link FolderDashboardWidget}.
     */
    class FolderDashboardWidgetParams extends PanelParams {
        /** Текст метки. */
        text: string;
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        folderId?: string;
        folderInfo?: GenModels.FolderNode;
        folderUnreadCount?: number;
        color?: string;
        unreadCount?: number;
        forceVirtualFolderSearch?: boolean;
    }
    /** @internal */
    class FolderDashboardWidget extends Panel<FolderDashboardWidgetParams, FolderDashboardWidgetState> {
        constructor(props: FolderDashboardWidgetParams);
        createParams(): FolderDashboardWidgetParams;
        init(): void;
        deinit(): void;
        protected headerFolderInfo: GenModels.FolderNode;
        private textResourceKey;
        protected forceVirtualFolderSearch: string | boolean;
        onUnreadCountChanged: () => void;
        addUnreadCountRequest(): void;
        protected createImpl(): FolderDashboardWidgetImpl<Readonly<{
            children?: React.ReactNode;
        }> & Readonly<FolderDashboardWidgetParams>, FolderDashboardWidgetState>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface FolderDashboardWidgetState extends FolderDashboardWidgetParams, PanelState {
    }
    /** @deprecated */
    type FolderDashboardWidgetImplState = FolderDashboardWidgetState;
    /** @internal */
    class FolderDashboardWidgetImpl<PropsT extends FolderDashboardWidgetParams, StateT extends FolderDashboardWidgetState> extends PanelImpl<PropsT, StateT> {
        constructor(props: PropsT, state: StateT);
        getHeader(): string;
        getNavigationHref(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * @internal
     * Содержит публичные свойства элемента управления [FolderGroupDashboardWidget]{@link FolderGroupDashboardWidget}.
     */
    class FolderGroupDashboardWidgetParams extends PanelParams {
        /** Текст метки. */
        text: string;
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        headerFolderId?: string;
        headerFolderInfo?: GenModels.FolderNode;
        headerFolderUnreadCount?: number;
        color?: string;
        unreadCount?: number;
        forceVirtualFolderSearch?: boolean;
    }
    /** @internal */
    class FolderGroupDashboardWidget extends Panel<FolderGroupDashboardWidgetParams, FolderGroupDashboardWidgetState> {
        constructor(props: FolderGroupDashboardWidgetParams);
        createParams(): FolderGroupDashboardWidgetParams;
        init(): void;
        deinit(): void;
        protected headerFolderInfo: GenModels.FolderNode;
        private textResourceKey;
        protected forceVirtualFolderSearch: string | boolean;
        onUnreadCountChanged: () => void;
        addUnreadCountRequest(): void;
        protected createImpl(): FolderGroupDashboardWidgetImpl<Readonly<{
            children?: React.ReactNode;
        }> & Readonly<FolderGroupDashboardWidgetParams>, FolderGroupDashboardWidgetState>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface FolderGroupDashboardWidgetState extends FolderGroupDashboardWidgetParams, PanelState {
    }
    /** @deprecated */
    type FolderGroupDashboardWidgetImplState = FolderGroupDashboardWidgetState;
    /** @internal */
    class FolderGroupDashboardWidgetImpl<PropsT extends FolderGroupDashboardWidgetParams, StateT extends FolderGroupDashboardWidgetState> extends PanelImpl<PropsT, StateT> {
        constructor(props: PropsT, state: StateT);
        getHeader(): string;
        getNavigationHref(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * @internal
     * Содержит публичные свойства элемента управления [RecentCardsDashboardWidget]{@link RecentCardsDashboardWidget}.
     */
    class RecentCardsDashboardWidgetParams extends PanelParams {
        /** Текст заголовка. */
        header: string;
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
    }
    /** @internal */
    class RecentCardsDashboardWidget extends Panel<RecentCardsDashboardWidgetParams, RecentCardsDashboardWidgetState> {
        constructor(props: RecentCardsDashboardWidgetParams);
        createParams(): RecentCardsDashboardWidgetParams;
        private textResourceKey;
        protected createImpl(): RecentCardsDashboardWidgetImpl<Readonly<{
            children?: React.ReactNode;
        }> & Readonly<RecentCardsDashboardWidgetParams>, RecentCardsDashboardWidgetState>;
    }
}
declare namespace WebClient {
    /** @internal */
    interface RecentCardsDashboardWidgetState extends RecentCardsDashboardWidgetParams, PanelState {
        gridModel: any;
        loader: RequestHelper;
        gridContainer: HTMLElement;
    }
    /** @deprecated */
    type RecentCardsDashboardWidgetImplState = RecentCardsDashboardWidgetState;
    /** @internal */
    class RecentCardsDashboardWidgetImpl<PropsT extends RecentCardsDashboardWidgetParams, StateT extends RecentCardsDashboardWidgetState> extends PanelImpl<PropsT, StateT> {
        static readonly size: number;
        constructor(props: PropsT, state: StateT);
        componentDidMount(): void;
        loadGridModel(): void;
        protected gridDataLoader(requestData: any, isMobile: boolean): JQueryDeferred<GenModels.CardListViewModel>;
        protected gridModelLoader: (requestData: any, isMobile: boolean) => JQueryDeferred<GenModels.GridViewModel>;
        mountGrid(): void;
        attachGridContainer: (elem: HTMLElement) => void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IDepartmentSelectDialogProps {
        itemTypes: GenModels.SearchDepartmentType;
        departmentSelected: (node: GenModels.DepartmentTreeNode) => void;
        departmentAccepted: (node: GenModels.DepartmentTreeNode) => void;
        /** Where to perform the search */
        source: GenModels.DepartmentDataSource;
        /** Задержка перед поиском (в мс) */
        searchDelay?: number;
        searchText: string;
        services: $LayoutStaffController;
    }
    /** @internal */
    interface IDepartmentSelectDialogState {
        requestHelper: RequestHelper;
        searchRequestHelper: RequestHelper;
        selectedNode: GenModels.DepartmentTreeNode;
        focusedNode: GenModels.DepartmentTreeNode;
        treeWrapper: HTMLElement;
        searchResultCount: number;
        showingSearchResults: boolean;
        searchText: string;
        initialLoading: LoadingState;
        nodes: GenModels.DepartmentTreeNode[];
        flatNodes: GenModels.DepartmentTreeNode[];
        searchTimerHandle: number;
    }
    /** @internal */
    class DepartmentSelectDialog extends React.Component<IDepartmentSelectDialogProps, IDepartmentSelectDialogState> {
        static LoadTreeLevelDown: number;
        static LevelsToExapndByDefault: number;
        recursive: RecursiveVisitor<GenModels.DepartmentTreeNode>;
        /** Уровень узла */
        levels: IAccessor<GenModels.DepartmentTreeNode, number>;
        /** Раскрыт ли узел */
        expanded: IAccessor<GenModels.DepartmentTreeNode, boolean>;
        /** Виден ли узел */
        visible: IAccessor<GenModels.DepartmentTreeNode, boolean>;
        /** Отображает процесс загрузки данных с сервера */
        childrenLoading: IAccessor<GenModels.DepartmentTreeNode, LoadingState>;
        /** Были ли загружены узлы с сервера */
        childrenLoaded: IAccessor<GenModels.DepartmentTreeNode, boolean>;
        /** Название для отображаемых имён узлов */
        displayNames: IAccessor<GenModels.DepartmentTreeNode, React.ReactNode>;
        /** Идентификаторы родительских узлов */
        parentIDs: IAccessor<GenModels.DepartmentTreeNode, string>;
        /** Выключенные узлы */
        disabled: IAccessor<GenModels.DepartmentTreeNode, boolean>;
        searchInput: HTMLElement;
        constructor(props: IDepartmentSelectDialogProps);
        componentDidMount(): void;
        protected getNodeID: (node: GenModels.DepartmentTreeNode) => string;
        protected getNodeIconClass: (node: GenModels.DepartmentTreeNode) => "dv-ico dv-ico-department" | "dv-ico dv-ico-organisation";
        protected resetStores: () => void;
        readonly selectedDepartment: GenModels.DepartmentTreeNode;
        protected loadTree(parentNode?: GenModels.DepartmentTreeNode): JQueryDeferred<GenModels.DepartmentTreeNode[]>;
        protected loadNodeChild(node: GenModels.DepartmentTreeNode): JQueryPromise<GenModels.DepartmentTreeNode[]>;
        protected searchTree(searchText: string, resultNumber: number): JQueryDeferred<GenModels.DepartmentFindInTreeResult>;
        protected updateNodesVisibility(visibility: boolean, nodes: GenModels.DepartmentTreeNode[], parentNode?: GenModels.DepartmentTreeNode): void;
        protected updateNodesMeta(nodes: GenModels.DepartmentTreeNode[], parentNode?: GenModels.DepartmentTreeNode, enabledItemTypes?: GenModels.SearchDepartmentType): void;
        protected onNodeSelected(node: GenModels.DepartmentTreeNode): void;
        protected onNodeAccepted(node: GenModels.DepartmentTreeNode): void;
        protected onNodeBlur(node: GenModels.DepartmentTreeNode, isSelected: boolean): void;
        protected onNodeToggle(node: GenModels.DepartmentTreeNode): void;
        protected onInputChange(ev: React.ChangeEvent<any>): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected attachSearchInput(el: HTMLElement): void;
        protected onNodeKeyDown(ev: React.KeyboardEvent<any>, node: GenModels.DepartmentTreeNode, flatIndex: number): void;
        protected onContainerKeyDown(ev: React.KeyboardEvent<any>): void;
        protected getSearchResultLabel(): string;
        private resetSearchMode();
        renderSearchResult(nodeName: string, searchText: string, matchedPropertyName: string, matchedPropertyValue: string): JSX.Element;
        renderNode: (index: any, key: any) => JSX.Element;
        /** @internal */
        render(): React.ReactNode;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IDepartmentSelectedNodesPath {
        [departmentId: string]: GenModels.DepartmentModel;
    }
    /** @internal */
    interface IDepartmentSelectDialogFlatProps {
        itemTypes: GenModels.SearchDepartmentType;
        departmentSelected: (node: GenModels.DepartmentModel) => void;
        /** Where to perform the search */
        source: GenModels.DepartmentDataSource;
        /** Тип родительского контрола */
        controlType?: string;
        /** Задержка перед поиском (в мс) */
        searchDelay?: number;
        onSelect?: () => void;
        selectedNode: GenModels.DepartmentModel;
        searchText: string;
        services: $LayoutStaffController;
    }
    /** @internal */
    interface IDepartmentSelectDialogFlatState {
        requestHelper: RequestHelper;
        searchRequestHelper: RequestHelper;
        selectedNode: GenModels.DepartmentModel;
        selectedNodeFocused: boolean;
        /** Список выбранных узлов с прошлых уровней, используется только для навигации с клавиатуры */
        selectedNodesPath: IDepartmentSelectedNodesPath;
        searchResultCount: number;
        showingSearchResults: boolean;
        initialLoading: boolean;
        initialLoadingState: LoadingState;
        breadcrumbsNodes: GenModels.DepartmentModel[];
        childrenListCache: IDepartmentNodeCache;
        searchText: string;
        searchItems: GenModels.DepartmentSearchFlatItem[];
        searchTimerHandle: number;
        searchDebouncer: QuickSearchLogic;
        /** Время последнего изменения справочника */
        directoryTimestamp: number;
        hasMoreSearchItems: boolean;
    }
    interface IDepartmentNodeCacheItem {
        items: GenModels.DepartmentFlatDigest[];
        totalItemsCount: number;
        accessTimestamp: Date;
    }
    interface IDepartmentNodeCache {
        [id: string]: IDepartmentNodeCacheItem;
    }
    /**
     * @internal
     * Компонент не до конца реализован
     */
    class DepartmentSelectDialogFlat extends React.Component<IDepartmentSelectDialogFlatProps, IDepartmentSelectDialogFlatState> {
        static ItemHeight: number;
        static ChildrenPageSize: number;
        static SearchPageSize: number;
        static SimpleItemView: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps & {
            className: string;
        }, any, ISimpleItemViewContentProps & React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps>;
        static SimpleItemViewCompact: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps & {
            className: string;
        }, any, ISimpleItemViewContentProps & React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps>;
        static LoadingNode: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps & {
            className: string;
        }, any, React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeContentDefaultProps>;
        static LoadTreeLevelDown: number;
        static LevelsToExapndByDefault: number;
        reactList: ReactListDynamic;
        recursive: RecursiveVisitor<GenModels.DepartmentFlatDigest>;
        searchInput: HTMLInputElement;
        protected readonly rootId: string;
        constructor(props: IDepartmentSelectDialogFlatProps);
        componentDidMount(): void;
        componentWillUnmount(): void;
        componentWillReceiveProps(newProps: IDepartmentSelectDialogFlatProps): void;
        protected loadInitialDataOnDidMount(): Promise<void>;
        protected getNodeIconClass: (node: GenModels.DepartmentFlatDigest | GenModels.DepartmentSearchFlatItem) => "dv-ico dv-ico-department" | "dv-ico dv-ico-organisation";
        protected readonly currentDepartment: GenModels.DepartmentModel;
        protected readonly currentDepartmentId: string;
        protected readonly rootLabel: string;
        protected readonly currentChildrenCache: IDepartmentNodeCacheItem;
        protected attachSearchInput: (elem: HTMLInputElement) => void;
        protected clearCache(): void;
        protected getDepartmentCache(id?: string): IDepartmentNodeCacheItem;
        protected onModalKeyDown: (ev: any) => void;
        protected onNavigateToFolder: (parentNode?: GenModels.DepartmentModel) => void;
        protected loadPath(departmentId: string): Promise<GenModels.DepartmentModel[]>;
        protected loadChildrenListByIndexes: (indexes: number[]) => void;
        protected loadChildrenList: (parentNodeId: string, start: number, end: number) => JQueryPromise<GenModels.DepartmentLoadFlatResponse>;
        protected onChildrenLoaded(response: GenModels.DepartmentLoadFlatResponse, parentId: string, from: number): void;
        protected search(query: GenModels.DepartmentSearchFlatQuery, reset: boolean): JQueryDeferred<{}>;
        protected isNodeDisabled(node: GenModels.DepartmentTreeNode | GenModels.DepartmentModel, enabledItemTypes?: GenModels.SearchDepartmentType): boolean;
        protected onNodeSelected(node: GenModels.DepartmentModel): void;
        protected onNodeAccepted(node: GenModels.DepartmentModel): void;
        protected onNodeExpanded(node: GenModels.DepartmentFlatDigest | GenModels.DepartmentSearchFlatItem): void;
        protected onNodeSelectSibling: (mode: "next" | "prev", index: number, getCollectionData: () => GenModels.DepartmentFlatDigest[] | GenModels.DepartmentSearchFlatItem[]) => void;
        protected onInputChange(ev: React.ChangeEvent<HTMLInputElement>): void;
        protected onInputKeyUp: (ev: React.KeyboardEvent<any>) => void;
        protected onLoadNewSearchResults: () => void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected getSearchResultLabel(): string;
        protected breadcrumbsOnChange: (nodes: GenModels.DepartmentModel[]) => void;
        protected onSelectedFilterMoveBack: () => void;
        private resetSearchMode;
        protected renderLoadingItem: (index: number, key: string | number) => JSX.Element;
        protected renderEmptyItem: (index: number, key: string | number) => JSX.Element;
        protected onLoadNextSearchPage: (page: any) => JQueryDeferred<{}>;
        protected onSearchPathItemClick: (department: GenModels.DepartmentModel, item: GenModels.DepartmentSearchFlatItem) => void;
        protected renderSearchItem: (index: number, key: string) => JSX.Element;
        protected renderNode: (key: string | number, node: GenModels.DepartmentFlatDigest, index: number) => JSX.Element;
        protected renderGoToButton(node: GenModels.DepartmentFlatDigest | GenModels.DepartmentSearchFlatItem): JSX.Element;
        protected renderItems(): JSX.Element;
        protected renderFlatItems(): JSX.Element;
        protected renderSearchItems(): JSX.Element;
        render(): React.ReactNode;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IDirectoryDesignerRowSelectDialogProps {
        nodeSelected: (node: DirectoryDesignerTreeNode) => void;
        nodeAccepted: (node: DirectoryDesignerTreeNode) => void;
        searchDelay: number;
        rootNodeId: string;
        selectedNodeId?: string;
        selectionArea: GenModels.DirectoryDesignerSearchArea;
        services: $LayoutDirectoryDesignerController;
    }
    /** @internal */
    interface IDirectoryDesignerRowSelectDialogState {
        requestHelper: RequestHelper;
        searchRequestHelper: RequestHelper;
        selectedNode: DirectoryDesignerTreeNode;
        treeWrapper: HTMLElement;
        searchResultCount: number;
        searchResultNumber: number;
        showingSearchResults: boolean;
        searchText: string;
        tree: DynamicTree;
        searchInput: HTMLInputElement;
        searchTimerHandle: number;
    }
    /** @internal */
    class DirectoryDesignerRowSelectDialog extends React.Component<IDirectoryDesignerRowSelectDialogProps, IDirectoryDesignerRowSelectDialogState> {
        static LoadTreeLevelDown: number;
        static LevelsToExapndByDefault: number;
        constructor(props: IDirectoryDesignerRowSelectDialogProps);
        readonly selectedDepartment: DirectoryDesignerTreeNode;
        protected loadTree(parentNode?: ITreeNodeData): JQueryDeferred<IDynamicTreeNodeData[]>;
        protected searchTree(searchText: string, resultNumber: number, searchMode?: GenModels.DirectoryDesignerSearchMode): JQueryDeferred<GenModels.DirectoryDesignerSearchTreeResult>;
        protected expandFirstLevels(nodes: DirectoryDesignerTreeNode[], currentLevel: number, expandLevel?: number): void;
        protected onNodeSelected(node: TreeNode): void;
        protected onNodeAccepted(node: TreeNode): void;
        componentDidMount(): void;
        protected onNextResultClick(): void;
        protected onPrevResultClick(): void;
        protected onInputChange(ev: React.ChangeEvent<any>): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected onTreeFoucsOut(directionUp: boolean): void;
        protected attachSearchInput(el: HTMLInputElement): void;
        protected getSearchResultLabel(): string;
        renderSearchResult(nodeName: string, searchText: string, matchedPropertyName: string, matchedPropertyValue: string): JSX.Element;
        render(): React.ReactNode;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Сотрудник]{@link Employee}.
     */
    class EmployeeParams extends InputBasedControlParams<GenModels.EmployeeDataModel> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Формат отображения во всплывающей подсказке информации о выбранном сотруднике. */
        tipMode?: GenModels.PartnerTipModeItems;
        /**
         * Флаг, указывающий, что при быстром поиске последние выбранные сотрудники должны отображаться в начале списка:
         * true - отображать сначала последних выбранных, false - обычный порядок отображения сотрудников.
         */
        supportFavourites?: boolean;
        /**
         * Флаг, указывающий, что при быстром поиске 10 последних из профиля пользователя должны отображаться в начале списка (актуально для Заданий и ГЗ):
         * true - отображать сначала последних выбранных, false - обычный порядок отображения сотрудников.
         */
        usePerformers?: boolean;
        /** Идентификатор подразделения, из которого можно выбирать сотрудников. Если значение не указано, то можно выбирать из любого подразделения. */
        restrictUnitId?: string;
        /** Список последних выбранных в элементе управления сотрудников. */
        favoriteEmployees?: GenModels.EmployeeDataModel[];
        /** Сервисы. */
        services?: $LayoutStaffController & $EditOperationStore & $LayoutInfo & $LocalStorage;
    }
    /**
     * Класс элемента управления Сотрудник.
     *
     * Добавляет в web-разметку поле ввода с кнопкой вызова диалогового окна для выбора сотрудника из *Справочника сотрудников*.
     */
    class Employee extends InputBasedControl<GenModels.EmployeeDataModel, EmployeeParams, EmployeeState> {
        protected createParams(): EmployeeParams;
        protected createImpl(): EmployeeImpl;
        protected getServices(): $LayoutStaffController & $EditOperationStore & $LayoutInfo & $LocalStorage;
        private readonly employeeImpl;
        private employeeBinding;
        private defaultEmployeeBinding;
        /** Добавление ограничения выбора исполнителей по указанному подразделению/организации. */
        restrictUnitId: string;
        /** Установка всплывающей подсказки. */
        tipMode: any;
        /** Установка вспомогательных исполнителей. */
        supportFavourites: any;
        /** Установка использующихся исполнителей. */
        usePerformers: any;
        /** Получение избранных исполнителей. */
        /** Установка избранных исполнителей. */
        favoriteEmployees: GenModels.EmployeeDataModel[];
        /** Установка новых сервисов. */
        servicesChanged: any;
        /**
         * Добавляет указанного сотрудника в список последних выбранных.
         * @param item Добавляемый сотрудник.
         */
        addToFavorite(item: GenModels.EmployeeDataModel): void;
        protected getBindings(): IBindingResult<any>[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface EmployeeState extends InputBasedControlState<GenModels.EmployeeDataModel>, EmployeeParams {
        lastEmployees: GenModels.EmployeeDataModel[];
        inputKeyDown: SimpleEvent<React.KeyboardEvent<any>>;
        favoritesStorage: FavoriteEmployeesStorage;
        employeeVisualizer: EmployeeVisualizer;
        employeeLoader: EmployeeLoader;
        binding: IBindingResult<GenModels.EmployeeDataModel>;
    }
    type EmployeeImplState = EmployeeState;
    /** @internal */
    class EmployeeImpl extends InputBasedControlImpl<GenModels.EmployeeDataModel, EmployeeParams, EmployeeState> {
        constructor(props: EmployeeParams, state: EmployeeState);
        setValue(value: GenModels.EmployeeDataModel, redraw: boolean): void;
        initHelpers(props: EmployeeParams): void;
        static validValue(value: GenModels.EmployeeDataModel): boolean;
        protected getTextValue(): string;
        protected renderInto(props: EmployeeParams, container: HTMLElement): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected onInputChange(event: any): void;
        protected getValueTitle(): string;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<any>;
        protected getFavoritesStorageName(props: EmployeeParams): string;
        protected onSelected(typeaheadVariant: ITypeaheadVariant): void;
        restrictUnitId: string;
        protected findItems(query: ITypeaheadSearchQuery): JQueryDeferred<ITypeaheadSearchResult>;
        favoriteEmployees: GenModels.EmployeeDataModel[];
        supportFavourites: any;
        tipMode: any;
        protected renderInputWithPlaceholder(): JSX.Element;
        addToFavorite(item: GenModels.EmployeeDataModel): void;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Сотрудники]{@link MultipleEmployees}.
     */
    class MultipleEmployeesParams extends InputBasedControlParams<GenModels.EmployeeDataModel[]> {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Массив выбранных сотрудников. */
        value?: GenModels.EmployeeDataModel[];
        /** Формат отображения во всплывающей подсказке информации о выбранном сотруднике. */
        tipMode?: GenModels.PartnerTipModeItems;
        /**
         * Флаг, указывающий, что при быстром поиске последние выбранные сотрудники должны отображаться в начале списка:
         * true - отображать сначала последних выбранных, false - обычный порядок отображения сотрудников.
         */
        supportFavourites?: boolean;
        /** Флаг, указывающий, что при быстром поиске 10 последних из профиля пользователя должны отображаться в начале списка (актуально для Заданий и ГЗ): true - отображать сначала последних выбранных, false - обычный порядок отображения сотрудников.  */
        usePerformers?: boolean;
        /** Идентификатор подразделения, из которого можно выбирать сотрудников. Если значение не указано, то можно выбирать из любого подразделения. */
        restrictUnitId?: string;
        /** Список последних выбранных в элементе управления сотрудников. */
        favoriteMultipleEmployeess?: GenModels.EmployeeDataModel[];
        /** Флаг, определяющий формат отображения выбранных сотрудников в элементе управления:
        * true - выбранные сотрудники отображаются в виде вертикального списка; false - в виде горизонтального списка.
        */
        verticalOrientation?: boolean;
        /** Путь к полю карточки с идентификатором сотрудника. */
        fieldPath?: string;
        /** События возникает при добавлении сотрудника. */
        addingEmployee?: CancelableApiEvent<GenModels.EmployeeDataModel>;
        /** События возникает после добавления сотрудника. */
        addedEmployee?: BasicApiEvent<GenModels.EmployeeDataModel>;
        /** События возникает при удалении сотрудника из списка. */
        removingEmployee?: CancelableApiEvent<GenModels.EmployeeDataModel>;
        /** События возникает после удаления сотрудника из списка. */
        removedEmployee?: BasicApiEvent<GenModels.EmployeeDataModel>;
        /** Сервисы. */
        services?: $LayoutStaffController & $EditOperationStore & $LayoutInfo & $LocalStorage;
    }
    /**
     * Класс элемента управления Сотрудники.
     *
     * Добавляет в web-разметку поле ввода с кнопкой вызова диалогового окна для выбора нескольких сотрудников из *Справочника сотрудников*.
     */
    class MultipleEmployees extends InputBasedControl<GenModels.EmployeeDataModel[], MultipleEmployeesParams, MultipleEmployeesState> {
        protected createParams(): MultipleEmployeesParams;
        private readonly multipleEmployeeImpl;
        protected getServices(): $LayoutStaffController & $EditOperationStore & $LayoutInfo & $LocalStorage;
        private employeeBinding;
        private defaultMultipleEmployeesBinding;
        /** Добавление ограничения выбора исполнителей по указанному подразделению/организации. */
        restrictUnitId: string;
        /** Установка всплывающей подсказки. */
        tipMode: any;
        /** Установка вспомогательных исполнителей. */
        supportFavourites: any;
        /** Установка использующихся исполнителей. */
        usePerformers: any;
        /** Получение избранных исполнителей. */
        /** Установка избранных исполнителей. */
        favoriteEmployees: GenModels.EmployeeDataModel[];
        /**
         * Добавляет указанного сотрудника в список последних выбранных.
         * @param item Добавляемый сотрудник.
         */
        addToFavorite(item: GenModels.EmployeeDataModel): void;
        protected getBindings(): IBindingResult<any>[];
        /** @internal */
        protected createImpl(): MultipleEmployeesImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface MultipleEmployeesState extends MultipleEmployeesParams, InputBasedControlState<GenModels.EmployeeDataModel[]> {
        binding: IBindingResult<GenModels.MultipleEmployeesDataModel>;
        lastEmployees: GenModels.EmployeeDataModel[];
        inputKeyDown: SimpleEvent<React.KeyboardEvent<any>>;
        favoritesStorage: FavoriteEmployeesStorage;
        employeeVisualizer: EmployeeVisualizer;
        employeeLoader: EmployeeLoader;
    }
    /** @internal */
    type MultipleEmployeesImplState = MultipleEmployeesState;
    /** @internal */
    class MultipleEmployeesImpl extends InputBasedControlImpl<GenModels.EmployeeDataModel[], MultipleEmployeesParams, MultipleEmployeesState> {
        constructor(props: MultipleEmployeesParams, state: MultipleEmployeesState);
        setValue(value: GenModels.EmployeeDataModel[], redraw: boolean): void;
        initHelpers(props: MultipleEmployeesParams): void;
        protected getTextValue(): string;
        hasValue(): boolean;
        protected renderInto(props: MultipleEmployeesParams, container: HTMLElement): void;
        protected onInputKeyDown(ev: React.KeyboardEvent<any>): void;
        protected showEditPopover(popoverOptions?: IEditPopoverProps): JQueryDeferred<any>;
        protected getFavoritesStorageName(props: MultipleEmployeesParams): string;
        protected onSelected(typeaheadVariant: ITypeaheadVariant): void;
        protected onRemoveEmployeeClick(empl: GenModels.EmployeeDataModel, ev: React.MouseEvent<any>): void;
        protected findItems(query: ITypeaheadSearchQuery): JQueryDeferred<ITypeaheadSearchResult>;
        protected getEmployeeTooltip(empl: GenModels.EmployeeDataModel): string;
        restrictUnitId: string;
        tipMode: GenModels.PartnerTipModeItems;
        supportFavourites: boolean;
        favoriteEmployees: GenModels.EmployeeDataModel[];
        protected renderViewEmployeeList(): JSX.Element;
        protected renderWithText(): JSX.Element;
        protected renderEditEmployeeList(): JSX.Element;
        protected renderInputWithPlaceholder(): JSX.Element;
        addToFavorite(item: GenModels.EmployeeDataModel): void;
    }
}
declare namespace WebClient {
    interface IFileListItem {
        data: GenModels.LayoutFileModel;
        file: File;
        state: FileListItemState;
    }
}
declare namespace WebClient {
    /** @internal */
    class FileListItemComponent extends React.Component<FileListItemProps, any> {
        protected fileCommentWindowCloser: () => void;
        logic: FileListControlLogic;
        downloadAction: string;
        versionsRequestHelper: RequestHelper;
        childVersionsLoaded: boolean;
        constructor(props: FileListItemProps);
        componentWillUnmount(): void;
        canRead(fileItem: FileListItem): boolean;
        canEdit(fileItem: FileListItem): boolean;
        canDelete(fileItem: FileListItem): boolean;
        canLock(fileItem: FileListItem): boolean;
        canComment(fileItem: FileListItem): boolean;
        protected onMenuClose(fileItem: FileListItem): void;
        onLockOperationClick(fileItem: FileListItem): void;
        onUnlockOperationClick(fileItem: FileListItem): void;
        protected onDeleteOperationClick(fileItem: FileListItem): void;
        protected onFileMenuClick(fileItem: FileListItem): void;
        protected onDownloadOperationClick(fileItem: FileListItem): void;
        onAddCommentClick(fileItem: FileListItem): void;
        onEditModeRemoveClick(fileItem: FileListItem): void;
        render(): JSX.Element;
        protected getFileVersionText(version: GenModels.VersionedFileModel): string;
        onVersionClick(fileItem: FileListItem): void;
        protected onNameClick(fileItem: FileListItem): void;
        protected onVersionNumberClick(fileItem: FileListItem, version: GenModels.VersionedFileModel): void;
        protected onDownloadVersionClick(fileItem: FileListItem, version: GenModels.VersionedFileModel): void;
        onWebDavFileClick(fileItem: FileListItem): void;
        protected renderViewMode(): JSX.Element;
        protected renderVersionList(fileItem: FileListItem): JSX.Element;
        protected getLoaderWidth(i: number): number;
        protected renderEditMode(item: FileListItem): JSX.Element;
        protected renderMenuItems(fileItem: FileListItem): React.ReactNode[];
        protected renderViewModeFileMenu(fileItem: FileListItem): JSX.Element;
    }
}
declare namespace WebClient {
    const FileListItemPlaceholderWrapper: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListItemPlaceholderIcon: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListItemPlaceholderName: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListItemPlaceholderVersion: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListItemPlaceholderSettings: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    interface FileListItemPlaceholderComponentProps {
        hidden?: boolean;
        index: number;
    }
    const FileListItemPlaceholderComponent: (props: FileListItemPlaceholderComponentProps) => any;
}
declare namespace WebClient {
    /** @internal */
    class FileListItemProps {
        fileListItem: FileListItem;
        mode: EditMode;
        autoUpload: boolean;
        logic: FileListControlLogic;
        renderUploadForm: (attach: FileListAttachedElements, action: string, main?: boolean, fileItem?: FileListItem) => any;
        key: string;
        services: $LayoutFileController & $DeviceType;
    }
}
declare namespace WebClient {
    /** @internal */
    enum FileListItemState {
        /** Added, not uploaded yet */
        New = 0,
        /** Uploading */
        Saving = 1,
        /** Uploaded to the server */
        Saved = 2,
    }
}
declare namespace WebClient {
    const FileListVersionPlaceholderVersion: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListVersionPlaceholderAuthor: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListVersionPlaceholderDate: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListVersionPlaceholderComments: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    const FileListVersionPlaceholderDownload: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    interface IFileListVersionPlaceholder {
        canRead?: boolean;
        hidden?: boolean;
    }
    const FileListVersionPlaceholder: (props: IFileListVersionPlaceholder) => JSX.Element;
}
declare namespace WebClient {
    class FileSign {
        protected crypto: Crypto;
        protected traceProvider: TraceProvider;
        protected interactionModel: IFileSignInteractionModel;
        protected createDialogModalHost: ModalHost;
        protected viewListDialogModalHost: ModalHost;
        protected signOperationHelper: RequestHelper;
        protected services: $SignatureController;
        constructor(interactionModel: IFileSignInteractionModel);
        /** Инициализация. */
        protected initialize(): void;
        /** Отрисовывает диалог для создания подписи. */
        protected renderCreateDialog: () => JSX.Element;
        /** Открыть диалог для создания подписи. */
        protected openCreateDialog: () => void;
        /** @deprecated */
        ShowSignDialog: () => void;
        /** Закрыть диалог для создания подписи. */
        protected closeCreateDialog: () => void;
        /** При подписывании. */
        protected onSign: (selectedCertInfo: ICryptoCertificateInfo, selectedLabel: ISignatureLabel, timestamp: number, signFields?: boolean, signAttachments?: boolean) => void;
        /**
         * Подписать сертификатом с указанным отпечатком и идентификатором метки.
         * @param selectedThumbprint Отпечаток
         * @param selectedLabelId Идентификатор метки
         */
        protected sign(selectedThumbprint: string, selectedLabel: ISignatureLabel, timestamp: number, signFields?: boolean, signAttachments?: boolean): JQueryDeferred<{}>;
        /** Присоединить указанную подпись. */
        protected attachSign(encryptedInfo: EncryptedInfo, selectedLabelId: string, timestamp: number): JQueryDeferred<{}>;
        /** Отрисовывает диалог для просмотра списка подписей. */
        protected renderViewListDialog: () => JSX.Element;
        /** Открывает диалог для просмотра списка подписей. */
        protected openViewListDialog: () => void;
        /** Закрывает диалог для просмотра списка подписей. */
        protected closeViewListDialog: () => void;
        protected onInitViewListDialog: () => void;
        /** Показывает предупреждение при замене версии файла на другую. */
        static showSignWarningDialog(successCb?: Function, cancelCb?: Function): void;
        /** @deprecated Uses {@link showSignWarningDialog} */
        static ShowSignWarningDialog(okFunction: Function): void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFileSignCreateDialogProps {
        /** Идентификатор документа. */
        documentId: string;
        /** Вызывается при подписи. */
        onSign?: (selectedCertInfo: ICryptoCertificateInfo, selectedLabel: ISignatureLabel, timestamp: number, signFields?: boolean, signAttachments?: boolean) => void;
        /** Вызывается при отмене подписи. */
        onCancel?: () => void;
        services: $DocumentCardController;
    }
    /** @internal */
    interface IFileSignCreateDialogState {
        /** Информация о стадии инициализации компонента. */
        initLoading: LoadingState;
        /** Идентификатор выбранной метки для подписи. */
        selectedLabel?: ISignatureLabel;
        /** Идентификатор выбранного варианта подписания подписи (простой или сертификат). */
        selectedModeId: string;
        /** Информация о выбранном сертификате для подписи (если подпись не является простой). */
        selectedCertInfo: ICryptoCertificateInfo;
        /** Необходимо ли подписать Поля */
        signFields?: boolean;
        /** Необходимо ли подписать Дополнения */
        signAttachments?: boolean;
        /** Список меток для подписи. */
        signLabels: ISignatureLabel[];
        /** Пользовательский отпечаток. */
        thumbprint: string;
        /** Таймштамп последнего изменения карточки. */
        timestamp: number;
        /** Экземпляр ModalHost для работы с модальным окном для выбора сертификата. */
        certSelectModalHost: ModalHost;
        /** Видно ли модальное окно для выбора сертификата. */
        isCertSelectVisible: boolean;
    }
    /** @internal */
    class FileSignCreateDialog extends React.Component<IFileSignCreateDialogProps, IFileSignCreateDialogState> {
        static readonly SELECT_CERTIFICATE_MODE: string;
        constructor(props: IFileSignCreateDialogProps);
        /** @internal */
        componentWillMount(): void;
        /** Является ли подпись простой. */
        isSimpleSign: () => boolean;
        /** Обновляет список доступных меток для подписи. */
        updateLabels: () => JQueryDeferred<IFilePreviewModel>;
        /** При изменении варианта подписания подписи. */
        protected onModeChange: (selectedElement: IComboBoxElement) => void;
        /** Получить отформатированный список меток для комбобокса. */
        protected getLabelsForCombobox: () => IComboBoxElement[];
        /** Получить отформатированный список вариантов подписания для комбобокса. */
        protected getModesForCombobox: () => IComboBoxElement[];
        /** Открывает модальное окно для выбора сертификата. */
        protected openCertSelectWindow: () => void;
        /** При закрытии модального окна для выбора сертификата. */
        protected onCloseCertSelectWindow: (selectedCertInfo: ICryptoCertificateInfo) => void;
        /** При подписании. */
        protected onSign: () => void;
        /** При отмене подписания. */
        protected onCancel: () => void;
        /** Отрисовывает модальное окно для выбора сертификата. */
        protected renderSelectCertDialog(): React.ReactNode;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFileSignListDialogProps {
        /** Идентификатор документа. */
        documentId: string;
        /** Вызывается после инициализации окна со списком подписей. */
        onInit?: () => void;
        /** Вызывается при закрытии окна со списком подписей. */
        onClose?: () => void;
        services: $DocumentCardController;
    }
    /** @internal */
    interface IFileSignListDialogState {
        /** Информация о стадии инициализации компонента. */
        initLoading: LoadingState;
        /** Список подписей. */
        signatures: ISignatureListItemDataModel[];
        /** Идентификатор выбранной подписи. */
        selectedSignatureId: string;
    }
    /** @internal */
    class FileSignListDialog extends React.Component<IFileSignListDialogProps, IFileSignListDialogState> {
        validationStateStyle: {
            [key: number]: string;
        };
        constructor(props: IFileSignListDialogProps);
        /** @internal */
        componentWillMount(): void;
        componentDidMount(): void;
        /** Обновляет журнал подписей. */
        update: () => JQueryDeferred<IFilePreviewModel>;
        /** Выполняется при закрытии окна со списком подписей. */
        protected onClose: () => void;
        /**
         * Отрисовывает строку таблицы с информацией о подписи.
         * @param signature Подпись
         * @param index Номер строки
         */
        protected renderRow(signature: ISignatureListItemDataModel, index: number): JSX.Element;
        /**
         * Отрисовывает подробную информацию о подписи.
         * @param signatureId Идентификатор подписи
         */
        protected renderSignatureDetails(signatureId: string, showTimestamp: boolean, detailsColumnCount: number): any[];
        /** Отрисовывает таблицу с информацией о подписях. */
        renderTable(): JSX.Element;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFileSignSelectCertificateDialogProps {
        /** Видно ли окно. */
        isVisible?: boolean;
        /** Вызывается при закрытии данного окна. */
        onClose?: (selectedCertInfo: ICryptoCertificateInfo) => void;
    }
    /** @internal */
    interface IFileSignSelectCertificateDialogState {
        /** Инициализирован ли компонент. */
        isInitialized: boolean;
        /** Выбранный сертификат для подписи. */
        selectedCert: ICryptoCertificate;
        /** Видно ли окно. */
        isVisible: boolean;
        /** Список доступных сертификатов для подписи. */
        certs: ICryptoCertificate[];
        /** Помощник для загрузки данных о списке сертификатов. */
        loadingHelper: RequestHelper;
    }
    /** @internal */
    class FileSignSelectCertificateDialog extends React.Component<IFileSignSelectCertificateDialogProps, IFileSignSelectCertificateDialogState> {
        constructor(props: IFileSignSelectCertificateDialogProps);
        /** @internal */
        componentWillMount(): void;
        /** @internal */
        componentWillReceiveProps(nextProps: IFileSignSelectCertificateDialogProps): void;
        /** Загружаются ли сертификаты в данный момент. */
        readonly isCertsLoading: boolean;
        /** Обновляет список доступных сертификатов. */
        updateCerts: () => JQueryDeferred<ICryptoCertificate[]>;
        /** Показать окно. */
        show: () => void;
        /** Скрыть окно. */
        hide: () => void;
        /** При закрытии окна. */
        protected onClose: () => void;
        /**
         * При нажатии на строку таблицы для выбора сертификата.
         * @param cert Информация о сертификате для данной строки.
         */
        protected onCertRowClick: (cert: ICryptoCertificate) => void;
        /**
         * Отрисовывает строку таблицы для выбора сертификата.
         * @param cert Информация о сертификате для данной строки.
         */
        protected renderCertRow(cert: ICryptoCertificate): JSX.Element;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    interface IFileSignInteractionModel {
        documentId: string;
        getFiles: () => IFileSignInfo[];
        signButton: HTMLElement;
        viewSignButton: HTMLElement;
        beforeSignCallback: () => JQueryDeferred<any>;
        beforeViewSignCallback: () => JQueryDeferred<any>;
        afterSignCallback: Function;
        afterViewSignCallback: Function;
        services: $DocumentCardController;
    }
}
declare namespace WebClient {
    interface IFolderModalProps {
        services: $LayoutFolderController;
    }
    /** @internal */
    class FolderModal extends React.Component<IFolderModalProps, IFolderModalState> {
        folderSelectedEvent: SimpleEvent<GenModels.FolderNode>;
        recursive: RecursiveVisitor<GenModels.FolderNode>;
        /** Уровень папки */
        level: IAccessor<GenModels.FolderNode, number>;
        /** Раскрыта ли папка */
        expanded: IAccessor<GenModels.FolderNode, boolean>;
        /** Видна ли папка */
        visible: IAccessor<GenModels.FolderNode, boolean>;
        /** Были ли загружены подчинённые папки с сервера */
        childrenLoaded: IAccessor<GenModels.FolderNode, boolean>;
        /** Отображает процесс загрузки данных с сервера */
        childrenLoading: IAccessor<GenModels.FolderNode, LoadingState>;
        constructor(props: any);
        componentDidMount(): void;
        readonly selectedFolder: GenModels.FolderNode;
        readonly folderSelected: IBasicEvent<GenModels.FolderNode>;
        protected parseFoldersTreeData(data: Array<GenModels.FolderNode>): Array<GenModels.FolderNode>;
        protected parseServerFolderInfo(src: GenModels.FolderNode, folderInfo: GenModels.FolderNode): void;
        protected onToggleFolder: (folder: GenModels.FolderNode) => void;
        protected onFolderSelected: (folder: GenModels.FolderNode) => void;
        protected updateFoldersMeta(folders: GenModels.FolderNode[], parentFolder?: GenModels.FolderNode): void;
        protected getFlatFolders(treeFolders?: GenModels.FolderNode[]): GenModels.FolderNode[];
        protected getFolderIconClass(folder: GenModels.FolderNode): string;
        renderFolder: (index: any, key: any) => JSX.Element;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IFolderModalState {
        initialLoading: LoadingState;
        tree: Tree;
        folders: GenModels.FolderNode[];
        /** flatFolders зависят от folders, лучше не менять руками */
        flatFolders: GenModels.FolderNode[];
        selectedFolderID: string;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [GridFilterItem]{@link GridFilterItem}.
     */
    class GridFilterItemParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Включен ли параметр в поиск или нет. */
        filterItemEnabled?: boolean;
        /** Имя столбца фильтрации. */
        columnName: string;
        /** Заголовок фильтра. */
        header: string;
        /** Введенное значение фильтра. */
        filterItemValue: string;
        /** Тип данных столбца. */
        columnType?: GenModels.ColumnType;
        /** Состояние панели. */
        expanded?: boolean;
        services?: $DeviceType;
    }
    /**
     * Класс элемента управления для отображения значения фильтра в виде раскрывающейся панели.
     */
    class GridFilterItem extends Panel<GridFilterItemParams, GridFilterItemState> implements IGridFilterItemControl {
        readonly isGridFilterItem: boolean;
        /** @internal */
        init(): void;
        /** Веденое пользователем значение параметра. */
        filterItemValues: string[];
        /** Имя параметра, которое будет передано в поисковый запрос. */
        readonly columnName: string;
        /** Содержит false если ползователь исключил условие из поиска. */
        filterItemEnabled: boolean;
        /** Тип данных столбца */
        readonly columnType: GenModels.ColumnType;
        /** Значение дочернего элемента управления, отвечающего за ввод значения фильтра. */
        contorlValue: any;
        /** Состояние панели */
        filterItemExpanded: boolean;
        /** @internal */
        protected createParams(): GridFilterItemParams;
        /** @internal */
        protected createImpl(): GridFilterItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface GridFilterItemState extends GridFilterItemParams, PanelState {
    }
    /** @internal */
    class GridFilterItemImpl extends PanelImpl<GridFilterItemParams, GridFilterItemState> {
        constructor(props: GridFilterItemParams, state: GridFilterItemState);
        getCssClass(): string;
        toggle(expanded: boolean): void;
        onExpanded(): void;
        getValueControl(): InputBasedControl<any, InputBasedControlParams<any>, InputBasedControlState<any>>;
        renderSwitch(): JSX.Element;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Интрейс, через который поисковая форма взаимодействует с контролами фильтров представления. Реализуется {@link GridFilterItem} */
    interface IGridFilterItemControl {
        /** Должен возвращать true. */
        readonly isGridFilterItem: boolean;
        /** Веденое пользователем значение параметра. */
        filterItemValues: string[];
        /** Имя столбца, которое будет передано в поисковый запрос. */
        readonly columnName: string;
        /** Содержит false если ползователь исключил условие из поиска. */
        filterItemEnabled: boolean;
        readonly columnType: GenModels.ColumnType;
        /** Полное значение контрола, содержащее отображаемое имя и дополнительные сведения. */
        contorlValue: any;
        /** В свернутом состоянии элемент управления для ввода значения не отображается. */
        filterItemExpanded: boolean;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Ссылка]{@link GridFilterItems}.
    */
    class GridFilterItemsParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
    }
    /** @internal */
    interface GridFilterItemsState extends GridFilterItemsParams, PanelState {
    }
    /**
     * Контрол для отображения кнопки сброса фильтра
     */
    class GridFilterItems extends Panel<GridFilterItemsParams, GridFilterItemsState> {
        /** @internal */
        protected createParams(): GridFilterItemsParams;
        /** @internal */
        protected createImpl(): GridFilterItemsImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    type GridFilterItemsImplImplState = GridFilterItemsState;
    /** @internal */
    class GridFilterItemsImpl extends PanelImpl<GridFilterItemsParams, GridFilterItemsImplImplState> {
        constructor(props: GridFilterItemsParams, state: GridFilterItemsImplImplState);
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Ссылка]{@link GridFilterClearButton}.
    */
    class GridFilterResetButtonParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        services?: $Layout;
    }
    /** @internal */
    interface GridFilterResetButtonState extends GridFilterResetButtonParams, BaseControlState {
    }
    /**
     * Контрол для отображения кнопки сброса фильтра
     */
    class GridFilterResetButton extends BaseControl<GridFilterResetButtonParams, GridFilterResetButtonState> {
        constructor(props: any);
        /** @internal */
        protected createParams(): GridFilterResetButtonParams;
        /** @internal */
        protected createImpl(): ControlImpl;
        /** @internal */
        protected onClick(): void;
        /** @internal */
        protected renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface HistoryViewProps {
        previewRecords: GenModels.HistoryRecord[];
        employeeVisualiser: EmployeeVisualizer;
        external: HistoryExternalRelations;
        pageSize: number;
        autoLoadScrollGap?: number;
        onRecordsChanged?: (records: GenModels.HistoryRecord[]) => void;
        /** Restricts height and enables scroll for modal window view. */
        modalMode: boolean;
        showFilters: boolean;
        autoLoadOnScroll: boolean;
        useTableMode?: boolean;
        operationsToHide: string[];
        cacheId: string;
        editOperation: string;
    }
    /** @internal */
    interface HistoryViewState {
        loader: RequestHelper;
        records: GenModels.HistoryRecord[];
        cacheId: string;
        authorNameFilter: Employee;
        dateFilter: DateTimePicker;
        eventSearch: TextBox;
        hasMore: boolean;
        bodyScrollContainer: HTMLElement;
        quickSearchLogic: QuickSearchLogic;
    }
    /** @internal */
    class HistoryView extends React.Component<HistoryViewProps, HistoryViewState> {
        constructor(props: HistoryViewProps);
        componentDidMount(): void;
        loadRecords(authorNameFilter?: string, dateFilter?: Date, eventSearch?: string, pageSize?: number): JQueryDeferred<GenModels.HistorySearchResult>;
        loadNextPage(pageSize?: number): JQueryDeferred<GenModels.HistorySearchResult>;
        reload(): void;
        onRecordsChanged(): void;
        isScrolledDown(elem: HTMLElement): boolean;
        loadIfScrollDown(): void;
        onBodyScroll(ev: React.UIEvent<any>): void;
        attachTableBodyContainer(elem: HTMLElement): void;
        onEmployeeChanged(sender: any, args: IDataChangedEventArgs): void;
        onDateChanged(sender: any, args: IDataChangedEventArgs): void;
        onEventSearchChanged(sender: any, args: IDataChangedEventArgs): void;
        renderTableHeader(): JSX.Element;
        renderTableBody(): JSX.Element;
        render(): JSX.Element;
        attachAuthorFilter(control: Employee): void;
        attachDateFilter(control: DateTimePicker): void;
        attachEventFilter(control: TextBox): void;
        records: GenModels.HistoryRecord[];
        authorFilterValue: GenModels.EmployeeDataModel;
        dateFilterValue: Date;
        eventFilterValue: string;
    }
}
declare namespace WebClient {
    /** @internal  */
    interface IAddUrlDialogProps {
        onClose: () => void;
        onAdd: (url: string, linkType: string) => void;
        isOpened: boolean;
        linkTypes?: GenModels.LinkTypeModel[];
    }
    /** @internal */
    interface IAddUrlDialogState {
        isValid: boolean;
        url: string;
        comboBoxVariants: IComboBoxVariant[];
        selectedLinkType: IComboBoxVariant;
        expanded: boolean;
        services: $LayoutLinksController & $EditOperationStore;
    }
    /** @internal
     * Модальное окно добавления Url
     */
    class AddUrlDialog extends React.Component<IAddUrlDialogProps, IAddUrlDialogState> {
        constructor(props: IAddUrlDialogProps);
        /** Закрытие модального окна. */
        protected closeModal: () => void;
        protected onLinkAdd: () => void;
        protected onLinkTypeSelect: (variant: IComboBoxVariant) => void;
        protected loadLinkTypes: () => void;
        protected onUrlChanged: (sender: any, e: IDataChangedEventArgs) => void;
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class ExistingCardLinkDialog {
        ownedLayout: Layout;
        bindingInfo: GenModels.SimpleBindingInfo;
        editOperation: string;
        saveHardLink: boolean;
        allowedLinkTypes: string[];
        allowedCardTypes: string[];
        services: $LayoutLinksController;
        constructor(ownedLayout: Layout, bindingInfo: GenModels.SimpleBindingInfo, saveHardLink: boolean, allowedLinkTypes: string[], allowedCardTypes: string[], editOperation: string, services?: $LayoutLinksController);
        showExistingCardLinkDialog(doneCallback: (model: GenModels.LinksDataModel) => void): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class LinkInfoPopover extends React.Component<ILinkInfoPopoverProps, ILinkInfoPopoverState> {
        constructor(props: ILinkInfoPopoverProps);
        onTextClick(event: React.MouseEvent<any>): void;
        beginEdit(): void;
        saveComment(): void;
        onSaveClick(): void;
        onCommentChange(event: React.SyntheticEvent<any>): void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILinkInfoPopoverProps {
        linkItem: LinkItem;
        bindingInfo: GenModels.SimpleBindingInfo;
        iconClass: string;
        editAvailable: boolean;
        onSaved: (model: GenModels.LinksDataModel) => void;
        onTitleClick?: (item: LinkItem) => void;
        maxCommentLength?: number;
        linkInfoEditing: CancelableEvent<ILinkEventArgs>;
        linkInfoEdited: (item: LinkItem) => void;
        ownedLayout: Layout;
        services: $LayoutLinksController;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILinkInfoPopoverState {
        editInProcess: boolean;
        saving: boolean;
        commentText: string;
        tooLongError: boolean;
        maxCommentLength: number;
        commentEditInput: HTMLTextAreaElement;
    }
}
declare namespace WebClient {
    /** @internal */
    interface INewCardLinkDialogProps {
        kinds: GenModels.LayoutKindModel[];
        linkTypes: GenModels.LinkTypeModel[];
        onKindSelected?: (sender: NewCardLinkDialog, args: NewCardLinkDialogArgs) => void;
        onLinkTypeSelect?: (sender: NewCardLinkDialog, args: NewCardLinkDialogArgs) => void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface INewCardLinkDialogState {
        selectedKind: GenModels.LayoutKindModel;
        selectedLinkType: GenModels.LinkTypeModel;
        treeNodes: KindTreeNodeData[];
        tree: Tree;
        root: HTMLElement;
    }
}
declare namespace WebClient {
    /** @internal */
    class NewCardLinkDialog extends React.Component<INewCardLinkDialogProps, INewCardLinkDialogState> {
        buttonOkEvent: SimpleEvent<NewCardLinkDialogArgs>;
        kindSelectedEvent: SimpleEvent<NewCardLinkDialogArgs>;
        linkTypeSelectedEvent: SimpleEvent<NewCardLinkDialogArgs>;
        constructor(props: INewCardLinkDialogProps);
        readonly buttonOkClicked: SimpleEvent<NewCardLinkDialogArgs>;
        readonly selectedKind: GenModels.LayoutKindModel;
        readonly selectedLinkType: GenModels.LinkTypeModel;
        static ShowDialog(kinds: GenModels.LayoutKindModel[], linkTypes: GenModels.LinkTypeModel[], uniqueControlKey: string, okCallback: (sender: any, data: NewCardLinkDialogArgs) => void): void;
        protected loadTreeNodes(kinds: GenModels.LayoutKindModel[]): KindTreeNodeData[];
        protected attachTree(tree: Tree): void;
        protected onKindSelected(sender: any, node: TreeNode): void;
        protected onLinkTypeSelect(val: LinkTypeComboBoxVariant): void;
        protected getLinkTypeComboBoxProps(): any;
        componentDidMount(): void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link BaseMainMenuItem}.
     */
    class BaseMainMenuItemParams extends PanelParams {
        /** Текст метки. */
        text: string;
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Класс иконки */
        iconClass?: string;
        /** Определяет, должен ли элемент управления отображаться в компактном режиме, в котором у элемента будет меньший визуальный размер. */
        compact?: boolean;
        /** Выбран ли элемент меню */
        isSelected?: boolean;
        /** Уровень вложенности элемента меню */
        level?: number;
        /** Количество уровней, на которое данный элемент меню и его дочерние элементы автоматически раскрываются */
        expandChildrenLevel?: number;
        /** Раскрыт ли элемент меню */
        isExpanded?: boolean;
        /** Можно ли настраивать элемент меню (например, скрывать) */
        configurable?: boolean;
        /** Находится ли меню в данный момент в режиме настройки или нет */
        isConfigurationModeEnabled?: boolean;
        /** Скрыт ли элемент меню через настройки */
        isConfiguredToHide?: boolean;
        /** Событие, возникающее перед началом переключения состояния раскрытости элемента меню */
        expandedToggling?: CancelableApiEvent<boolean>;
        /** Событие, возникающее после переключения состояния раскрытости элемента меню */
        expandedToggled?: BasicApiEvent<boolean>;
        /** Событие, возникающее перед выбором элемента меню */
        selecting?: CancelableApiEvent<boolean>;
        /** Событие, возникающее после выбора элемента меню */
        selected?: BasicApiEvent<boolean>;
        /** Событие, возникающее после переключения режима видимости элемента меню */
        configuredToHideToggled?: BasicApiEvent<boolean>;
    }
    /**
     * Базовый класс для элементов главного меню.
     */
    abstract class BaseMainMenuItem<PropsT extends BaseMainMenuItemParams, StateT extends BaseMainMenuItemState> extends Panel<PropsT, StateT> {
        private baseMainMenuItemImpl();
        private textResourceKey;
        private compact;
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected level: number | string;
        /** @internal */
        protected expanded: string | boolean;
        /** @internal */
        protected isConfigurationModeEnabled: boolean;
        /** @internal */
        protected isConfiguredToHide: boolean | string;
        /** @internal */
        protected configurable: boolean | string;
        /** @internal */
        protected expandChildrenLevel: string;
        /**
         * Является ли контрол контролом для главного меню. Через это свойство данные контролы можно отличать от других.
         */
        readonly isMainMenuItem: boolean;
        /** @internal */
        protected readonly baseItemImpl: BaseMainMenuItemImpl<BaseMainMenuItemParams, any>;
        /** @internal */
        protected selected: boolean;
        /**
         * Раскрыть всех родительские элементы меню
         */
        expandAllParents(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface BaseMainMenuItemState extends BaseMainMenuItemParams, PanelState {
    }
    /** @internal */
    type BaseMainMenuItemImplState = BaseMainMenuItemState;
    /** @internal */
    class BaseMainMenuItemImpl<PropsT extends BaseMainMenuItemParams, StateT extends BaseMainMenuItemState> extends PanelImpl<PropsT, StateT> {
        constructor(props: PropsT, state?: StateT);
        componentWillMount(): void;
        onSelecting(): CancelableEventArgs<boolean>;
        onSelected(): void;
        onToggling(): CancelableEventArgs<boolean>;
        onToggled(): void;
        protected onClick(event: React.MouseEvent<any>): void;
        protected getCssClass(): string;
        protected onConfiguredToHideToggled: () => void;
        protected getAutoExpandLevelsCount: () => number;
        protected getChildrenAutoExpandLevelsCount: () => number;
        protected canAutoExpand: () => boolean;
        protected autoExpand(): void;
        protected renderChildren(children?: GenModels.ControlModel[]): React.ReactNode[];
        renderSelfContentItems(): (JSX.Element | JSX.Element[])[];
        renderSelfContent(): JSX.Element;
        renderSelf(): JSX.Element;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления {@link BaseNavigationMainMenuItem}.
    */
    class BaseNavigationMainMenuItemParams extends BaseMainMenuItemParams {
        /** Время последней активации элемента меню */
        lastActivationTimestamp?: Date;
        /** Адрес для перехода */
        navigationHref?: string;
    }
    /**
     * Базовый класс для контролов главного меню, представляющих ссылки на страницы ЛК.
     */
    abstract class BaseNavigationMainMenuItem<PropsT extends BaseNavigationMainMenuItemParams, StateT extends BaseNavigationMainMenuItemState> extends BaseMainMenuItem<PropsT, StateT> {
        constructor(props: PropsT);
        /** @internal */
        init(): void;
        /** @internal */
        readonly navigationHref: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface BaseNavigationMainMenuItemState extends BaseNavigationMainMenuItemParams, BaseMainMenuItemState {
    }
    /** @internal */
    type BaseNavigationMainMenuItemImplState = BaseNavigationMainMenuItemState;
    /** @internal */
    abstract class BaseNavigationMainMenuItemImpl<PropsT extends BaseNavigationMainMenuItemParams, StateT extends BaseNavigationMainMenuItemState> extends BaseMainMenuItemImpl<PropsT, StateT> {
        constructor(props: PropsT, state: StateT);
        onContentClick(): void;
        protected getCssClass(): string;
        abstract getNavigationHref(): string;
        renderSelfContent(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [ConfigurableMainMenuContainer]{@link ConfigurableMainMenuContainer}.
     */
    class ConfigurableMainMenuContainerParams extends BaseMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Настройки главного меню */
        mainMenuSettings: GenModels.MainMenuSettings;
        /** Началась ли настройка меню */
        isConfigurationStarted?: boolean;
        /** Событие, возникающее перед началом настройки меню */
        configurationStarting?: CancelableApiEvent<void>;
        /** Событие, возникающее после начала настройки меню */
        configurationStared?: BasicApiEvent<void>;
        /** Событие, возникающее перед сохранением настроек меню */
        configurationSaving?: CancelableApiEvent<GenModels.MainMenuSettings>;
        /** Событие, возникающее после сохранении настроек меню */
        configurationSaved?: BasicApiEvent<GenModels.MainMenuSettings>;
        /** Событие, возникающее перед завершением настройки меню */
        configurationFinishing?: CancelableApiEvent<boolean>;
        /** Событие, возникающее после завершения настройки меню */
        configurationFinished?: BasicApiEvent<boolean>;
        services?: $LayoutUserSettingsController & $ControlStore;
    }
    /**
     * Контейнер для хранения элементов меню, реализующий логику скрытия элементов меню пользователем.
     */
    class ConfigurableMainMenuContainer extends BaseMainMenuItem<ConfigurableMainMenuContainerParams, ConfigurableMainMenuContainerState> {
        constructor(props: any);
        /** @internal */
        protected createParams(): ConfigurableMainMenuContainerParams;
        /** @internal */
        protected mainMenuSettings: GenModels.MainMenuSettings;
        /** @internal */
        protected childrenHandler: GenModels.ControlModel[];
        /**
         * Скрытие элементов меню, указанных в настройках меню
         * @param current Элемент меню
         */
        hideItemModels(current: GenModels.ControlModel): void;
        /** Начало настройки */
        beginConfiguration(): void;
        /** Сброс настроек */
        resetSettings(): Promise<void>;
        /** @internal */
        protected toggleConfigurationMode(current: LayoutControl, enabled: boolean): void;
        /**
         * Завершение настроек
         * @param accepted Приняты ли изменения или отменены
         */
        finishConfigurationMode(accepted: boolean): Promise<void>;
        /** @internal */
        protected applyMainMenuSettings(settings: GenModels.MainMenuSettings): void;
        /** @internal */
        protected onControlConfigredToHide: (sender: BaseMainMenuItem<BaseMainMenuItemParams, any>, configuredToHide: boolean) => void;
        /** @internal */
        protected saveSettings(settings: GenModels.MainMenuSettings): JQueryDeferred<void>;
        /** @internal */
        protected createImpl(): ConfigurableMainMenuContainerImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ConfigurableMainMenuContainerState extends ConfigurableMainMenuContainerParams, BaseMainMenuItemState {
        /** Список контролов для скрытия */
        controlsToHide: BaseMainMenuItem<BaseMainMenuItemParams, any>[];
        /** Принятие изменений настройки меню */
        acceptChanges: () => void;
        /** Отмена изменений настройки меню */
        cancelChanges: () => void;
    }
    /** @internal */
    type ConfigurableMainMenuContainerImplState = ConfigurableMainMenuContainerState;
    /** @internal */
    class ConfigurableMainMenuContainerImpl extends BaseMainMenuItemImpl<ConfigurableMainMenuContainerParams, ConfigurableMainMenuContainerState> {
        constructor(props: ConfigurableMainMenuContainerParams, state: ConfigurableMainMenuContainerState);
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link ConnectConfigurableMainMenuContainerButtonScript}.
     */
    class ConnectConfigurableMainMenuContainerButtonScriptParams extends LayoutScriptParams {
        /** Название контрола контейнера с настраиваемыми элементами меню */
        configurableContainerName: string;
        /** Название контрола кнопки для настройки меню */
        buttonName: string;
    }
    /** @internal */
    interface ConnectConfigurableMainMenuContainerButtonScriptState extends ConnectConfigurableMainMenuContainerButtonScriptParams, LayoutScriptState {
    }
    /**
     * Класс для связывания настраиваемого контейнера главного меню и кнопки настройки
     */
    class ConnectConfigurableMainMenuContainerButtonScript extends LayoutScript<ConnectConfigurableMainMenuContainerButtonScriptParams, ConnectConfigurableMainMenuContainerButtonScriptState> {
        private container;
        private pinButton;
        /** @internal */
        protected createParams(): ConnectConfigurableMainMenuContainerButtonScriptParams;
        /** @internal */
        init(): void;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [CustomHtmlPageMainMenuItem]{@CustomHtmlPage CustomHtmlPageMainMenuItem}.
    */
    class CustomHtmlPageMainMenuItemParams extends BaseNavigationMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Адрес, по которому располагается произвольная html страница */
        url: string;
        /** Заголовок страницы */
        header: string;
        /** Цвет страницы */
        color: string;
    }
    /**
     * Контрол для отображения ссылки на страницу Web-клиента в списке элементов главной панели.
     */
    class CustomHtmlPageMainMenuItem extends BaseNavigationMainMenuItem<CustomHtmlPageMainMenuItemParams, CustomHtmlPageMainMenuItemState> {
        /** @internal */
        protected createParams(): CustomHtmlPageMainMenuItemParams;
        private headerResourceKey;
        /** @internal */
        protected createImpl(): CustomHtmlPageMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface CustomHtmlPageMainMenuItemState extends CustomHtmlPageMainMenuItemParams, BaseNavigationMainMenuItemState {
    }
    /** @internal */
    type CustomHtmlPageMainMenuItemImplState = CustomHtmlPageMainMenuItemState;
    /** @internal */
    class CustomHtmlPageMainMenuItemImpl extends BaseNavigationMainMenuItemImpl<CustomHtmlPageMainMenuItemParams, CustomHtmlPageMainMenuItemState> {
        constructor(props: CustomHtmlPageMainMenuItemParams, state: CustomHtmlPageMainMenuItemState);
        getNavigationHref(): string;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [FolderMainMenuItem]{@link FolderMainMenuItem}.
    */
    class FolderMainMenuItemParams extends BaseNavigationMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Информация о папке */
        folderInfo: GenModels.FolderNode;
        /** Цвет страницы */
        color?: string;
        /** Идентификатор папки */
        folderId?: string;
        /** Показывать ли подпапки */
        showSubfolders?: boolean;
        /** Показывать ли сам элемент меню или только его содержимое */
        showRoot?: boolean;
        /** Количество подуровней элемента, которые будут автоматически предзагружены */
        subfoldersPreloadLevel?: number;
        /** Компактное представление для подэлементов */
        compactChildren?: boolean;
        /** Показывать ли иконку */
        showIcon?: boolean;
        /** Показывать ли иконки подэлементов меню */
        showChildrenIcons?: boolean;
        /** */
        forceToggleIdent?: boolean;
        /** Раскрыт ли элемент меню */
        isExpanded?: boolean;
        /** Количество непросмотренных карточек в папке */
        unreadCount?: number;
        /** Принудительный поиск в виртуальной папке */
        forceVirtualFolderSearch?: boolean;
        services?: $LayoutFolderController & $ControlStore;
    }
    /**
     * Контрол для отображения ссылки на папку в списке элементов главной панели.
     */
    class FolderMainMenuItem extends BaseNavigationMainMenuItem<FolderMainMenuItemParams, FolderMainMenuItemState> implements IProxyControl {
        constructor(props: any);
        /**
         * Является ли контрол контролом для папки главного меню, таким образом их можно отличать от других.
         */
        readonly isFolderMainMenuItem: boolean;
        /** @internal */
        init(): void;
        /** @internal */
        deinit(): void;
        /** @internal */
        protected createParams(): FolderMainMenuItemParams;
        /** @internal */
        protected showSubfolders: string | boolean;
        /** @internal */
        protected showRoot: string | boolean;
        /** @internal */
        protected subfoldersPreloadLevel: string | number;
        /** @internal */
        protected expanded: string | boolean;
        /** @internal */
        protected compactChildren: string | boolean;
        /** @internal */
        protected showIcon: string | boolean;
        /** @internal */
        protected showChildrenIcons: string | boolean;
        /** @internal */
        protected forceToggleIdent: string | boolean;
        /** @internal */
        protected forceVirtualFolderSearch: string | boolean;
        /** @internal */
        protected folderInfo: GenModels.FolderNode;
        /**
         * Является ли элемент меню проксирующим, то есть видны только подэлементы, а сам данный элемент меню не виден
         */
        readonly isProxyControl: boolean;
        /**
         * Отрисовка содержимого проксирующего элемента меню
         */
        renderProxyChildren(): React.ReactNode[];
        /**
         * Загрузка подпапок на указанное количество уровней
         * @param levelsCount Количество уровней для загрузки
         */
        loadSubfoldersDownTo(levelsCount: number): Promise<void>;
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected level: number | string;
        /** @internal */
        protected isConfiguredToHide: boolean;
        /** @internal */
        componentDidUpdate(prevProps: any, prevState: any, prevContext: any): void;
        /**
         * Подписывание на событие изменение счётчика содержимого для данной папки
         */
        subscribeToUnreadCount(): void;
        /**
         * Отписывание от события изменения счётчика содержимого для данной папки
         */
        unsubscribeFromUnreadCount(): void;
        /**
         * При изменении счётчика содержимого данной папки
         */
        onUnreadCountChanged(): void;
        /**
         * Запрос на пересчёт счётчика содержимого для данной папки
         */
        addUnreadCountRequest(): void;
        private generateControlName;
        /** @internal */
        protected createImpl(): FolderMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface FolderMainMenuItemState extends FolderMainMenuItemParams, BaseNavigationMainMenuItemState {
        /**
         * Загрузка вместе с подэлементами до нужного уровня
         * @param levelCount Количество уровней
         */
        loadWithChildren(levelCount?: number): JQueryDeferred<GenModels.FolderNode>;
        /**
         * Генерирование имени контрола
         * @param folderId Идентификатор папки
         */
        generateControlName(folderId: string): string;
        loader: RequestHelper;
        controlNames: {
            [folderId: string]: string;
        };
    }
    /** @internal */
    type FolderMainMenuItemImplState = FolderMainMenuItemState;
    /** @internal */
    class FolderMainMenuItemImpl extends BaseNavigationMainMenuItemImpl<FolderMainMenuItemParams, FolderMainMenuItemState> {
        constructor(props: FolderMainMenuItemParams, state: FolderMainMenuItemState);
        generateControlName(folderId: string): void;
        protected getAutoExpandLevelsCount: () => number;
        protected getChildrenAutoExpandLevelsCount: () => number;
        protected canAutoExpand: () => boolean;
        protected autoExpand(): Promise<void>;
        renderChildren(): React.ReactNode[];
        protected hasSubfolders(): boolean;
        loadChildren(levelsDown?: number): JQueryDeferred<GenModels.FolderNode>;
        onToggleClick(ev: React.MouseEvent<any>): void;
        toggleInternal(): Promise<void>;
        getNavigationHref(): string;
        onContentClick(): void;
        protected getIconClass(): string;
        protected getUnreadCount(): number;
        renderSelfContent(): JSX.Element;
        protected getCssClass(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [GroupFoldersMainMenuItem]{@GroupFolders GroupFoldersMainMenuItem}.
     */
    class GroupFoldersMainMenuItemParams extends BaseMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Раскрыт ли элемент меню */
        isExpanded?: boolean;
        /** Показывать ли сам элемент меню или только его содержимое */
        showRoot?: boolean;
        /** Количество подуровней элемента, которые будут автоматически предзагружены */
        foldersPreloadLevel?: number;
        /** Компактное представление для папок */
        compactFolders?: boolean;
        /** Показывать ли иконки */
        showIcons?: boolean;
    }
    /**
     * Контрол для отображения папок группы/роли в списке элементов главной панели.
     */
    class GroupFoldersMainMenuItem extends BaseMainMenuItem<GroupFoldersMainMenuItemParams, GroupFoldersMainMenuItemState> implements IProxyControl {
        /** @internal */
        protected createParams(): GroupFoldersMainMenuItemParams;
        /** @internal */
        protected showRoot: string | boolean;
        /** @internal */
        protected expanded: string | boolean;
        /** @internal */
        protected level: number | string;
        /**
         * Является ли элемент меню проксирующим, то есть видны только подэлементы, а сам данный элемент меню не виден
         */
        readonly isProxyControl: boolean;
        /**
         * Отрисовка содержимого проксирующего элемента меню
         */
        renderProxyChildren(): React.ReactNode[];
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected createImpl(): GroupFoldersMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface GroupFoldersMainMenuItemState extends GroupFoldersMainMenuItemParams, BaseMainMenuItemState {
    }
    /** @internal */
    type GroupFoldersMainMenuItemImplState = GroupFoldersMainMenuItemState;
    /** @internal */
    class GroupFoldersMainMenuItemImpl extends BaseMainMenuItemImpl<GroupFoldersMainMenuItemParams, GroupFoldersMainMenuItemState> {
        constructor(props: GroupFoldersMainMenuItemParams, state: GroupFoldersMainMenuItemState);
        protected onClick(event: React.MouseEvent<any>): void;
        protected canAutoExpand: () => boolean;
        protected getChildrenAutoExpandLevelsCount: () => number;
        renderProxyChildren(): React.ReactNode[];
        protected getCssClass(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Страница]{@link Page}.
    */
    class GroupMainMenuItemParams extends BaseMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Раскрыт ли элемент меню */
        isExpanded?: boolean;
        /** Показывать ли сам элемент меню или только его содержимое */
        showRoot?: boolean;
    }
    /**
     * Контрол для отображения группы элементов в главной панели
     */
    class GroupMainMenuItem extends BaseMainMenuItem<GroupMainMenuItemParams, GroupMainMenuItemState> implements IProxyControl {
        /** @internal */
        protected showRoot: string | boolean;
        /** @internal */
        protected level: number | string;
        /**
         * Является ли элемент меню проксирующим, то есть видны только подэлементы, а сам данный элемент меню не виден
         */
        readonly isProxyControl: boolean;
        /**
         * Отрисовка содержимого проксирующего элемента меню
         */
        renderProxyChildren(): React.ReactNode[];
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected createParams(): GroupMainMenuItemParams;
        /** @internal */
        protected createImpl(): GroupMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface GroupMainMenuItemState extends GroupMainMenuItemParams, BaseMainMenuItemState {
    }
    /** @internal */
    type GroupMainMenuItemImplState = GroupMainMenuItemState;
    /** @internal */
    class GroupMainMenuItemImpl extends BaseMainMenuItemImpl<GroupMainMenuItemParams, GroupMainMenuItemState> {
        constructor(props: GroupMainMenuItemParams, state: GroupMainMenuItemState);
        protected onClick(event: React.MouseEvent<any>): void;
        protected canAutoExpand: () => boolean;
        protected getChildrenAutoExpandLevelsCount: () => number;
        renderProxyChildren(): React.ReactNode[];
        protected getCssClass(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления {@link LayoutPageMainMenuItem}.
    */
    class LayoutPageMainMenuItemParams extends BaseMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Имя позиции, которое будет использовано для получения разметки */
        position: string;
        /** Заголовок страницы */
        header: string;
        /** Цвет страницы */
        color: string;
    }
    /**
     * Класс элемента управления главного меню, служащего для открытия разметки.
     */
    class LayoutPageMainMenuItem extends BaseMainMenuItem<LayoutPageMainMenuItemParams, LayoutPageMainMenuItemState> {
        /** @internal */
        protected createParams(): LayoutPageMainMenuItemParams;
        private headerResourceKey;
        /** @internal */
        protected createImpl(): LayoutPageMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface LayoutPageMainMenuItemState extends LayoutPageMainMenuItemParams, BaseMainMenuItemState {
    }
    /** @internal */
    type LayoutPageMainMenuItemImplState = LayoutPageMainMenuItemState;
    /** @internal */
    class LayoutPageMainMenuItemImpl extends BaseMainMenuItemImpl<LayoutPageMainMenuItemParams, LayoutPageMainMenuItemState> {
        constructor(props: LayoutPageMainMenuItemParams, state: LayoutPageMainMenuItemState);
        renderSelfContent(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Ссылка]{@link LinkMainMenuItem}.
    */
    class LinkMainMenuItemParams extends BaseNavigationMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /**
         * Значение атрибута href для html-элемента `<a>`.
         * Для указания страницы Web-клиента используйте путь, начинающийся с `#`. Например, `#/Dashboard`.
         */
        href: string;
        /** Значение атрибута hreflang для html-элемента `<a>` */
        hreflang?: string;
        /** Значение атрибута target для html-элемента `<a>` */
        target?: string;
        /** Значение атрибута accesskey для html-элемента `<a>` */
        accesskey?: string;
        /** Значение атрибута download для html-элемента `<a>` */
        download?: boolean;
        /** Значение атрибута type для html-элемента `<a>` */
        type?: string;
    }
    /**
     * Контрол для отображения ссылки на страницу Web-клиента в списке элементов главной панели.
     */
    class LinkMainMenuItem extends BaseNavigationMainMenuItem<LinkMainMenuItemParams, LinkMainMenuItemState> {
        /** @internal */
        protected createParams(): LinkMainMenuItemParams;
        click(): void;
        /** @internal */
        protected createImpl(): LinkMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface LinkMainMenuItemState extends LinkMainMenuItemParams, BaseNavigationMainMenuItemState {
        navigationClickElement: MainMenuHelpers.NavigationLink;
    }
    /** @internal */
    type LinkMainMenuItemImplState = LinkMainMenuItemState;
    /** @internal */
    class LinkMainMenuItemImpl extends BaseNavigationMainMenuItemImpl<LinkMainMenuItemParams, LinkMainMenuItemState> {
        constructor(props: LinkMainMenuItemParams, state: LinkMainMenuItemState);
        getNavigationHref(): string;
        attach: (element: MainMenuHelpers.NavigationLink) => void;
        click: () => void;
        renderSelfContent(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [ConnectPinButtonToMainMenuScript]{@link ConnectPinButtonToMainMenuScript}.
     */
    class ConnectPinButtonToMainMenuScriptParams extends LayoutScriptParams {
        /** Название контрола с главным меню */
        mainMenuName: string;
        /** Название контрола с кнопкой прикрепления меню */
        pinButtonName: string;
        /** Класс иконки для прикрепления меню */
        pinIconClassName?: string;
        /** Класс иконки для открепления меню */
        unpinIconClassName?: string;
        services?: $ControlStore;
    }
    /** @internal */
    interface ConnectPinButtonToMainMenuScriptState extends ConnectPinButtonToMainMenuScriptParams, LayoutScriptState {
    }
    /**
     * Класс для связывания главного меню и кнопки его прикрепления/открепления
     */
    class ConnectPinButtonToMainMenuScript extends LayoutScript<ConnectPinButtonToMainMenuScriptParams, ConnectPinButtonToMainMenuScriptState> {
        private mainMenu;
        private pinButton;
        /** @internal */
        protected createParams(): ConnectPinButtonToMainMenuScriptParams;
        /** @internal */
        init(): void;
        /**
         * При нажатии на кнопку прикрепления меню
         */
        onPinButtonClick(): void;
        /**
         * При появлении/скрытии меню
         */
        onMenuToggle: (sender: BaseControl<BaseControlParams, BaseControlState>, data: boolean) => void;
        /**
         * Обновление иконки прикрепления меню
         */
        updateIcon(): void;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления [Основное меню]{@link MainMenu}.
    */
    class MainMenuParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Прикреплено ли меню */
        isPinned?: boolean;
        /** Событие, возникающее после появления/скрытия меню */
        toggle?: BasicApiEvent<boolean>;
    }
    /**
     * Класс элемента управления Основное меню.
     */
    class MainMenu extends Panel<MainMenuParams, MainMenuState> {
        /** @internal */
        protected createParams(): MainMenuParams;
        /** @internal */
        /** @internal */
        protected isPinned: boolean;
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected createImpl(): MainMenuImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface MainMenuState extends MainMenuParams, PanelState {
    }
    /** @internal */
    class MainMenuImpl extends PanelImpl<MainMenuParams, MainMenuState> {
        constructor(props: MainMenuParams, state: MainMenuState);
        componentDidMount(): void;
        private onSidebarToggle;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link MasterGroupMainMenuItem}.
     */
    class MasterGroupMainMenuItemParams extends BaseMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Раскрыт ли элемент меню */
        isExpanded?: boolean;
        /** Включен ли режим отображения для мобильных устройств */
        enableMobileMode?: boolean;
        /** Показывать ли сам элемент меню или только его содержимое */
        showRoot?: boolean;
    }
    /**
     * Контрол для отображения группы элементов в главной панели
     */
    class MasterGroupMainMenuItem extends BaseMainMenuItem<MasterGroupMainMenuItemParams, MasterGroupMainMenuItemState> implements IProxyControl {
        constructor(props: any);
        /** @internal */
        protected createParams(): MasterGroupMainMenuItemParams;
        /** @internal */
        init(): void;
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected level: number | string;
        /**
         * Является ли элемент меню проксирующим, то есть видны только подэлементы, а сам данный элемент меню не виден
         */
        readonly isProxyControl: boolean;
        /**
         * Отрисовка содержимого проксирующего элемента меню
         */
        renderProxyChildren(): React.ReactNode[];
        /** @internal */
        protected onChildToggled(child: LayoutControl): void;
        /** @internal */
        protected showRoot: string | boolean;
        /** @internal */
        protected createImpl(): MasterGroupMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface MasterGroupMainMenuItemState extends MasterGroupMainMenuItemParams, BaseMainMenuItemState {
    }
    /** @internal */
    type MasterGroupMainMenuItemImplState = MasterGroupMainMenuItemState;
    /** @internal */
    class MasterGroupMainMenuItemImpl extends BaseMainMenuItemImpl<MasterGroupMainMenuItemParams, MasterGroupMainMenuItemState> {
        constructor(props: MasterGroupMainMenuItemParams, state: MasterGroupMainMenuItemState);
        protected onClick(event: React.MouseEvent<any>): void;
        protected getCssClass(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link RightMainMenuItemPanel}.
     */
    class RightMainMenuItemPanelParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Расположение */
        location?: RightMainMenuItemPanelLocation;
    }
    /**
     * Контрол для отображения кнопок поверх пунктов главного меню в правой части.
     */
    class RightMainMenuItemPanel extends Panel<RightMainMenuItemPanelParams, RightMainMenuItemPanelState> {
        /** @internal */
        protected createParams(): RightMainMenuItemPanelParams;
        /** @internal */
        protected createImpl(): RightMainMenuItemPanelImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface RightMainMenuItemPanelState extends RightMainMenuItemPanelParams, PanelState {
    }
    /** @internal */
    type RightMainMenuItemPanelImplState = RightMainMenuItemPanelState;
    /** @internal */
    class RightMainMenuItemPanelImpl extends PanelImpl<RightMainMenuItemPanelParams, RightMainMenuItemPanelState> {
        constructor(props: RightMainMenuItemPanelParams, state: RightMainMenuItemPanelState);
        getLocation(location: string): MainMenuHelpers.OverlapPanelLocation;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Значения для свойства {@link RightMainMenuItemPanelParams.location}. */
    type RightMainMenuItemPanelLocation = "above" | "below";
    /** Значения для свойства {@link RightMainMenuItemPanelParams.location}. */
    class RightMainMenuItemPanelLocations {
        static Above: string;
        static Below: string;
    }
}
declare namespace WebClient {
    /**
    * Содержит публичные свойства элемента управления {@link SearchResultsMainMenuItem}.
    */
    class SearchResultsMainMenuItemParams extends LinkMainMenuItemParams {
        /** Адрес страницы поиска */
        href: string;
        /** Классы для иконок */
        iconClass: string;
    }
    /** @internal */
    type SearchResultsMainMenuItemState = LinkMainMenuItemState;
    /**
     * Контрол для отображения ссылки на результаты поиска в списке элементов главной панели.
     */
    class SearchResultsMainMenuItem extends LinkMainMenuItem {
        constructor(props: any);
        /** @internal */
        protected createParams(): SearchResultsMainMenuItemParams;
        /** @internal */
        protected createImpl(): LinkMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link StandardMainMenuContainer}.
     */
    class StandardMainMenuContainerParams extends BaseMainMenuItemParams {
    }
    /**
     * Контейнер для элементов меню
     */
    class StandardMainMenuContainer extends BaseMainMenuItem<StandardMainMenuContainerParams, StandardMainMenuContainerState> {
        protected createParams(): StandardMainMenuContainerParams;
        /** @internal */
        protected createImpl(): StandardMainMenuContainerImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface StandardMainMenuContainerState extends StandardMainMenuContainerParams, BaseMainMenuItemState {
    }
    /** @internal */
    type StandardMainMenuContainerImplState = StandardMainMenuContainerState;
    /** @internal */
    class StandardMainMenuContainerImpl extends BaseMainMenuItemImpl<StandardMainMenuContainerParams, StandardMainMenuContainerState> {
        constructor(props: any, state: StandardMainMenuContainerState);
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [ConnectUserFoldersButtonScript]{@link ConnectUserFoldersButtonScript}.
     */
    class ConnectUserFoldersButtonScriptParams extends LayoutScriptParams {
        /** Название контрола с пользовательскими папками */
        userFoldersName: string;
        /** Название контрола кнопки настройки главного меню */
        configurationButtonName: string;
        services?: $ControlStore;
    }
    /** @internal */
    interface ConnectUserFoldersButtonScriptState extends ConnectUserFoldersButtonScriptParams, LayoutScriptState {
    }
    /**
     * Класс для связывания кнопки настройки главного меню с пользовательскими папками
     */
    class ConnectUserFoldersButtonScript extends LayoutScript<ConnectUserFoldersButtonScriptParams, ConnectUserFoldersButtonScriptState> {
        private userFolders;
        private button;
        protected createParams(): ConnectUserFoldersButtonScriptParams;
        /** @internal */
        init(): void;
        /** @internal */
        protected onFoldersAttached: (folders: string[]) => void;
        /** @internal */
        protected onAttachFolderClick: () => void;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link ConnectUserFoldersToConfigurableContainerScript}.
     */
    class ConnectUserFoldersToConfigurableContainerScriptParams extends LayoutScriptParams {
        /** Название контрола с пользовательскими папками */
        userFoldersName: string;
        /** Название контрола контейнера с настраиваемыми элементами меню */
        configurableContainerName: string;
        services?: $ControlStore;
    }
    /** @internal */
    interface ConnectUserFoldersToConfigurableContainerScriptState extends ConnectUserFoldersToConfigurableContainerScriptParams, LayoutScriptState {
    }
    /**
     * Класс для связывания настраиваемого контейнера главного меню с пользовательскими папками
     */
    class ConnectUserFoldersToConfigurableContainerScript extends LayoutScript<ConnectUserFoldersToConfigurableContainerScriptParams, ConnectUserFoldersToConfigurableContainerScriptState> {
        private userFolders;
        private container;
        /** @internal */
        protected createParams(): ConnectUserFoldersToConfigurableContainerScriptParams;
        /** @internal */
        init(): void;
        /** @internal */
        protected onConfigurationSaving: (sender: any, args: CancelableEventArgs<GenModels.MainMenuSettings>) => void;
    }
}
declare namespace WebClient {
    /** Свойства для {@link UserFolderItemWrapper} */
    interface IUserFolderItemWrapperProps {
        /** Содержимое UserFolderItemWrapper */
        children?: React.ReactNode;
        /** При нажатии на кнопку закрытия элемента меню */
        onRemoveClick?: (ev: React.MouseEvent<any>) => void;
    }
    /** @internal */
    const UserFolderItemWrapper: (props: IUserFolderItemWrapperProps) => JSX.Element;
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [UserFoldersMainMenuItem]{@UserFolders UserFoldersMainMenuItem}.
     */
    class UserFoldersMainMenuItemParams extends BaseMainMenuItemParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Показывать ли сам элемент меню или только его содержимое */
        showRoot?: boolean;
        /** Количество подуровней элемента, которые будут автоматически предзагружены */
        foldersPreloadLevel?: number;
        /** Компактное представление для папок */
        compactFolders?: boolean;
        /** Показывать ли иконки */
        showIcons?: boolean;
        /** Список папок */
        folders?: string[];
        /** Раскрыт ли элемент меню */
        isExpanded?: boolean;
        services?: $LayoutController & $LayoutFolderController & $Layout;
    }
    /**
     * Контрол для отображения папок в списке элементов главной панели.
     */
    class UserFoldersMainMenuItem extends BaseMainMenuItem<UserFoldersMainMenuItemParams, UserFoldersMainMenuItemState> implements IProxyControl {
        constructor(props: any);
        /** @internal */
        protected createParams(): UserFoldersMainMenuItemParams;
        /** @internal */
        protected showRoot: string | boolean;
        /** @internal */
        protected expanded: string | boolean;
        /**
         * Является ли элемент меню проксирующим, то есть видны только подэлементы, а сам данный элемент меню не виден
         */
        readonly isProxyControl: boolean;
        /**
         * Отрисовка содержимого проксирующего элемента меню
         */
        renderProxyChildren(): React.ReactNode[];
        /** @internal */
        protected registerChild(child: BaseControl<BaseControlParams, BaseControlState>): void;
        /** @internal */
        protected level: number | string;
        /**
         * Обновление списка пользовательских папок с сервера.
         */
        reload(): JQueryDeferred<{}>;
        /**
         * Отсоединить папки
         * @param folderIds Список идентификаторов отсоединяемых папок
         */
        detachFolders(folderIds: string[]): Promise<void>;
        /** @internal */
        protected createImpl(): UserFoldersMainMenuItemImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface UserFoldersMainMenuItemState extends UserFoldersMainMenuItemParams, BaseMainMenuItemState {
        /**
         * Отсоединить папки
         * @param folderIds Список идентификаторов отсоединяемых папок
         */
        detachFolders: (folderIds: string[]) => JQueryDeferred<{}>;
        detachHelper: RequestHelper;
    }
    /** @internal */
    type UserFoldersMainMenuItemImplState = UserFoldersMainMenuItemState;
    /** @internal */
    class UserFoldersMainMenuItemImpl extends BaseMainMenuItemImpl<UserFoldersMainMenuItemParams, UserFoldersMainMenuItemState> {
        constructor(props: UserFoldersMainMenuItemParams, state: UserFoldersMainMenuItemState);
        protected onClick(event: React.MouseEvent<any>): void;
        onDetachClick(index: number): void;
        protected getChildrenAutoExpandLevelsCount: () => number;
        protected canAutoExpand: () => boolean;
        renderProxyChildren(): React.ReactNode[];
        protected getCssClass(): string;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    namespace PartnerHelpers {
        /** Иконка поиска используемая в {@link Partner}. */
        const SearchIcon: ({}: {}) => JSX.Element;
    }
}
declare function DisableFormEnter(formName: string): any;
declare namespace WebClient {
    /** @internal */
    class GroupTaskCardPerformersPanelParams extends BaseRazorControlParams {
    }
    /** @internal */
    interface GroupTaskCardPerformersPanelState extends BaseRazorControlState {
        performersLogic: TaskGroupCardCreatePerformers;
    }
    /** @internal */
    class GroupTaskCardPerformersPanelRazorControl extends BaseRazorControl<GroupTaskCardPerformersPanelParams, GroupTaskCardPerformersPanelState> {
        protected createParams(): GroupTaskCardPerformersPanelParams;
        setTaskGroupInterval(startDate: Date, endDate: Date, duration: number): void;
        mountRazorContent(razorContainer: HTMLElement): void;
        protected getBindings(): IBindingResult<any>[];
    }
}
declare namespace WebClient {
    /** @internal */
    class GroupTaskPerformersUpdateModel {
        TaskGroupId: string;
        PerformerId: string;
        ExecutionType: string;
        PerformerSettingUpdateModels: Array<PerformerSettingUpdateModel>;
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskGroupCardCreatePerformers {
        private form;
        private intervalManager;
        private localResourses;
        private performersTable;
        private dateTimeFormat;
        private responsePerformer;
        private employeeAutocomplete;
        private changePerformerControls;
        private allowResponsiveAcceptance;
        private allowAcceptance;
        private controlHour;
        executionTypeChanged: IBasicEvent<GenModels.ExecutionType>;
        constructor(formName: HTMLFormElement);
        protected Initialize(): void;
        getExecutinType(): GenModels.ExecutionType;
        taskGroupStartDate: Date;
        taskGroupEndDate: Date;
        taskGroupDuration: number;
        executionType: GenModels.ExecutionType;
        setTaskGroupInterval(startDate: Date, endDate: Date, duration: number): void;
        validate(): boolean;
        getData(): GroupTaskPerformersUpdateModel;
        /** Called when start date, end date or duration changed in dates range control  */
        protected onIntervalChanged(): void;
        private UpdateIntervalManager(tasksIntervalsManager);
        private UpdateIntervalsView(tasksIntervalsManager);
        private disableSelection($el);
        private fixHelper(e, ui);
        private CompareTaskIntervals(a, b);
        private GetExistingPerformers(except?);
        private ChangeExecutionTypeEventHandler();
        private EditTaskIntervalEventHandler();
        private UpdateTaskInterval(changeDateInfo, currentTaskInterval, startDateControl, endDateControl, durationControl, rootElement);
        private EditTaskDescriptionEventHandler();
        private RemovePerformerEventHandler();
        private MoveUpPerformerEventHandler();
        private MoveDownPerformerEventHandler();
        private ChangePerformerEventHandler();
        private ChangePerformerResponseEventHandler();
    }
}
declare namespace WebClient {
    /** Интрейс, через который поисковая форма взаимодействует с контролами поисковых параметров. Реализуется {@link QueryCondition} */
    interface IQueryConditionControl {
        /** Должен возвращать true. */
        readonly isQueryCondition: boolean;
        /** Веденое пользователем значение параметра. */
        queryParameterValue: string;
        /** Имя параметра, которое будет передано в поисковый запрос. */
        readonly queryParameterAlias: string;
        /** Содержит false если ползователь исключил условие из поиска. */
        queryParameterEnabled: boolean;
        readonly fieldType: GenModels.FieldType;
        readonly fieldSubType: GenModels.FieldSubtype;
        /** Полное значение контрола, содержащее отображаемое имя и дополнительные сведения. */
        contorlValue: any;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [QueryCondition]{@link QueryCondition}.
     */
    class QueryConditionParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Значение по-умолчанию настроенное для прамаметра. */
        parameterDefaultValue?: any;
        /** Текст, определяющий тип условия (содержит, больше, меньше, равно...). Используется для отображения пользователю. */
        conditionText?: string;
        /** Используется контрол внутри {@link QueryConditionsTable} или нет. В табличном режиме используются теги `<tr>` и `<td>`. */
        tableMode?: boolean;
        /** Включен ли параметр в поиск или нет. */
        parameterEnabled?: boolean;
        parameterName: string;
        parameterAlias: string;
        parameterValue: string;
        queryId?: string;
        fieldType?: GenModels.FieldType;
        fieldSubType?: GenModels.FieldSubtype;
        services?: $DeviceType;
    }
    /**
     * Класс элемента управления для отображения параметров поискового запроса и взаимодействия с контролом ввода значения поискового запроса.
     */
    class QueryCondition extends Panel<QueryConditionParams, QueryConditionState> implements IQueryConditionControl {
        /** Служит для отличения контрола от других элементов управления. */
        readonly isQueryCondition: boolean;
        /** @internal */
        init(): void;
        /** @internal */
        componentDidUpdate(): void;
        /** @internal */
        protected updateControlPlaceholder(): void;
        /** Введеное пользователем значение параметра. */
        /** Устанавливает значение поискового параметра. */
        queryParameterValue: any;
        /** Имя параметра, которое будет передано в поисковый запрос. */
        readonly queryParameterAlias: string;
        /** Содержит false если пользователь исключил условие из поиска. */
        queryParameterEnabled: boolean;
        /** Тип данных поискового параметра. */
        readonly fieldType: GenModels.FieldType;
        readonly fieldSubType: GenModels.FieldSubtype;
        /** Возвращает значение дочернего контрола, служащего для ввода значения фильтра. */
        contorlValue: any;
        /** Возвращает дочерний контрол, служащий для ввода значения фильтра. */
        protected getValueControl(): InputBasedControl<any, InputBasedControlParams<any>, InputBasedControlState<any>>;
        /** @internal */
        protected createParams(): QueryConditionParams;
        /** @internal */
        protected createImpl(): QueryConditionImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface QueryConditionState extends QueryConditionParams, PanelState {
    }
    /** @internal */
    class QueryConditionImpl extends PanelImpl<QueryConditionParams, QueryConditionState> {
        constructor(props: QueryConditionParams, state: QueryConditionState);
        getCssClass(): string;
        renderLabel(): JSX.Element;
        renderSwitch(): JSX.Element;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [QueryConditionsTable]{@link QueryConditionsTable}.
     */
    class QueryConditionsTableParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
    }
    /**
     * Класс элемента управления для отображения параметров поискового запроса в виде плоского списка.
     */
    class QueryConditionsTable extends Panel<QueryConditionsTableParams, QueryConditionsTableState> {
        /** @internal */
        protected createParams(): QueryConditionsTableParams;
        /** @internal */
        protected createImpl(): QueryConditionsTableImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface QueryConditionsTableState extends QueryConditionsTableParams, PanelState {
    }
    /** @internal */
    class QueryConditionsTableImpl extends PanelImpl<QueryConditionsTableParams, QueryConditionsTableState> {
        constructor(props: QueryConditionsTableParams, state: QueryConditionsTableState);
        /** @internal */
        renderControl(): React.ReactNode[];
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Страница вкладок]{@link StateButtons}.
     */
    class TabPageParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Всплывающая подсказка. */
        tip?: string;
    }
    /**
     * Класс элемента управления Страница вкладок
     *
     * Добавляет в web-разметку элемент управления для отображения страницы вкладок и её содержимого.
     */
    class TabPage extends Panel<TabPageParams, TabPageState> {
        protected createParams(): TabPageParams;
        /** @internal */
        protected createImpl(): TabPageImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TabPageState extends TabPageParams, PanelState {
    }
    /** @internal */
    type TabPageImplState = TabPageState;
    /** @internal */
    class TabPageImpl extends PanelImpl<TabPageParams, TabPageState> {
        constructor(props: TabPageParams, state: TabPageState);
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления [Столбец таблицы]{@link TableColumn}.
     */
    class TableColumnParams extends PanelParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
    }
    /**
     * Класс элемента управления Столбец таблицы
     *
     * Добавляет в web-разметку элемент управления для отображения столбца таблицы.
     */
    class TableColumn extends Panel<TableColumnParams, TableColumnState> {
        createParams(): TableColumnParams;
        /** @internal */
        createImpl(): TableColumnImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TableColumnState extends TableColumnParams, PanelState {
        /** Таблица. */
        table: TableImpl;
        /** Номер столбца таблицы. */
        columnNumber: number;
        /** Ширина столбца таблицы (любые единицы измерения). */
        columnWidth: string;
    }
    /** @deprecated */
    type TableColumnImplState = TableColumnState;
    /** @internal */
    class TableColumnImpl extends PanelImpl<TableColumnParams, TableColumnState> {
        constructor(props: TableColumnParams, state: TableColumnState);
        protected prepareChildren(): void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link TaskDelegationInfo}.
     */
    class TaskDelegationInfoParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления. */
        standardCssClass?: string;
        /** Данные контрола */
        delegationInfo: GenModels.TaskDelegationInfoModel;
    }
    /** @internal */
    interface TaskDelegationInfoState extends TaskDelegationInfoParams, BaseControlState {
        employeeVisualizer: EmployeeVisualizer;
    }
    /**
     * Класс элемента управления, отображающего информацию о делегировании задания.
     */
    class TaskDelegationInfo extends BaseControl<TaskDelegationInfoParams, TaskDelegationInfoState> {
        constructor(props: any);
        /** @internal */
        protected createParams(): TaskDelegationInfoParams;
        private binding;
        /** @internal */
        protected createImpl(): ControlImpl;
        /** @internal */
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    class CommandMenuComponent extends React.Component<ICommandMenuProps, ICommandMenuState> {
        constructor(props: any);
        componentWillUnmount(): void;
        protected handleComponentClick(event?: Event): void;
        protected handleCommandMenuClick(event?: React.MouseEvent<any>): void;
        protected toggleMenu(): void;
        protected onMenuItemClick(item: GenModels.CreateKindDataModel, ev: React.MouseEvent<any>): void;
        protected getCommandMenuItems(filter: (ICommandMenuItem) => boolean): JSX.Element[];
        protected getKindItems(): JSX.Element[];
        protected getTemplates(): JSX.Element[];
        protected attachCommandBarButton(elem: any): void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICommandMenuProps {
        createKinds: GenModels.CreateKindDataModel[];
        isVisible: boolean;
        createTask: (item: GenModels.CreateKindDataModel) => void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICommandMenuState {
        expanded: boolean;
        commandMenuItems: GenModels.CreateKindDataModel[];
        commandBarBtn: any;
        popoverOpen: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITaskListProps {
        digestView: boolean;
        tabStop: boolean;
        items: GenModels.TaskDataModel[];
        itemsLoading?: boolean;
        itemsCount: number;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITaskListState {
        taskListItems: GenModels.TaskDataModel[];
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskListComponent extends React.Component<ITaskListProps, ITaskListState> {
        protected refItems: HTMLElement;
        constructor(props: any);
        componentWillReceiveProps(newProps: any): void;
        protected getTaskListItems(): JSX.Element[];
        render(): any[] | JSX.Element;
        protected getClassName(): string;
        protected getLoaderWidth(i: number): number;
        protected renderEmptyItemList(): any[] | JSX.Element;
        protected renderItemList(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITaskListItemProps {
        taskListItem: GenModels.TaskDataModel;
        digestView: boolean;
        tabStop: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITaskListItemState {
        endDate: Date;
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskListItemComponent extends React.Component<ITaskListItemProps, ITaskListItemState> {
        constructor(props: any);
        protected getClassName(): string;
        protected groupTaskIconClassName(): string;
        protected getTaskStateIconClassName(): string;
        protected getUrl(): string;
        protected getEndDate(): string;
        protected getEndDateClassName(): string;
        protected inState(taskState: GenModels.TaskStateType[], taskGroupState: GenModels.TaskGroupStateType[]): boolean;
        protected getTabIndex(): 0 | -1;
        render(): JSX.Element;
        protected renderFullView(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ICollapsedTextProps {
        className?: string;
        text: string;
        maxLength: number;
    }
    /** @internal */
    interface ICollapsedTextState {
        expanded: boolean;
    }
    /** @internal */
    class CollapsedText extends React.Component<ICollapsedTextProps, ICollapsedTextState> {
        constructor(props: ICollapsedTextProps);
        componentWillUnmount(): void;
        componentWillReceiveProps(nextProps: ICollapsedTextProps, nextContext: any): void;
        onClick(): void;
        private isShowFullText();
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IColorTextProps {
        className?: string;
        children?: React.ReactNode;
        color?: string;
        background?: string;
        onClick?: () => void;
    }
    /** @internal */
    const ColorText: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IColorTextProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IColorTextProps>;
}
declare namespace WebClient {
    /** @internal */
    interface IEmployeeInfoProps {
        className?: string;
        employeeName: string;
        position?: string;
        employeeId: string;
    }
    /** @internal */
    interface IImageContainerStyleProps {
        imageUrl: string;
    }
    const EmployeeInfo: (props: IEmployeeInfoProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IGroupEmployeeInfoProps {
        className?: string;
        responsibleEmployees: GenModels.TaskGroupSelectedPerformer[];
        otherEmployees: GenModels.TaskGroupSelectedPerformer[];
        executionType: GenModels.ExecutionType;
    }
    /** @internal */
    const GroupEmployeeInfo: (props: IGroupEmployeeInfoProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IImageWithDescriptionProps {
        className?: string;
        image: string;
        color?: string;
        children?: React.ReactNode;
        onClick?: () => void;
    }
    /** @internal */
    const ImageWithDescription: (props: IImageWithDescriptionProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    const LineSpacer: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    /** @internal */
    const PreloadHelpBoxContent: string;
}
declare namespace WebClient {
    /** @internal */
    interface IValueWithDescriptionProps {
        className?: string;
        description: string;
        value: string;
        color?: string;
        background?: string;
    }
    /** @internal */
    const ValueWithDescription: (props: IValueWithDescriptionProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    const DOCUMENT_CARD_TYPE_ID: string;
    /** @internal */
    const TASK_CARD_TYPE_ID: string;
    /** @internal */
    const GROUP_TASK_CARD_TYPE_ID: string;
    /** @internal */
    const GROUP_TYPE_BOX: string;
    /** @internal */
    const GROUP_TYPE_GREY: string;
    /** @internal */
    const GROUP_TYPE_RED: string;
    /** @internal */
    const GROUP_TYPE_ORANGE: string;
    /** @internal */
    const GROUP_TYPE_GREEN: string;
    /** @internal */
    const GROUP_TYPE_BLUE: string;
    /** @internal */
    const GROUP_TYPE_LIGHT_BLUE: string;
    /** @internal */
    const GROUP_TYPE_ICON: string;
    /** @internal */
    const COLOR_OVERDUE_BORDER: string;
    /** @internal */
    const TASKSTREE_TASK_LABEL_MAX_PERFORMERS: number;
    /** @internal */
    const TASKSTREE_TASK_LABEL_MAX_LENGTH: number;
    /** @internal */
    const TASKSTREE_TASK_LABEL_MAX_ROWS: number;
    /** @internal */
    const TASKSTREE_SELECTED_NODE_BORDER_COLOR: string;
}
declare namespace WebClient {
    /** @internal Свойства для {@link InnerWindow}  */
    interface IInnerWindowProps {
        className?: string;
        children?: React.ReactNode;
        width?: number;
        top?: number;
        left?: number;
        visible?: boolean;
    }
    /** @internal Вспомогательный компонент для {@link TasksTreeContainer} */
    const InnerWindow: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IInnerWindowProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & IInnerWindowProps>;
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeContainerProps extends ITasksTreeImplState {
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeContainerState {
        network: vis.Network;
        shouldContainerUpdate: boolean;
        propertyProcessors: any;
        nodes: ITasksTreeNodeContainer[];
        edges: ITasksTreeEdgeContainer[];
        helpBoxDelegationExpanded: boolean;
        helpBoxDelegationClick: (e: React.MouseEvent<any>) => void;
        helpBoxRender: any;
        selectedNode: ITasksTreeNodeContainer;
        helpModel: GenModels.TreeNodeHelpModel;
        data: vis.Data;
        roots: vis.IdType[];
    }
}
declare namespace WebClient {
    /** @internal */
    class TasksTreeContainer extends React.Component<ITasksTreeContainerProps, ITasksTreeContainerState> {
        state: ITasksTreeContainerState;
        private container;
        constructor(props: any);
        componentDidMount(): void;
        componentWillUnmount(): void;
        componentWillReceiveProps(nextProps: ITasksTreeContainerProps): void;
        updateProps(nextProps: ITasksTreeContainerProps, initialize: boolean): void;
        updateContainer(): void;
        redrawNetwork(): void;
        beforeDrawing(): void;
        afterDrawing(): void;
        onClick(params: IVisClickParams): void;
        onHold(params: IVisClickParams): void;
        onSelectNode(params: IVisClickParams): Promise<void>;
        changeNodeCollapse(nodeId: vis.IdType): void;
        selectNode(selectedNodeId: vis.IdType): void;
        onDeselectNode(): void;
        setFit(): void;
        setFocus(nodeId: vis.IdType): void;
        updateNodeCollapse(nodeId: vis.IdType, hidden: boolean, forceExpand: boolean, expandChilds: boolean): void;
        updateNodeVisibility(nodeId: vis.IdType, hidden: boolean, forceExpand: boolean, expandChilds: boolean): void;
        tasksTreeModelUpdate(prop: GenModels.TasksTreeModel, nextProps: ITasksTreeContainerProps): void;
        collapseAll(): void;
        expandAll(): void;
        private showHelpBox(selectedNode);
        private getRoots(nodes, edges);
        private updateNodes();
        private hideCollapsedBySettingNodes();
        private collapseBySetting(nodeId, nodes, edges);
        private collapseNodeBySetting(nodeId, nodes, edges);
        private getLinkedNode(nodeId, hiddenNodes);
        private refresh();
        private getOptions();
        private getColor(colorAlias);
        private getData();
        private getTasksTreeNodeHelpModel(cardId, cardTypeId);
        private helpBoxDelegationClick(e);
        private getHeight(helpBox);
        private hideNode(nodeId);
        private showNode(nodeId, includeChilds);
        private findNode(array, nodeId);
        render(): JSX.Element;
        renderHelpBox(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    const TasksTreeContainerStyle: styled.StyledComponentClass<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    /** @internal */
    function getIndicator(parentId: vis.IdType, indicatorType: IndicatorType, image: string, hidden?: boolean, size?: number): ITasksTreeNodeContainer;
    /** @internal */
    function openTask(id: string): void;
    /** @internal */
    function openLink(linkItemData: GenModels.LayoutLinkModel): void;
}
declare namespace WebClient {
    /** Элемент дополнительной метаинформации, переданной резолвером контрола. */
    interface IBindingMetadata {
        key: string;
        value: string;
    }
}
declare namespace WebClient {
    /** Модель данных, загруженных с сервера при помощи механизма биндингов. */
    interface IBindingResult<T> {
        /** Идентификатор биндинга (служебная информация). */
        name: string;
        /** Используется в некоторых контролах наряду {@link value}. */
        values: string[];
        /** Значение биндинга. */
        value: T;
        /** Идентификатор операции редактирования, ассоциированной с биндингом. */
        editOperation: string;
        /** Дополнительная метаинформация, переданная резолвером контрола. */
        metadata: IBindingMetadata[];
    }
}
declare namespace WebClient {
    /** Модель, используемая при отправке значений контролов на сервер. */
    interface IBindingsWriteRequest {
        /** Имя контрола. */
        controlName: string;
        /** Имя контрола, который инициировал сохранение. Это может быть имя контрола, отображаемого в окне редактирования по месту. */
        actualControlName: string;
        /** Тип контрола. */
        controlTypeName: string;
        /** Данные контрола. */
        bindingResults: IBindingResult<any>[];
    }
}
declare namespace WebClient {
    namespace Breadcrumbs {
        /**
         * См. {@link Breadcrumbs.ButtonItem}
         */
        const LinkItemView: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
            className: string;
        }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    }
}
declare namespace WebClient {
    namespace Breadcrumbs {
        /** @review Свойства для {@link LinkItemViewWithSeparator}  */
        interface ILinkItemViewWithSeparatorProps {
            /** Дополнительный класс */
            className?: string;
            /** Является ли элемент первым в списке */
            first: boolean;
            /** Текст элемента */
            title?: string;
            /** @internal */
            children?: React.ReactNode;
        }
        /** @review Отображает {@link LinkItemView} c {@link LinkSeparator} перед ним, если элемент первый в списке. */
        const LinkItemViewWithSeparator: (props: ILinkItemViewWithSeparatorProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace Breadcrumbs {
        /** @review См. {@link Breadcrumbs.ButtonItem} */
        const LinkSeparator: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
            className: string;
        }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    }
}
declare namespace WebClient {
    namespace Breadcrumbs {
        /** @review Аналог {@link LinkItemView}, но без стилизации в виде ссылки. */
        const SimpleItemView: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
            className: string;
        }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    }
}
declare namespace WebClient {
    namespace Breadcrumbs {
        /** @review Свойства для {@link SimpleItemViewWithSeparator}  */
        interface ISimpleItemViewWithSeparatorProps {
            /** Дополнительный класс */
            className?: string;
            /** Является ли элемент первым в списке */
            first: boolean;
            /** Текст элемента */
            title?: string;
            /** @internal */
            children?: React.ReactNode;
        }
        /** @review Аналог {@link LinkItemViewWithSeparator}, но без стилизации в виде ссылки. */
        const SimpleItemViewWithSeparator: (props: ISimpleItemViewWithSeparatorProps) => JSX.Element;
    }
}
declare namespace WebClient {
    namespace Breadcrumbs {
        /** @review Аналог {@link LinkSeparator}, но без стилизации в виде ссылки. */
        const SimpleSeparator: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
            className: string;
        }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
    }
}
declare namespace WebClient {
    /** @internal */
    const AdapativeComboBoxBodyContent: styled.StyledComponentClass<IInlineDropdownPopoverProps, any, styled.WithOptionalTheme<IInlineDropdownPopoverProps, any>>;
}
declare namespace WebClient {
    /** @internal */
    interface IComboBoxBodyContentProps {
        /** Дополнительный класс */
        className?: string;
        /** Содержимое */
        children?: React.ReactNode;
    }
    /** @internal */
    class ComboBoxBodyContent extends React.Component<IComboBoxBodyContentProps, undefined> {
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IComboBoxElementContentProps {
        /** Дополнительный класс */
        className?: string;
        /** Содержимое */
        children?: React.ReactNode;
    }
    /** @internal */
    class ComboBoxElementContent extends React.Component<IComboBoxElementContentProps, undefined> {
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IComboBoxTitleContentProps {
        /** Дополнительный класс */
        className?: string;
        /** Содержимое */
        children?: React.ReactNode;
    }
    /** @internal */
    class ComboBoxTitleContent extends React.Component<IComboBoxTitleContentProps, undefined> {
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IComboBoxWrapperContentProps {
        /** Дополнительный класс */
        className?: string;
        /** Заголовок комбобокса */
        title?: React.ReactNode;
        /** Тело комбобокса */
        body?: React.ReactNode;
    }
    /** @internal */
    class ComboBoxWrapperContent extends React.Component<IComboBoxWrapperContentProps, undefined> {
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @internal */
    const PopoverComboBoxBodyContent: styled.StyledComponentClass<IPopoverProps, any, styled.WithOptionalTheme<IPopoverProps, any>>;
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNodeButton }  */
    interface ICustomTreeNodeButtonProps {
        /** Выделен ли узел */
        selected?: boolean;
        className?: string;
        /** Доступен ли выбор узла. По умолчанию - true. */
        selectable?: boolean;
    }
    /** Содержимое узла дерева, упрощенный аналог {@link CustomTreeNodeContentDefault} с нативным outline при фокусе.
     * Пример использования см. {@link CustomTreeDefault}
     */
    const CustomTreeNodeButton: styled.StyledComponentClass<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeButtonProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & ICustomTreeNodeButtonProps>;
}
declare namespace WebClient {
    /** @review Содержимое сворачиваемой области. См. также {@link DisclosureHead}. */
    class DisclosureBody extends React.Component<IDisclosureBodyProps, IDisclosureBodyState> {
        protected refItems: HTMLElement;
        constructor(props: IDisclosureBodyProps);
        componentWillReceiveProps(nextProps: IDisclosureBodyProps, nextContext: any): void;
        toggleCollapsed(duration?: number, easing?: string, animate?: boolean): void;
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** @review Свойства для {@link DisclosureBody}  */
    interface IDisclosureBodyProps {
        /** Раскрыта ли сворачиваемая область. Значение по умолчанию: true */
        expanded: boolean;
        /**
         * Следует ли использовать анимацию при разворачивании и сворачивании (см. JQuery функции slideUp и slideDown)
         * Значение по умолчанию: true
         */
        animate?: boolean;
        /**
         * См. JQuery slideUp и slideDown функции
         * Значение по умолчанию: 250
         */
        duration?: number;
        /**
         * См. JQuery slideUp и slideDown функции
         * Значение по умолчанию: linear
         */
        easing?: string;
        /** @internal */
        children?: any;
        /** Дополнительные классы */
        className?: string;
        /** Дополнительные стили */
        style?: React.CSSProperties;
        /** Видимость. Значение по умолчанию: true */
        visible?: boolean;
        /** Событие, возникающее перед сворачиванием */
        onCollapsing?: () => JQueryDeferred<any>;
        /** Событие, возникающее после сворачивания */
        onCollapsed?: Function;
        /** Событие, возникающее перед разворачиванием */
        onExpanding?: () => JQueryDeferred<any>;
        /** Событие, возникающее после разворачивания */
        onExpanded?: Function;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IDisclosureBodyState {
        expanded: boolean;
        intialState: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAdaptiveMenuContentProps {
        children?: React.ReactNode;
    }
    /**
      * @internal Представляет собой адаптивное содержимое для меню {@link AdaptiveMenuBar}.
      * См. также {@link AdaptiveMenuItem}
      */
    const AdaptiveMenuContent: (props: IAdaptiveMenuContentProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IDesktopMenuContentProps extends IAdaptiveMenuContentProps {
    }
    /**
      * @internal Представляет собой обёртку для содержимого меню в настольной версии.
      */
    const DesktopMenuContent: (props: IDesktopMenuContentProps) => JSX.Element;
}
declare namespace WebClient {
    /** @internal */
    interface IMobileMenuContentProps extends IAdaptiveMenuContentProps {
    }
    /**
      * @internal Представляет собой обёртку для содержимого меню в мобильной версии.
      */
    const MobileMenuContent: (props: IMobileMenuContentProps) => JSX.Element;
}
declare namespace WebClient {
    /**
     * Использует {@link Popover} для отображения вслывающего окна контролов, в режиме edit-in-place.
     *
     * Для создания всплывающего окна следует исполдьзовать статический метод {@link EditPopover.CreatePopover}
     */
    class EditPopover extends React.Component<IEditPopoverProps, IEditPopoverState> {
        private contentRoot;
        private wrapper;
        constructor(props: IEditPopoverProps);
        /** Событие, возникающее перед показом окна */
        readonly showing: ICancelableEvent<IEventArgs>;
        /** Событие, возникающее после показа окна */
        readonly shown: IBasicEvent<IEventArgs>;
        /** Событие, возникающее перед нажатием кнопки OK */
        readonly accepting: ICancelableEvent<IEventArgs>;
        /** Событие, возникающее после нажатия кнопки ОК */
        readonly accepted: IBasicEvent<IEventArgs>;
        /** Событие, возникающее перед закрытием окна путем нажатия кнопки Отмена, клавиши Esc или щелчка вне вслывающего окна) */
        readonly canceling: ICancelableEvent<IEventArgs>;
        /** Событие, возникающее после нажатия кнопки Отмена, клавиши Esc или щелчка вне вслывающего окна. */
        readonly canceled: IBasicEvent<IEventArgs>;
        /** Событие, возникающее перед показом окна */
        readonly hidding: ICancelableEvent<IEventArgs>;
        /** Событие, возникающее после скрытия окна */
        readonly hidden: IBasicEvent<IEventArgs>;
        /**
         * Создает экземпляр вслывающего окна.
         *
         * После создания следует использовать {@link contentElement} свойство для задания содержимого, и методы {@link show} и {@link hide}
         * для управления всплывающим окном.
         */
        static CreatePopover(popoverOptions: IEditPopoverProps): JQueryDeferred<EditPopover>;
        /**
         * HTMLElement, в который следует поместить содержимое всплывающего окна.
         *
         * Внимание! Значение свойства будет принициализировано только после вызова {@link IEditPopoverProps.onMounted}
         */
        readonly contentElement: HTMLElement;
        /**
         * Отображает всплыающее окно на экране.
         */
        show(): JQueryDeferred<any>;
        /**
         * Скрывает всплыающее окно.
         */
        hide(): void;
        /**
         * Отображается всплыающее окно на экране в данный момент или нет.
         */
        visible: boolean;
        /**
         * Настройка, определяющая, будет ли окно скрываться по клику во вне.
         */
        hideByClickOutside: boolean;
        /**
         * Настройка, определяющая, будет ли окно скрываться по нажатию Esc
         */
        hideByEsc: boolean;
        /**
         * Настройка, определяющая, будет ли иницироваться применение изменений по нажатию клавиши Enter.
         */
        acceptByEnter: boolean;
        /**
         * Корректно очищает содержимое {@link contentElement}
         */
        clearContent(): void;
        /**
         * Скрывает окно и очищает все используемые ресурсы.
         */
        dispose(): void;
        private onKeyEnter(ev);
        private onKeyEsc(ev);
        private attachContentRoot(elem);
        private hideInternal();
        private accept();
        private cancel();
        private onOkClick();
        private onCancelClick();
        private onClickOutside(ev);
        private renderSaveCancelButtons();
        /** @internal */
        render(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Свойства для {@link EditPopover} */
    interface IEditPopoverProps {
        /** Элемент, возле которого будет отображено всплывающее окно */
        target: HTMLElement;
        /** Уникальный идентфикатор окна. */
        key?: string;
        /** Ширина содержимого всплывающего окна */
        width?: string;
        /** Максимальная высота содержимого всплывающего окна */
        maxHeight?: string;
        /** Максимальная ширина содержимого всплывающего окна */
        maxWidth?: string;
        /** Текст заголовка всплывающего окна */
        title?: string;
        /** Настройка, определяющая, будет ли иницироваться применение изменений по нажатию клавиши Enter. */
        acceptByEnter?: boolean;
        /** Настройка, определяющая, будет ли окно скрываться по нажатию Esc */
        hideByEsc?: boolean;
        /** Минимальное расстояние до границ экрана */
        screenPadding?: number;
        /** @internal */
        className?: string;
        /**
         * Настройка, определяющая, будет ли окно скрываться по клику во вне.
         */
        hideByClickOutside?: boolean;
        /**
         * Настройка, определяющая будет ли проигнорирован клик во вне, если этот клик был совершен в пределах другого модального окна.
         * Модальными окнами считаются элементы, созданные при помощи BodyContainerProvider.
         *
         * Значение по умолчанию: true
         */
        ignoreModalOutsideClicks?: boolean;
        /**
         * Место относительно целевого элемента, где будет размещено вспылвающее окно.
         */
        mode?: PopoverMode;
        /** Статичное смещение всплывающего окна от вычисленного положения по оси X в пикселях.  */
        xShift?: number;
        /** Если значение указано, то Popover не будет вычислять собственную ширину, но будет использовать заданную. */
        forceWidth?: number;
        /** Функция, которая будет вызвана после того, как {@link EditPopover.contentElement} примет корректное значение. */
        onMounted: (popover: EditPopover) => void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IEditPopoverState {
        waitingState: LoadingState;
        currentTarget: HTMLElement;
        offScreenX: boolean;
        offScreenY: boolean;
        visible: boolean;
        hideByEscOption: boolean;
        acceptByEnterOption: boolean;
        title: string;
        screenPadding: number;
        mode: PopoverMode;
        /**
         * Должен ли Popover скрываться при клике снаружи него.
         * Значение по умолчанию: false
         */
        hideByClickOutside?: boolean;
        ignoreModalOutsideClicks?: boolean;
        acceptingEvent: CancelableEvent<IEventArgs>;
        acceptedEvent: SimpleEvent<IEventArgs>;
        cancelingEvent: CancelableEvent<IEventArgs>;
        canceledEvent: SimpleEvent<IEventArgs>;
        showingEvent: CancelableEvent<IEventArgs>;
        shownEvent: SimpleEvent<IEventArgs>;
        hiddingEvent: CancelableEvent<IEventArgs>;
        hiddenEvent: SimpleEvent<IEventArgs>;
    }
}
declare namespace WebClient {
    /** @internal Query data, that would be sent by typeahead */
    interface ITypeaheadSearchQuery {
        /** Search text, entered by user in quick search field */
        searchText?: string;
        /** Count of items to skip (paginator logic) */
        skipCount: number;
        /** Max items count in the result */
        maxCount: number;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITypeaheadSearchResult {
        items: ITypeaheadVariant[];
        hasMore: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITypeaheadVariant {
        name: string;
        value: string;
        iconCssClass?: string;
        title?: string;
        favored?: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class TypeaheadItem {
        data: ITypeaheadVariant;
        constructor(data: ITypeaheadVariant);
        getName(): string;
        getTitle(): string;
        getIconCssClass(): string;
        getValue(): string;
        getFavored(): boolean;
        htmlElement: HTMLElement;
    }
}
declare namespace WebClient {
    /** @internal */
    class AutoCompleteItem {
        constructor(label: string, value: string, isFav: boolean, data: GenModels.EmployeeDataModel);
        label: string;
        value: string;
        isFavorite: boolean;
        data: GenModels.EmployeeDataModel;
    }
}
declare namespace WebClient {
    /** @internal */
    class ControlFactory {
        static CreateTextControl(root: HTMLElement, value?: string): any;
        static CreateLabelTextareaControl(root: HTMLElement, labelText?: string, textValue?: string): any;
        static CreateLabelTextControl(root: HTMLElement, labelText?: string, textValue?: string): any;
        static CreateRadioListControl(root: HTMLElement, selectedValue?: string): any;
        static CreateHiddenControl(root: HTMLElement, value?: string): any;
        static CreateDatepickerControl(root: HTMLElement, time: string, minDate?: Date, maxDate?: Date): DatepickerControl;
        static CreateSelectControl(root: HTMLElement, value: string): any;
        static CreateDecisionControl(root: HTMLElement): any;
        static CreateDropdownControl(root: HTMLElement, disabled?: string): DropdownControl;
        static CreateEmployeeSelectControl(root: HTMLElement): EmployeeAutoComplete;
        static CreateDateRangeControl(root: HTMLElement): DateRangeControl;
        static CreateDisclosureControl(root: HTMLElement): DisclosureHeader;
        static GetFromData(root: HTMLElement): any;
    }
}
declare namespace WebClient {
    /** @internal */
    enum ControlType {
        Text = 0,
        Label = 1,
        LabelText = 2,
        Textarea = 3,
        LabeledTextarea = 4,
        Hidden = 5,
        Boolean = 6,
        Select = 7,
        Numeric = 8,
        DateTime = 9,
        LabeledText = 10,
        Radio = 11,
        RadioList = 12,
        EmployeeSelect = 13,
        BaseUniversalSelect = 14,
    }
}
declare namespace WebClient {
    /** @internal */
    class DatepickerControl extends Control {
        private hiddenInput;
        private dateInput;
        private timeInput;
        private dateTimeBox;
        private clearButton;
        private currentTime;
        private dateTimeFormat;
        private minDate;
        private maxDate;
        private lastValidTime;
        constructor(root: HTMLElement, time: string, minDate?: Date, maxDate?: Date);
        Update(time?: Date): void;
        Clear(): void;
        SetMinMaxDate(minDate?: Date, maxDate?: Date): void;
        Disable(): void;
        private Initialize();
        readonly Value: Date;
        private CheckDateTime();
        private GetDateAttribute(element, name);
        private ClearBtnShow();
        private ClearBtnHide();
    }
}
declare namespace WebClient {
    /** @internal */
    class DateRangeControl extends Control {
        private currentZeroDuration;
        private startDateControl;
        private endDateControl;
        private durationControl;
        constructor(root: HTMLElement);
        IntervalManager: TaskIntervalManager;
        OnChangeCallback: Function;
        readonly Duration: number;
        readonly StartDate: Date;
        readonly EndDate: Date;
        UpdateView(intervalManager: TaskIntervalManager): void;
        private Initialize();
        private DateRangeCreateTasksIntervalManager();
    }
}
declare namespace WebClient {
    /** @internal */
    class DisclosureHeader extends Control {
        private id;
        private arrow;
        private content;
        constructor(root: HTMLElement);
        Init(): void;
        private onHeaderClick;
        private onHeaderKeyDown;
        private AddHeaderClickFunction();
        Destroy(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class DropdownControl extends Control {
        private optionList;
        private options;
        private selectedText;
        private selectedElement;
        private selectedValue;
        private isDisabled;
        private DATA_VALUE;
        SelectingItemCallback: (value: string, name: string) => JQueryDeferred<any>;
        SelectItemCallback: (value: string, name: string) => void;
        constructor(root: HTMLElement, disabled: string);
        ShowOptions(selectedOption: string, displayOptions?: Array<GenModels.SearchContextOption>): void;
        Hide(): void;
        Show(): void;
        readonly SelectedValue: string;
        readonly SelectedOption: HTMLElement;
        readonly Element: HTMLElement;
        private Initialize();
        private AddDropdownMissClickEvent();
        private AddDropdownClickEvent();
        private AddOptionListClickEvent();
        private UpdateSelectedOption();
        private SetSelectedText();
    }
}
declare namespace WebClient {
    /** @internal */
    class EmployeeAutoComplete extends Control {
        inputElement: HTMLInputElement;
        hiddenElement: HTMLInputElement;
        hiddenLabel: HTMLElement;
        private selectedItemsContainer;
        selectedItemsList: HTMLElement;
        private allBtn;
        private MoreBtn;
        private DirectoryBtn;
        private ErrorSpan;
        private labelElement;
        private itemCount;
        private favoriteStorage;
        private useStorage;
        private hasMore;
        private kindId;
        private allowMultiple;
        private selectCallback;
        private deleteItemCallback;
        private filter;
        private showAllItemsIfNoResultsOnNextLoad;
        private noResultsOnLastLoad;
        private isSelected;
        private OnSelectValidation;
        private employeeInfo;
        private dropDownMinWidth;
        constructor(root: HTMLElement);
        SelectCallback: (employeeData: IEmployeeItemData) => void;
        SelectingCallback: (employeeData: IEmployeeItemData) => JQueryDeferred<any>;
        FocusoutCallback: Function;
        DeletingItemCallback: (employeeId: string) => JQueryDeferred<any>;
        DeleteItemCallback: (employeeId: string) => void;
        SetFilter(filter: string[]): void;
        readonly AllowMultiple: boolean;
        KindId: string;
        readonly Value: string;
        getEmloyeeInfo(id: string): any;
        private needValidate;
        readonly NeedValidate: boolean;
        private readonly LastMenu;
        private FavoriteEmployees;
        private CloseAutoComplete();
        private onItemsLoaded(event, ui);
        Init(): void;
        private hasAdditionalValidate;
        SetFocus(): void;
        DisableOnKeyUpValidation(): void;
        Validate(throwError?: boolean): boolean;
        ResetValidationError(): void;
        private DeleteItem(deleteBtn);
        private AddToFavorite(item);
        private LoadAll(useStorage, directoryBtn?);
        private GetEmployeesList(term);
        private arrayUnique(array);
        private GetEmployeeFromServer(term, limitCount);
    }
}
declare namespace WebClient {
    /** @internal */
    class HiddenControl extends Control {
        textInput: HTMLInputElement;
        constructor(root: HTMLElement, value?: string);
        Text(value?: string): string;
        Init(onComplete?: () => void): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class LabelControl extends Control implements ILabelControl {
        constructor(root: HTMLElement, value?: string);
        Text(value?: string): string;
        HTML(value?: string): string;
    }
}
declare namespace WebClient {
    /** @internal */
    class LabelTextareaControl extends Control implements ILabelTextareaControl {
        Label: ILabelControl;
        Textarea: ITextareaControl;
        private r;
        constructor(root: HTMLElement, labelText?: string, textValue?: string);
        Init(onComplete?: () => void): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class LabelTextControl extends Control implements ILabelTextControl {
        Label: ILabelControl;
        Text: ITextControl;
        constructor(root: HTMLElement, labelText?: string, textValue?: string);
        Init(onComplete?: () => void): void;
    }
}
declare namespace WebClient {
    /** @internal */
    class LinkedTaskControl extends Control {
        private plusButton;
        private aside;
        private widget;
        private cardId;
        private static LinkedTaskControlPlaceholder;
        constructor(root: HTMLElement, cardId: string);
        private Initialize();
    }
}
declare namespace WebClient {
    /** @internal */
    class RadioListControl extends Control {
        radioControls: NodeListOf<Element>;
        constructor(root: HTMLElement, selectedValue?: string);
        Value(value?: string): string;
        private SetValue(value);
        private GetValue();
    }
}
declare namespace WebClient {
    /** @internal */
    class SelectControl extends Control {
        selectElement: HTMLSelectElement;
        constructor(root: HTMLElement, value?: string);
        Value(value?: string): string;
        Init(onComplete?: () => void): void;
        OnValueChange: Function;
    }
}
declare namespace WebClient {
    /** @internal */
    class TextareaControl extends Control implements ITextareaControl {
        textInput: HTMLInputElement;
        constructor(root: HTMLElement, value?: string);
        Text(value?: string): string;
        Init(onComplete?: () => void): void;
        OnTextChange: Function;
        OnKeyPress: Function;
    }
}
declare namespace WebClient {
    /** @internal */
    class TextControl extends Control implements ITextControl {
        textInput: HTMLInputElement;
        constructor(root: HTMLElement, value?: string);
        Text(value?: string): string;
        Init(onComplete?: () => void): void;
        OnTextChange: Function;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAgreementParams {
        agreementTemplateId: string;
        stages: StageModelWithChange[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface IAgreementStage {
        stageId: string;
        fieldId: string;
        participants: string[];
    }
}
declare namespace WebClient {
    /** @internal */
    interface IControl {
        rootElement: HTMLElement;
        ID(value?: string): string;
        isInit: boolean;
        Init(onComplete?: () => void): void;
        Destroy(): void;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IEmployeeItemData {
        Id: string;
        FullName: string;
        FirstName: string;
        MiddleName: string;
        LastName: string;
        IsMyself: boolean;
        Position: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILabelControl extends IControl {
        Text(value?: string): string;
        HTML(value?: string): string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILabelTextareaControl extends IControl {
        Label: ILabelControl;
        Textarea: ITextareaControl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ILabelTextControl extends IControl {
        Label: ILabelControl;
        Text: ITextControl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITextareaControl extends IControl {
        /** Fired when the text is changed. */
        OnTextChange: Function;
        OnKeyPress: Function;
        Text(value?: string): string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITextControl extends IControl {
        /** Fired when the text is changed. */
        OnTextChange: Function;
        Text(value?: string): string;
    }
}
declare namespace WebClient {
    /** Параметра события сохранения карточки. */
    interface ICardSavingEventArgs {
        saveControlData: SaveControlDataModelEventArgs;
    }
}
declare namespace WebClient {
    /** Аргументы события изменения состояния карточки. */
    interface ICardStateChangingEventArgs {
        operationId: string;
        additionalInfo?: {
            comment?: string;
        };
    }
}
declare namespace WebClient {
    /** Стандартный тип обработчика. */
    type BasicEventHandler<T> = (sender, args?: T) => void;
    /** Базовый интерфейс события. */
    interface IBasicEvent<T> {
        subscribe(handler: BasicEventHandler<T>): any;
        unsubscribe(handler: BasicEventHandler<T>): any;
    }
    /** @deprecated */
    function getEvent<T>(event: BasicApiEvent<T>): BasicApiEvent<T>;
}
declare namespace WebClient {
    /** Интерфейс отменяемого события. */
    type ICancelableEvent<T> = IBasicEvent<ICancelableEventArgs<T>>;
}
declare namespace WebClient {
    /** Интерфейс аргумента отменяемого события. */
    interface ICancelableEventArgs<T> {
        /** Отменить действие. */
        cancel(): void;
        /** Разрешить выполнение действия. Вызывается автоматически если {@link wait} не был вызван. */
        accept(): void;
        /** Задержать выполнение действия до явного вызова {@link accept}. */
        wait(): void;
        /** Данные события. */
        data: T;
        /** Если значение true, то действие будет выполнено после вызова всех обработчиков. */
        autoAcceptEnabled: boolean;
    }
}
declare namespace WebClient {
    /** Базовый интерфейс параметров событий. */
    interface IEventArgs {
    }
}
declare namespace WebClient {
    /** @internal */
    class FolderViewHandler implements IRouteHandler<any> {
        name: string;
        mountRoute(data: any, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: any, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /** @internal */
    class HeaderRouteHandler implements IRouteHandler<any> {
        name: string;
        mountRoute?(data: any, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
    }
}
declare namespace WebClient {
    /** @internal */
    class NavBarRouteHandler implements IRouteHandler<any> {
        name: string;
        mountRoute?(data: any, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
    }
}
declare namespace WebClient {
    /** @internal */
    class SearchPanelRouteHandler implements IRouteHandler<any> {
        name: string;
        prepareRouteDataLoad(routeData: any, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        mountRoute(data: any, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: any, routeType: RouteType): JQueryDeferred<{}>;
    }
    /** @internal Временная функция, перестраивающая панель поиска в обход стандартного механизма роутинга. Функция будет удалена в следующих релизах. */
    function __DangerRemountSearchPanel(): void;
}
declare namespace WebClient {
    /** @internal */
    class UnreadCounterRouteHandler implements IRouteHandler<IFolderRouteData> {
        protected currentFolderCounter: IUnreadCounter;
        protected currentFolderId: string;
        protected popupNotification: Noty;
        name: string;
        mountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: IFolderRouteData, routeType: RouteType): JQueryDeferred<{}>;
        protected onUnreadCountersChanged: () => void;
    }
}
declare namespace WebClient {
    interface IGetFilePreviewModelParams {
        fileInfo: {
            /** Идентификатор файла. */
            fileId: string;
            /** Идентификатор карточки файла. */
            fileCardId: string;
            /** Идентификатор версии файла. */
            versionId: string;
            /** Идентификатор карточки-владельца. */
            ownerCardId: string;
        };
        /** Текущий номер страницы. */
        pageIndex: number;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovingReportOpenedEventArgs extends GenModels.ApprovalHistoryViewModel {
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovingReportOpeningEventArgs {
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovingReportRefreshedEventArgs {
        cycleNumber: number;
        cycleInfo: GenModels.ApprovalHistoryCycleModel;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IApprovingReportRefreshingEventArgs {
        cycleNumber: number;
    }
}
declare namespace WebClient {
    interface IAgreementListTableColumn {
        class?: string;
        name: any;
        weight: number;
        calculatedWidth?: string;
        value: (item: GenModels.AgreementListItemModel) => string;
        hidden?: boolean;
        order: number;
    }
}
declare namespace WebClient {
    interface IAgreementListRenderEventArgs {
        model: GenModels.AgreementListModel;
        columns: IAgreementListTableColumn[];
    }
}
declare namespace WebClient {
    interface IAgreementListReportOpenedEventArgs {
        model: GenModels.AgreementListModel;
        contentControl: AgreementListContent;
    }
}
declare namespace WebClient {
    interface IAgreementListReportOpeningEventArgs {
        model: GenModels.AgreementListModel;
    }
}
declare namespace WebClient {
    /** @internal */
    class TemplateComboVariant implements IComboBoxVariant {
        template: GenModels.AgreementTemplateModel;
        constructor(val: GenModels.AgreementTemplateModel);
        readonly displayName: any;
        readonly uniqueId: string;
    }
}
declare namespace WebClient {
    enum ReconcileDurationType {
        PerTask = 0,
        PerStage = 1,
    }
}
declare namespace WebClient {
    interface IAgreementEventArgs extends IAgreementParams {
    }
}
declare namespace WebClient {
    interface IApproverDeletionEventArgs {
        employeeId: string;
        stage: StageModelWithChange;
    }
}
declare namespace WebClient {
    interface IApproverEventArgs {
        employeeInfo: IEmployeeItemData;
        stage: StageModelWithChange;
    }
}
declare namespace WebClient {
    interface IApprovingPathEventArgs {
        /** @deprecated */
        agreementTemplateId: string;
        /** @deprecated */
        agreementTemplateDisplayName: string;
        /** Информация о маршруте согласования. */
        template: GenModels.AgreementTemplateModel;
    }
}
declare namespace WebClient {
    interface ChangedPropertyInfo {
        name: string;
        oldValue: any;
        newValue: any;
    }
}
declare namespace WebClient {
    interface IBlurEventArgs extends React.FocusEvent<any> {
    }
}
declare namespace WebClient {
    interface IClickEventArgs extends React.MouseEvent<any> {
    }
}
declare namespace WebClient {
    interface IFocusEventArgs extends React.FocusEvent<any> {
    }
}
declare namespace WebClient {
    interface IMouseOutEventArgs extends React.MouseEvent<any> {
    }
}
declare namespace WebClient {
    interface IMouseOverEventArgs extends React.MouseEvent<any> {
    }
}
declare namespace WebClient {
    /** @internal */
    class CardKindTreeNodeModel {
        /** Card kind name */
        cardKindName: string;
        /** Card kind name with parent kinds */
        cardKindFullName: string;
        /** Card kind identifier */
        cardKindId: string;
        /** Card type identifier */
        cardTypeId: string;
        /** Is card kind available or not */
        notAvailable: boolean;
        /** Is card kind selectable */
        notSelectable: boolean;
        /** Is node open and its children visible */
        isOpen: boolean;
        /** Child kinds */
        kinds: CardKindTreeNodeModel[];
        constructor(model: GenModels.CardKindInfoModel);
    }
}
declare namespace WebClient {
    /** @internal */
    class CardKindTypeaheadVariant implements ITypeaheadVariant {
        data: CardKindTreeNodeModel;
        constructor(data: CardKindTreeNodeModel);
        readonly name: string;
        readonly value: string;
        readonly iconCssClass: string;
        readonly title: string;
    }
}
declare namespace WebClient {
    interface IComboBoxItem {
        data: IComboBoxVariant;
        selected: boolean;
    }
}
declare namespace WebClient {
    interface IComboBoxVariant {
        displayName: string;
        uniqueId: string;
    }
}
declare namespace WebClient {
    interface ICommentEventArgs {
        comment: GenModels.Comment;
    }
}
declare namespace WebClient {
    interface IDepartmentTreeNodeData {
        childrenLoaded: boolean;
        displayName: React.ReactNode;
        uniqueId: string;
        parentUniqueId?: string;
        iconClass: string;
        level: number;
        visible: boolean;
        children: IDepartmentTreeNodeData[];
        nodeClass?: string;
        disabled?: boolean;
        title?: string;
        loading?: LoadingState;
    }
    /** @internal */
    class DepartmentTreeNodeData implements IDepartmentTreeNodeData {
        private mData;
        private mChildren;
        private mName;
        private mExpanded;
        level: number;
        visible: boolean;
        parentUniqueId: string;
        loading: LoadingState;
        static Create(data: GenModels.DepartmentTreeNode, enabledItemTypes: GenModels.SearchDepartmentType): DepartmentTreeNodeData;
        static CreateMany(dataArray: GenModels.DepartmentTreeNode[], enabledItemTypes: GenModels.SearchDepartmentType): DepartmentTreeNodeData[];
        disabled: boolean;
        readonly data: GenModels.DepartmentTreeNode;
        displayName: React.ReactNode;
        readonly uniqueId: string;
        readonly title: string;
        readonly iconClass: string;
        children: DepartmentTreeNodeData[];
        expanded: boolean;
        childrenLoaded: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class DepartmentTypeaheadVariant implements ITypeaheadVariant {
        data: GenModels.DepartmentModel;
        constructor(data: GenModels.DepartmentModel);
        readonly name: string;
        readonly value: string;
        readonly iconCssClass: string;
        readonly title: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class DirectoryDesignerTreeNode implements IDynamicTreeNodeData {
        mData: GenModels.DirectoryDesignerTreeNode;
        mChildren: DirectoryDesignerTreeNode[];
        mName: React.ReactNode;
        static Create(data: GenModels.DirectoryDesignerTreeNode): DirectoryDesignerTreeNode;
        static CreateMany(dataArray: GenModels.DirectoryDesignerTreeNode[]): DirectoryDesignerTreeNode[];
        readonly data: GenModels.DirectoryDesignerTreeNode;
        displayName: React.ReactNode;
        readonly uniqueId: string;
        readonly iconClass: string;
        readonly children: ITreeNodeData[];
        expandedByDefault: boolean;
        childrenLoaded: boolean;
        readonly disabled: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class DirectoryDesignerTypeaheadVariant implements ITypeaheadVariant {
        data: GenModels.DirectoryDesignerRowModel;
        constructor(data: GenModels.DirectoryDesignerRowModel);
        readonly name: string;
        readonly value: string;
        readonly iconCssClass: string;
        readonly title: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class EmployeeTypeaheadVariant implements ITypeaheadVariant {
        data: GenModels.EmployeeDataModel;
        mTitle: string;
        mFavored: boolean;
        constructor(data: GenModels.EmployeeDataModel, title: string, favored?: boolean);
        readonly name: string;
        readonly value: string;
        readonly iconCssClass: string;
        readonly title: string;
        readonly favored: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class FileListAttachedElements {
        form: HTMLElement;
        filesContainer: HTMLElement;
        filesInput: HTMLElement;
        filesInputLabel: HTMLElement;
        dropZone: HTMLElement;
        timestampInput: HTMLInputElement;
        allElementsHasAttached: SimpleEvent<any>;
        constructor();
        attachForm(elem: HTMLElement): void;
        attachFilesContainer(elem: HTMLElement): void;
        attachFilesInput(elem: HTMLElement): void;
        attachFilesInputLabel(elem: HTMLElement): void;
        attachDropZone(elem: HTMLElement): void;
        attachTimestampInput(elem: HTMLInputElement): void;
        protected onElemAttached(): void;
        readonly allElementsAttached: boolean;
    }
}
declare namespace WebClient {
    /**
     * Предоставляет данные файла для элемента управления [Список файлов]{@link FileListControl}.
     */
    class FileListItem implements IFileListItem {
        data: GenModels.LayoutFileModel;
        settingsMenuExpaned: boolean;
        versionsListExanded: boolean;
        versionsListAnimating: boolean;
        comentsDialogOpen: boolean;
        uploadVersionAttachedElements: FileListAttachedElements;
        versionListElement: HTMLElement;
        itemComponent: FileListItemComponent;
        file: File;
        state: FileListItemState;
    }
}
declare namespace WebClient {
    class FileListBuiltInOperations {
        static ViewSignList: string;
        static EditMainFile: string;
        static ReadExtraFile: string;
        static LockMainFile: string;
        static AddExtraFile: string;
        static SignDocument: string;
        static RemoveMainFile: string;
        static AddMainFile: string;
        static AddCommentToMainFileVersion: string;
        static ReadMainFile: string;
        static RemoveExtraFile: string;
    }
}
declare namespace WebClient {
    interface IExtraFileAddedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IExtraFileAddingArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IExtraFileDeletedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IExtraFileDeletingArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IFileOpenedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IFileOpeningArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IFilePreviewedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IFilePreviewingArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IFileVersionCommentAddedArgs {
        fileItem: IFileListItem;
        commentText: string;
    }
}
declare namespace WebClient {
    interface IFileVersionCommentAddingArgs {
        fileItem: IFileListItem;
        commentText: string;
    }
}
declare namespace WebClient {
    interface IFileVersionCommentDeletedArgs {
        fileItem: IFileListItem;
        commentId: string;
    }
}
declare namespace WebClient {
    interface IFileVersionCommentDeletingArgs {
        fileItem: IFileListItem;
        commentId: string;
    }
}
declare namespace WebClient {
    interface IFileVersionDownloadedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IFileVersionDownloadingArgs {
        fileItem: IFileListItem;
        version: GenModels.VersionedFileModel;
    }
}
declare namespace WebClient {
    interface IFileVersionUploadedArgs {
        fileItem: IFileListItem;
        version: GenModels.VersionedFileModel;
    }
}
declare namespace WebClient {
    interface IFileVersionUploadingArgs {
        fileItem: IFileListItem;
        file: File;
    }
}
declare namespace WebClient {
    interface IMainFileAddedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IMainFileAddingArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IMainFileDeletedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IMainFileDeletingArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IMainFileNewVersionCreatedArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface IMainFileNewVersionCreatingArgs {
        fileItem: IFileListItem;
    }
}
declare namespace WebClient {
    interface ISignatureCreatedArgs {
    }
}
declare namespace WebClient {
    interface ISignatureCreatingArgs {
    }
}
declare namespace WebClient {
    interface ISignatureListViewedArgs {
    }
}
declare namespace WebClient {
    interface ISignatureListViewingArgs {
    }
}
declare namespace WebClient {
    /** См. {@link HistoryParams.recordsChanged} */
    interface IRecordsChangedEventArgs {
        records: GenModels.HistoryRecord[];
    }
}
declare namespace WebClient {
    /** Интерфейс события {@link InputBasedControlParams.dataChanged}. */
    interface IDataChangedEventArgs {
        oldValue: any;
        newValue: any;
    }
    /** Типизированная версия интерфейса {@link IDataChangedEventArgs} */
    interface IDataChangedEventArgsEx<T> extends IDataChangedEventArgs {
        oldValue: T;
        newValue: T;
    }
}
declare namespace WebClient {
    /** Информация о ссылке контрола {@link Links} */
    interface ILinkItem {
        /** Основная информация о ссылке. */
        data: GenModels.LayoutLinkModel;
        /** Сохранена ли ссылка на сервере, или находится в процессе сохранения. */
        state: LinkItemState;
    }
}
declare namespace WebClient {
    /** @internal */
    class KindTreeNodeData implements ITreeNodeData {
        kindModel: GenModels.LayoutKindModel;
        children: KindTreeNodeData[];
        trimmedName: string;
        constructor(kind: GenModels.LayoutKindModel, children: KindTreeNodeData[]);
        readonly displayName: string;
        readonly uniqueId: string;
        readonly iconClass: string;
        readonly disabled: boolean;
        private trimName(fullName);
    }
}
declare namespace WebClient {
    /** @internal */
    class LinkItem implements ILinkItem {
        data: GenModels.LayoutLinkModel;
        state: LinkItemState;
        settingsMenuExpanded: boolean;
        infoPopoverOpen: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class LinkTypeComboBoxVariant implements IComboBoxVariant {
        data: GenModels.LinkTypeModel;
        constructor(val: GenModels.LinkTypeModel);
        readonly displayName: any;
        readonly uniqueId: string;
    }
}
declare namespace WebClient {
    /** См. {@link ILinkItem.state}. */
    enum LinkItemState {
        /** Ссылка в процессе сохранения. */
        Saving = 0,
        /** Ссылка сохранена на сервере. */
        Saved = 1,
    }
}
declare namespace WebClient {
    /** Используется в событиях контрола {@link Links} */
    interface ILinkEventArgs {
        linkItem: ILinkItem;
    }
}
declare namespace WebClient {
    interface NewCardLinkDialogArgs {
        kind: GenModels.LayoutKindModel;
        linkType: GenModels.LinkTypeModel;
    }
}
declare namespace WebClient {
    type BaseNavigationItem = BaseNavigationMainMenuItem<BaseNavigationMainMenuItemParams, any>;
    class BaseNavigationMenuItemRouteHandler implements IRouteHandler<any> {
        private static Components;
        name: string;
        mountRoute?(routedata: any, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute?(data: any, routeType: RouteType): JQueryDeferred<{}>;
        private static unselectAllComponents();
        private static select(route);
        static register(control: BaseNavigationItem): void;
    }
}
declare namespace WebClient {
    /**
     * Содержит публичные свойства элемента управления {@link ConfigurableMainMenuContainerButton}.
     */
    class ConfigurableMainMenuContainerButtonParams extends BaseControlParams {
        /** Стандартный CSS класс со стилями элемента управления */
        standardCssClass?: string;
        /** Текст всплывающей подсказки. */
        tip?: string;
        /** Имя CSS класса, в котором определен путь к иконке, отображаемой в кнопке. */
        iconClass?: string;
        /** Открыто меню или нет. */
        menuExpanded?: boolean;
        /** Доступен ли элемент меню "Настроить панель". */
        showBeginConfigurationItem?: boolean;
        /** Доступен ли элемент меню "Вернуть настройки по умолчанию". */
        showRestoreItem?: boolean;
        /** Доступен ли элемент меню "Присоединить папку". */
        showAttachFolderItem?: boolean;
        /** Доступен ли элемент меню "Обновить дерево папок". */
        showRefreshFoldersItem?: boolean;
        /** Активирован элемент меню "Настроить панель". */
        beginConfigurationClicked?: BasicApiEvent<void>;
        /** Активирован элемент меню "Вернуть настройки по умолчанию". */
        restoreClicked?: BasicApiEvent<void>;
        /** Активирован элемент меню "Присоединить папку". */
        attachFolderClicked?: BasicApiEvent<void>;
        /** Активирован элемент меню "Обновить дерево папок". */
        refreshFoldersClicked?: BasicApiEvent<void>;
    }
    /**
     * Класс элемента управления Кнопка.
     *
     * Добавляет в web-разметку кнопку в виде иконки для вызова произвольной функции из скрипта карточки.
     */
    class ConfigurableMainMenuContainerButton extends BaseControl<ConfigurableMainMenuContainerButtonParams, ConfigurableMainMenuContainerButtonState> {
        constructor(props: ConfigurableMainMenuContainerButtonParams);
        /** @internal */
        protected createParams(): ConfigurableMainMenuContainerButtonParams;
        /** @internal */
        protected createImpl(): ConfigurableMainMenuContainerButtonImpl;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ConfigurableMainMenuContainerButtonState extends ConfigurableMainMenuContainerButtonParams, BaseControlState {
    }
    /** @internal */
    type ConfigurableMainMenuContainerButtonImplState = ConfigurableMainMenuContainerButtonState;
    /** @internal */
    class ConfigurableMainMenuContainerButtonImpl extends BaseControlImpl<ConfigurableMainMenuContainerButtonParams, ConfigurableMainMenuContainerButtonState> {
        constructor(props: ConfigurableMainMenuContainerButtonParams, state: ConfigurableMainMenuContainerButtonState);
        protected handleClick(event: React.MouseEvent<any>): void;
        protected onToggleMenuClick: () => void;
        protected onCloseMenu: () => void;
        protected onBeginConfigurationClick: () => void;
        protected onRestoreClick: () => void;
        protected onAttachFolderClick: () => void;
        protected onRefreshFoldersrClick: () => void;
        renderControl(): JSX.Element;
    }
}
declare namespace WebClient {
    /** Обработчик роута папки, служащий для обеспечения функционирования контролов {@link FolderMainMenuItem},
     * а также для загрузки дополнительной информации о папке при ее открытии. */
    class FolderMainMenuItemRouteHandler implements IRouteHandler<IFolderRouteData> {
        private services;
        static Components: {
            [folderId: string]: FolderMainMenuItem[];
        };
        constructor(services: $LayoutFolderController);
        name: string;
        prepareRouteDataLoad?(routeData: Partial<IFolderRouteData>, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        /** Инициирует загрузку элементов меню, для отображение указанной папки. */
        static loadSelectedFolder(parentNodes: string[]): void;
        /** Регистрирует соответствие папки и контрола FolderMainMenuItem.
         * Используется для получения дополнительной информации о папке при ее открытии. */
        static register(folderId: string, control: FolderMainMenuItem): void;
    }
}
declare namespace WebClient {
    /**
     * Закрывает боковую панель главного меню при переходе на другой роут.
     */
    class MainMenuRouteHandler implements IRouteHandler<any> {
        name: string;
        mountRoute?(data: any, routeType: RouteType): JQueryDeferred<RouteHandleResult>;
        unmountRoute(data: any, routeType: RouteType): JQueryDeferred<{}>;
    }
}
declare namespace WebClient {
    /** Модель данных для контрола {@link Numerator}. */
    interface INumberInfo extends GenModels.NumberInfo {
        /** Информация о привязке к полю карточки. */
        bindingInfo: GenModels.BindingInfo;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IPartnerDirectoryTreeItem extends GenModels.PartnerDirectoryItem {
        expanded?: boolean;
        loadingState?: LoadingState;
        displayName?: React.ReactNode;
        visible?: boolean;
        parentId?: string;
        level?: number;
    }
}
declare namespace WebClient {
    /** @internal */
    class PartnerTypeaheadVariant implements ITypeaheadVariant {
        item: GenModels.PartnerDirectoryItem;
        visualiser: PartnerHelpers.PartnerDirectoryItemVisualiser;
        constructor(item: GenModels.PartnerDirectoryItem, visualiser: PartnerHelpers.PartnerDirectoryItemVisualiser);
        readonly name: string;
        readonly value: string;
        readonly iconCssClass: string;
        readonly title: string;
    }
}
declare namespace WebClient {
    enum PartnerQueryTypes {
        QuickSearch = 0,
        LoadTree = 1,
        DirectorySearch = 2,
    }
    class IPartnerDataLoadingEventArgs {
        /** Из какого места контрола производится загрузка данных. */
        queryType: PartnerQueryTypes;
        /**
          * Запрашиваемая информация, включая текущий фильтр.
          *
          * В зависимости от значения {@link queryType} объект может быть представлен одним из производных интерфейсов:
          * 1) при `PartnerQueryTypes.QuickSearch` объект типа {@link WebClient.GenModels.PartnerQuickSearchQuery}
          * 2) при `PartnerQueryTypes.DirectorySearch` объект типа {@link WebClient.GenModels.PartnerQuickSearchQuery}
          * 3) при `PartnerQueryTypes.LoadTree` объект типа {@link WebClient.GenModels.PartnerLoadQuery}
          */
        query: GenModels.PartnerLoadQuery | GenModels.PartnerQuickSearchQuery;
        /**
          * Результат выполнения запроса.
          *
          * В зависимости от значения {@link queryType} объект может быть представлен одним из производных интерфейсов:
          * 1) при `PartnerQueryTypes.QuickSearch` объект типа {@link WebClient.GenModels.PartnerQuickSearchResponse}
          * 2) при `PartnerQueryTypes.DirectorySearch` объект типа {@link WebClient.GenModels.PartnerSearchResponse}
          * 3) при `PartnerQueryTypes.LoadTree` объект типа {@link WebClient.GenModels.PartnerTreeLoadResponse}
          */
        result?: GenModels.PartnerSearchResponse | GenModels.PartnerTreeLoadResponse;
    }
}
declare namespace WebClient {
    class IPartnerFilterChangeEventArgs {
        oldValue: GenModels.DepartmentModel[];
        newValue: GenModels.DepartmentModel[];
    }
}
declare namespace WebClient {
    enum SavingButton {
        Save = 0,
        Cancel = 1,
    }
}
declare namespace WebClient {
    interface ISavingButtonClickEventArgs {
        button: SavingButton;
    }
}
declare namespace WebClient {
    class TabPageInfo {
        header: string;
        key: string;
        data: GenModels.ControlModel;
        loadingState: LoadingState;
        mobileTab: HTMLElement;
        constructor(data: GenModels.ControlModel);
        readonly loaded: boolean;
    }
}
declare namespace WebClient {
    interface IActiveTabChangeEventArgs {
        oldTabIndex: number;
        newTabIndex: number;
    }
}
declare namespace WebClient {
    interface IRowInfo {
        rowId: string;
        htmlElem: HTMLElement;
        columns: GenModels.ControlModel[];
        removeRowHelper: RequestHelper;
    }
}
declare namespace WebClient {
    class TableColumnWrapper implements GenModels.LayoutTableColumnInfo {
        private _private;
        constructor(info: GenModels.LayoutTableColumnInfo, table: Table, columnNumber: number);
        header: string;
        columnWidth: string;
        tip: string;
        visibility: boolean;
    }
}
declare namespace WebClient {
    interface IRowEventArgs {
        rowId: string;
    }
}
declare namespace WebClient {
    /** Используется в событиях контрола {@link Tasks}. */
    interface ITaskCreatingEventArgs {
        cardTypeId: string;
        cardKindId: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IHiddenNode {
        nodeId: vis.IdType;
        linkedWithNodeId: vis.IdType;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeColor {
        color: string;
        background: string;
        border: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeColorMap {
        [aliasName: string]: ITasksTreeColor;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeEdgeContainer extends vis.Edge {
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeGroup {
        colorAlias: string;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeGroupMap {
        [aliasName: string]: ITasksTreeGroup | any;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeNodeContainer extends vis.Node {
        isIndicator?: boolean;
        parentNodeId?: vis.IdType;
        indicatorType?: IndicatorType;
        borderWidth?: number;
        title?: HTMLElement | string;
        nodeModel: GenModels.TreeNodeModel;
        collapsed?: boolean;
        collapsedBySetting?: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface IVisClickParams {
        nodes?: vis.IdType[];
        edges?: vis.IdType[];
        event?: MouseEvent;
    }
}
declare namespace WebClient {
    /** @internal */
    enum IndicatorType {
        None = 0,
        Overdue = 1,
        Priority = 2,
        OnControl = 3,
        ResponsibleTask = 4,
        Report = 5,
        Expand = 6,
        Collapse = 7,
        CurrentNode = 8,
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeNodeResolver {
        resolveNode(treeNodeModel: GenModels.TreeNodeModel, props: ITasksTreeContainerProps, state: ITasksTreeContainerState): ITasksTreeNodeContainer[];
        resolveRenderHelpBox(props: ITasksTreeContainerProps, state: ITasksTreeContainerState): React.ReactNode;
        selectionAllowed: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITasksTreeNodeResolverMap {
        [cardTypeId: string]: ITasksTreeNodeResolver;
    }
}
declare namespace WebClient {
    /** @internal */
    class TasksTreeNodeResolveService {
        resolvers: ITasksTreeNodeResolverMap;
        defaultResolver: ITasksTreeNodeResolver;
        register(cardTypeId: string, resolver: ITasksTreeNodeResolver, override?: boolean): void;
        get(cardTypeId: string): ITasksTreeNodeResolver;
    }
}
declare namespace WebClient {
    /** @internal */
    interface TextAreaAutosize {
        autosize(el: Element): void;
    }
}
declare namespace WebClient {
    interface IComboBoxElement {
        /** Уникальный идентификатор среди соседних элементов */
        id: string;
        /** Отображаемый заголовок элемента */
        title: string;
        /** Запретить взаимодействие с элементом в списке */
        disabled?: boolean;
        /** Объект с любыми пользовательскими данными (по умолчанию - undefined) */
        data?: any;
    }
}
declare namespace WebClient {
    /**
     * @review
     * Вспомогательный компонент для отрисовки дерева.
     *
     * Пример использования (вместо CustomTreeDefault можно использовать div):
     *
     *     <CustomTreeDefault>
     *         <div className="display-flex align-items-stretch">
     *             <CustomTreeLevelIndent level={0} />
     *             <CustomTreeNodeTogglerDefault expanded visible onClick={() => console.log('Нажат переключатель')} />
     *             <CustomTreeNodeContentDefault tabIndex selected disabled onClick={() => console.log('Первый узел')}>
     *                 <CustomTreeNodeIconDefault />
     *                 <CustomTreeNodeTextDefault>Первый узел</CustomTreeNodeTextDefault>
     *            </CustomTreeNodeContentDefault>
     *         </div>
     *
     *         <div className="display-flex align-items-stretch">
     *             <CustomTreeLevelIndent level={0} />
     *             <CustomTreeNodeTogglerDefault expanded visible onClick={() => console.log('Нажат переключатель')} />
     *             <CustomTreeNodeContentDefault tabIndex selected disabled onClick={() => console.log('Второй узел')}>
     *                 <CustomTreeNodeIconDefault />
     *                 <CustomTreeNodeTextDefault innerRef={attachTooltip('Подсказка второго узла')}>Второй узел</CustomTreeNodeTextDefault>
     *             </CustomTreeNodeContentDefault>
     *         </div>
     *     </CustomTreeDefault>
     *
     */
    const CustomTreeDefault: styled.StyledComponentClass<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        className: string;
    }, any, React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>>;
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNodeIconDefault }  */
    interface ICustomTreeNodeIconDefaultProps {
    }
    /** Иконка узла дерева. Пример использования см. {@link CustomTreeDefault} */
    const CustomTreeNodeIconDefault: styled.StyledComponentClass<React.ClassAttributes<HTMLSpanElement> & React.HTMLAttributes<HTMLSpanElement> & ICustomTreeNodeIconDefaultProps, any, React.ClassAttributes<HTMLSpanElement> & React.HTMLAttributes<HTMLSpanElement> & ICustomTreeNodeIconDefaultProps>;
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNodeLoadingIconDefault }  */
    interface ICustomTreeNodeLoadingIconDefaultProps {
        /** Дополнительный класс */
        className?: string;
    }
    /** Иконка загрузки узла дерева. Пример использования см. {@link CustomTreeDefault} */
    const CustomTreeNodeLoadingIconDefault: styled.StyledComponentClass<React.ClassAttributes<HTMLSpanElement> & React.HTMLAttributes<HTMLSpanElement> & ICustomTreeNodeIconDefaultProps & {
        className: string;
    }, any, React.ClassAttributes<HTMLSpanElement> & React.HTMLAttributes<HTMLSpanElement> & ICustomTreeNodeIconDefaultProps>;
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNodeTextDefault }  */
    interface ICustomTreeNodeTextDefaultProps {
        /** Дополнительный класс */
        className?: string;
        /** Содержимое */
        children?: React.ReactNode;
    }
    /** Текст узла дерева. Пример использования см. {@link CustomTreeDefault} */
    const CustomTreeNodeTextDefault: styled.StyledComponentClass<React.ClassAttributes<HTMLSpanElement> & React.HTMLAttributes<HTMLSpanElement> & ICustomTreeNodeTextDefaultProps, any, React.ClassAttributes<HTMLSpanElement> & React.HTMLAttributes<HTMLSpanElement> & ICustomTreeNodeTextDefaultProps>;
}
declare namespace WebClient {
    /** @review Свойства для {@link CustomTreeNodeTextDefault}  */
    interface ICustomTreeNodeTogglerProps {
        /** Виден ли переключатель или просто занимает место */
        visible?: boolean;
        /** Раскрыт ли переключатель */
        expanded?: boolean;
        /** Дополнительный класс */
        className?: string;
        /** Дополнительный класс при раскрытии */
        expandedClass?: string;
        /** Дополнительный класс при закрытии */
        collapsedClass?: string;
        /** При клике */
        onClick?: () => void;
    }
    /**
     * @internal См. {@link CustomTreeNodeTogglerDefault}
     */
    class CustomTreeNodeToggler extends React.Component<ICustomTreeNodeTogglerProps, undefined> {
        render(): JSX.Element;
    }
    /**
     * Переключатель узла дерева
     * Пример использования см. в {@link CustomTreeDefault}
     */
    const CustomTreeNodeTogglerDefault: styled.StyledComponentClass<ICustomTreeNodeTogglerProps, any, styled.WithOptionalTheme<ICustomTreeNodeTogglerProps, any>>;
}
declare namespace WebClient {
    /**
      * @internal Интерфейс для элемента списка перетаскиваемых элементов для {@link Sortable}
      */
    interface ISortableItem<T> {
        /** Уникальный идентификатор среди соседних элементов */
        id: string | number;
        /** Данные элемента, который будет использоваться для рендеринга */
        data: T;
        /** Компонент, который нужно отрендерить */
        render: (data: T) => React.ReactNode;
    }
}
declare namespace WebClient {
    /** @internal */
    interface ITreeNodeData {
        displayName: React.ReactNode;
        uniqueId: string;
        iconClass: string;
        children: ITreeNodeData[];
        nodeClass?: string;
        disabled?: boolean;
        expandedByDefault?: boolean;
        title?: string;
    }
}
declare namespace WebClient {
    /** @internal */
    class DefaultTasksTreeNodeResolver implements ITasksTreeNodeResolver {
        resolveNode(treeNodeModel: GenModels.TreeNodeModel, props: ITasksTreeContainerProps, state: ITasksTreeContainerState): ITasksTreeNodeContainer[];
        resolveRenderHelpBox(props: ITasksTreeContainerProps, state: ITasksTreeContainerState): React.ReactNode;
        readonly selectionAllowed: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class DocumentTasksTreeNodeResolver implements ITasksTreeNodeResolver {
        resolveNode(treeNodeModel: GenModels.TreeNodeModel, props: ITasksTreeContainerProps, state: ITasksTreeContainerState): ITasksTreeNodeContainer[];
        resolveRenderHelpBox(props: ITasksTreeContainerProps, state: ITasksTreeContainerState): React.ReactNode;
        readonly selectionAllowed: boolean;
    }
}
declare namespace WebClient {
    /** @internal */
    class GroupTaskTasksTreeNodeResolver implements ITasksTreeNodeResolver {
        resolveNode(treeNodeModel: GenModels.TreeNodeModel, props: ITasksTreeContainerProps, state: ITasksTreeContainerState): ITasksTreeNodeContainer[];
        resolveRenderHelpBox(props: ITasksTreeContainerProps, state: ITasksTreeContainerState): React.ReactNode;
        readonly selectionAllowed: boolean;
        protected getIndicatorNodes(nodeModel: GenModels.TaskGroupTreeNodeModel): ITasksTreeNodeContainer[];
        protected getGroup(nodeModel: GenModels.TaskGroupTreeNodeModel): string;
        protected getHelpBoxHeaderIcon(groupName: any): string;
        protected getLabel(nodeModel: GenModels.TaskGroupTreeNodeModel, props: ITasksTreeContainerProps, state: ITasksTreeContainerState): string;
        protected getImage(nodeModel: GenModels.TaskGroupTreeNodeModel): string;
        protected prepareView(node: ITasksTreeNodeContainer, nodeModel: GenModels.TaskGroupTreeNodeModel, props: ITasksTreeContainerProps): any;
        protected getTitle(node: ITasksTreeNodeContainer, nodeModel: GenModels.TaskGroupTreeNodeModel, props: ITasksTreeContainerProps): string;
        private getExecutionTypeResourceKey(executionType);
    }
}
declare namespace WebClient {
    /** @internal */
    class TaskTasksTreeNodeResolver implements ITasksTreeNodeResolver {
        private services;
        private readonly moreDots;
        constructor(services: () => $FileController & $LayoutFileController);
        resolveNode(treeNodeModel: GenModels.TreeNodeModel, props: ITasksTreeContainerProps, state: ITasksTreeContainerState): ITasksTreeNodeContainer[];
        resolveRenderHelpBox(props: ITasksTreeContainerProps, state: ITasksTreeContainerState): React.ReactNode;
        readonly selectionAllowed: boolean;
        protected renderDelegateList(taskNodeHelpModel: GenModels.TaskTreeNodeHelpModel, color: ITasksTreeColor, state: ITasksTreeContainerState): JSX.Element;
        protected getIndicatorNodes(nodeModel: GenModels.TaskTreeNodeModel): ITasksTreeNodeContainer[];
        protected getGroup(nodeModel: GenModels.TaskTreeNodeModel): string;
        protected getHelpBoxHeaderIcon(groupName: any): string;
        protected getLabel(nodeModel: GenModels.TaskTreeNodeModel): string;
        protected getImage(nodeModel: GenModels.TaskTreeNodeModel): string;
        protected prepareView(node: ITasksTreeNodeContainer, nodeModel: GenModels.TaskTreeNodeModel, props: ITasksTreeContainerProps): any;
        protected getTitle(node: ITasksTreeNodeContainer, nodeModel: GenModels.TaskTreeNodeModel, props: ITasksTreeContainerProps): string;
        protected getDelegationLabel(delegationRecord: GenModels.DelegationRecord): string;
        protected getDelegationHistory(delegationRecords: GenModels.DelegationRecord[]): string[];
        protected showFilePreview(linkItemData: GenModels.LayoutLinkModel): void;
    }
}
